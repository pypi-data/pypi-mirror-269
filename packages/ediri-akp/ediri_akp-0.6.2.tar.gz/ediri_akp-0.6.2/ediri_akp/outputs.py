# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from . import _utilities
from . import outputs

__all__ = [
    'ClusterKubeConfig',
    'ClusterSpec',
    'ClusterSpecData',
    'InstanceArgocd',
    'InstanceArgocdSpec',
    'InstanceArgocdSpecInstanceSpec',
    'InstanceArgocdSpecInstanceSpecAppSetDelegate',
    'InstanceArgocdSpecInstanceSpecAppSetDelegateManagedCluster',
    'InstanceArgocdSpecInstanceSpecAppsetPolicy',
    'InstanceArgocdSpecInstanceSpecClusterCustomizationDefaults',
    'InstanceArgocdSpecInstanceSpecExtension',
    'InstanceArgocdSpecInstanceSpecHostAlias',
    'InstanceArgocdSpecInstanceSpecImageUpdaterDelegate',
    'InstanceArgocdSpecInstanceSpecImageUpdaterDelegateManagedCluster',
    'InstanceArgocdSpecInstanceSpecIpAllowList',
    'InstanceArgocdSpecInstanceSpecRepoServerDelegate',
    'InstanceArgocdSpecInstanceSpecRepoServerDelegateManagedCluster',
    'InstanceConfigManagementPlugins',
    'InstanceConfigManagementPluginsSpec',
    'InstanceConfigManagementPluginsSpecDiscover',
    'InstanceConfigManagementPluginsSpecDiscoverFind',
    'InstanceConfigManagementPluginsSpecGenerate',
    'InstanceConfigManagementPluginsSpecInit',
    'InstanceConfigManagementPluginsSpecParameters',
    'InstanceConfigManagementPluginsSpecParametersDynamic',
    'InstanceConfigManagementPluginsSpecParametersStatic',
    'GetClusterKubeConfigResult',
    'GetClusterSpecResult',
    'GetClusterSpecDataResult',
    'GetClustersClusterResult',
    'GetClustersClusterKubeConfigResult',
    'GetClustersClusterSpecResult',
    'GetClustersClusterSpecDataResult',
    'GetInstanceArgocdResult',
    'GetInstanceArgocdSpecResult',
    'GetInstanceArgocdSpecInstanceSpecResult',
    'GetInstanceArgocdSpecInstanceSpecAppSetDelegateResult',
    'GetInstanceArgocdSpecInstanceSpecAppSetDelegateManagedClusterResult',
    'GetInstanceArgocdSpecInstanceSpecAppsetPolicyResult',
    'GetInstanceArgocdSpecInstanceSpecClusterCustomizationDefaultsResult',
    'GetInstanceArgocdSpecInstanceSpecExtensionResult',
    'GetInstanceArgocdSpecInstanceSpecHostAliasResult',
    'GetInstanceArgocdSpecInstanceSpecImageUpdaterDelegateResult',
    'GetInstanceArgocdSpecInstanceSpecImageUpdaterDelegateManagedClusterResult',
    'GetInstanceArgocdSpecInstanceSpecIpAllowListResult',
    'GetInstanceArgocdSpecInstanceSpecRepoServerDelegateResult',
    'GetInstanceArgocdSpecInstanceSpecRepoServerDelegateManagedClusterResult',
    'GetInstanceConfigManagementPluginsResult',
    'GetInstanceConfigManagementPluginsSpecResult',
    'GetInstanceConfigManagementPluginsSpecDiscoverResult',
    'GetInstanceConfigManagementPluginsSpecDiscoverFindResult',
    'GetInstanceConfigManagementPluginsSpecGenerateResult',
    'GetInstanceConfigManagementPluginsSpecInitResult',
    'GetInstanceConfigManagementPluginsSpecParametersResult',
    'GetInstanceConfigManagementPluginsSpecParametersDynamicResult',
    'GetInstanceConfigManagementPluginsSpecParametersStaticResult',
]

@pulumi.output_type
class ClusterKubeConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientCertificate":
            suggest = "client_certificate"
        elif key == "clientKey":
            suggest = "client_key"
        elif key == "clusterCaCertificate":
            suggest = "cluster_ca_certificate"
        elif key == "configContext":
            suggest = "config_context"
        elif key == "configContextAuthInfo":
            suggest = "config_context_auth_info"
        elif key == "configContextCluster":
            suggest = "config_context_cluster"
        elif key == "configPath":
            suggest = "config_path"
        elif key == "configPaths":
            suggest = "config_paths"
        elif key == "proxyUrl":
            suggest = "proxy_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterKubeConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterKubeConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterKubeConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_certificate: Optional[str] = None,
                 client_key: Optional[str] = None,
                 cluster_ca_certificate: Optional[str] = None,
                 config_context: Optional[str] = None,
                 config_context_auth_info: Optional[str] = None,
                 config_context_cluster: Optional[str] = None,
                 config_path: Optional[str] = None,
                 config_paths: Optional[Sequence[str]] = None,
                 host: Optional[str] = None,
                 insecure: Optional[bool] = None,
                 password: Optional[str] = None,
                 proxy_url: Optional[str] = None,
                 token: Optional[str] = None,
                 username: Optional[str] = None):
        """
        :param str client_certificate: PEM-encoded client certificate for TLS authentication.
        :param str client_key: PEM-encoded client certificate key for TLS authentication.
        :param str cluster_ca_certificate: PEM-encoded root certificates bundle for TLS authentication.
        :param str config_context: Context name to load from the kube config file.
        :param str config_path: Path to the kube config file.
        :param Sequence[str] config_paths: A list of paths to kube config files.
        :param str host: The hostname (in form of URI) of Kubernetes master.
        :param bool insecure: Whether server should be accessed without verifying the TLS certificate.
        :param str password: The password to use for HTTP basic authentication when accessing the Kubernetes master endpoint.
        :param str proxy_url: URL to the proxy to be used for all API requests
        :param str token: Token to authenticate an service account
        :param str username: The username to use for HTTP basic authentication when accessing the Kubernetes master endpoint.
        """
        if client_certificate is not None:
            pulumi.set(__self__, "client_certificate", client_certificate)
        if client_key is not None:
            pulumi.set(__self__, "client_key", client_key)
        if cluster_ca_certificate is not None:
            pulumi.set(__self__, "cluster_ca_certificate", cluster_ca_certificate)
        if config_context is not None:
            pulumi.set(__self__, "config_context", config_context)
        if config_context_auth_info is not None:
            pulumi.set(__self__, "config_context_auth_info", config_context_auth_info)
        if config_context_cluster is not None:
            pulumi.set(__self__, "config_context_cluster", config_context_cluster)
        if config_path is not None:
            pulumi.set(__self__, "config_path", config_path)
        if config_paths is not None:
            pulumi.set(__self__, "config_paths", config_paths)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if insecure is not None:
            pulumi.set(__self__, "insecure", insecure)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if proxy_url is not None:
            pulumi.set(__self__, "proxy_url", proxy_url)
        if token is not None:
            pulumi.set(__self__, "token", token)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="clientCertificate")
    def client_certificate(self) -> Optional[str]:
        """
        PEM-encoded client certificate for TLS authentication.
        """
        return pulumi.get(self, "client_certificate")

    @property
    @pulumi.getter(name="clientKey")
    def client_key(self) -> Optional[str]:
        """
        PEM-encoded client certificate key for TLS authentication.
        """
        return pulumi.get(self, "client_key")

    @property
    @pulumi.getter(name="clusterCaCertificate")
    def cluster_ca_certificate(self) -> Optional[str]:
        """
        PEM-encoded root certificates bundle for TLS authentication.
        """
        return pulumi.get(self, "cluster_ca_certificate")

    @property
    @pulumi.getter(name="configContext")
    def config_context(self) -> Optional[str]:
        """
        Context name to load from the kube config file.
        """
        return pulumi.get(self, "config_context")

    @property
    @pulumi.getter(name="configContextAuthInfo")
    def config_context_auth_info(self) -> Optional[str]:
        return pulumi.get(self, "config_context_auth_info")

    @property
    @pulumi.getter(name="configContextCluster")
    def config_context_cluster(self) -> Optional[str]:
        return pulumi.get(self, "config_context_cluster")

    @property
    @pulumi.getter(name="configPath")
    def config_path(self) -> Optional[str]:
        """
        Path to the kube config file.
        """
        return pulumi.get(self, "config_path")

    @property
    @pulumi.getter(name="configPaths")
    def config_paths(self) -> Optional[Sequence[str]]:
        """
        A list of paths to kube config files.
        """
        return pulumi.get(self, "config_paths")

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        """
        The hostname (in form of URI) of Kubernetes master.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def insecure(self) -> Optional[bool]:
        """
        Whether server should be accessed without verifying the TLS certificate.
        """
        return pulumi.get(self, "insecure")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        The password to use for HTTP basic authentication when accessing the Kubernetes master endpoint.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter(name="proxyUrl")
    def proxy_url(self) -> Optional[str]:
        """
        URL to the proxy to be used for all API requests
        """
        return pulumi.get(self, "proxy_url")

    @property
    @pulumi.getter
    def token(self) -> Optional[str]:
        """
        Token to authenticate an service account
        """
        return pulumi.get(self, "token")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        The username to use for HTTP basic authentication when accessing the Kubernetes master endpoint.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ClusterSpec(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "namespaceScoped":
            suggest = "namespace_scoped"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterSpec. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterSpec.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterSpec.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data: 'outputs.ClusterSpecData',
                 description: Optional[str] = None,
                 namespace_scoped: Optional[bool] = None):
        """
        :param 'ClusterSpecDataArgs' data: Cluster data
        :param str description: Cluster description
        :param bool namespace_scoped: If the agent is namespace scoped
        """
        pulumi.set(__self__, "data", data)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if namespace_scoped is not None:
            pulumi.set(__self__, "namespace_scoped", namespace_scoped)

    @property
    @pulumi.getter
    def data(self) -> 'outputs.ClusterSpecData':
        """
        Cluster data
        """
        return pulumi.get(self, "data")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Cluster description
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="namespaceScoped")
    def namespace_scoped(self) -> Optional[bool]:
        """
        If the agent is namespace scoped
        """
        return pulumi.get(self, "namespace_scoped")


@pulumi.output_type
class ClusterSpecData(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "appReplication":
            suggest = "app_replication"
        elif key == "autoUpgradeDisabled":
            suggest = "auto_upgrade_disabled"
        elif key == "redisTunneling":
            suggest = "redis_tunneling"
        elif key == "targetVersion":
            suggest = "target_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterSpecData. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterSpecData.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterSpecData.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 size: str,
                 app_replication: Optional[bool] = None,
                 auto_upgrade_disabled: Optional[bool] = None,
                 kustomization: Optional[str] = None,
                 redis_tunneling: Optional[bool] = None,
                 target_version: Optional[str] = None):
        """
        :param str size: Cluster Size. One of `small`, `medium` or `large`
        :param bool app_replication: Enables Argo CD state replication to the managed cluster that allows disconnecting the cluster from Akuity Platform without losing core Argocd features
        :param str kustomization: Kustomize configuration that will be applied to generated agent installation manifests
        :param bool redis_tunneling: Enables the ability to connect to Redis over a web-socket tunnel that allows using Akuity agent behind HTTPS proxy
        :param str target_version: The version of the agent to install on your cluster
        """
        pulumi.set(__self__, "size", size)
        if app_replication is not None:
            pulumi.set(__self__, "app_replication", app_replication)
        if auto_upgrade_disabled is not None:
            pulumi.set(__self__, "auto_upgrade_disabled", auto_upgrade_disabled)
        if kustomization is not None:
            pulumi.set(__self__, "kustomization", kustomization)
        if redis_tunneling is not None:
            pulumi.set(__self__, "redis_tunneling", redis_tunneling)
        if target_version is not None:
            pulumi.set(__self__, "target_version", target_version)

    @property
    @pulumi.getter
    def size(self) -> str:
        """
        Cluster Size. One of `small`, `medium` or `large`
        """
        return pulumi.get(self, "size")

    @property
    @pulumi.getter(name="appReplication")
    def app_replication(self) -> Optional[bool]:
        """
        Enables Argo CD state replication to the managed cluster that allows disconnecting the cluster from Akuity Platform without losing core Argocd features
        """
        return pulumi.get(self, "app_replication")

    @property
    @pulumi.getter(name="autoUpgradeDisabled")
    def auto_upgrade_disabled(self) -> Optional[bool]:
        return pulumi.get(self, "auto_upgrade_disabled")

    @property
    @pulumi.getter
    def kustomization(self) -> Optional[str]:
        """
        Kustomize configuration that will be applied to generated agent installation manifests
        """
        return pulumi.get(self, "kustomization")

    @property
    @pulumi.getter(name="redisTunneling")
    def redis_tunneling(self) -> Optional[bool]:
        """
        Enables the ability to connect to Redis over a web-socket tunnel that allows using Akuity agent behind HTTPS proxy
        """
        return pulumi.get(self, "redis_tunneling")

    @property
    @pulumi.getter(name="targetVersion")
    def target_version(self) -> Optional[str]:
        """
        The version of the agent to install on your cluster
        """
        return pulumi.get(self, "target_version")


@pulumi.output_type
class InstanceArgocd(dict):
    def __init__(__self__, *,
                 spec: 'outputs.InstanceArgocdSpec'):
        """
        :param 'InstanceArgocdSpecArgs' spec: Argo CD instance spec
        """
        pulumi.set(__self__, "spec", spec)

    @property
    @pulumi.getter
    def spec(self) -> 'outputs.InstanceArgocdSpec':
        """
        Argo CD instance spec
        """
        return pulumi.get(self, "spec")


@pulumi.output_type
class InstanceArgocdSpec(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "instanceSpec":
            suggest = "instance_spec"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceArgocdSpec. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceArgocdSpec.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceArgocdSpec.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 instance_spec: 'outputs.InstanceArgocdSpecInstanceSpec',
                 version: str,
                 description: Optional[str] = None):
        """
        :param 'InstanceArgocdSpecInstanceSpecArgs' instance_spec: Argo CD instance spec
        :param str version: Argo CD version. Should be equal to any Akuity [`argocd` image tag](https://quay.io/repository/akuity/argocd?tab=tags).
        :param str description: Instance description
        """
        pulumi.set(__self__, "instance_spec", instance_spec)
        pulumi.set(__self__, "version", version)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter(name="instanceSpec")
    def instance_spec(self) -> 'outputs.InstanceArgocdSpecInstanceSpec':
        """
        Argo CD instance spec
        """
        return pulumi.get(self, "instance_spec")

    @property
    @pulumi.getter
    def version(self) -> str:
        """
        Argo CD version. Should be equal to any Akuity [`argocd` image tag](https://quay.io/repository/akuity/argocd?tab=tags).
        """
        return pulumi.get(self, "version")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Instance description
        """
        return pulumi.get(self, "description")


@pulumi.output_type
class InstanceArgocdSpecInstanceSpec(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "appSetDelegate":
            suggest = "app_set_delegate"
        elif key == "appsetPolicy":
            suggest = "appset_policy"
        elif key == "assistantExtensionEnabled":
            suggest = "assistant_extension_enabled"
        elif key == "auditExtensionEnabled":
            suggest = "audit_extension_enabled"
        elif key == "backendIpAllowListEnabled":
            suggest = "backend_ip_allow_list_enabled"
        elif key == "clusterCustomizationDefaults":
            suggest = "cluster_customization_defaults"
        elif key == "declarativeManagementEnabled":
            suggest = "declarative_management_enabled"
        elif key == "hostAliases":
            suggest = "host_aliases"
        elif key == "imageUpdaterDelegate":
            suggest = "image_updater_delegate"
        elif key == "imageUpdaterEnabled":
            suggest = "image_updater_enabled"
        elif key == "ipAllowLists":
            suggest = "ip_allow_lists"
        elif key == "repoServerDelegate":
            suggest = "repo_server_delegate"
        elif key == "syncHistoryExtensionEnabled":
            suggest = "sync_history_extension_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceArgocdSpecInstanceSpec. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceArgocdSpecInstanceSpec.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceArgocdSpecInstanceSpec.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 app_set_delegate: Optional['outputs.InstanceArgocdSpecInstanceSpecAppSetDelegate'] = None,
                 appset_policy: Optional['outputs.InstanceArgocdSpecInstanceSpecAppsetPolicy'] = None,
                 assistant_extension_enabled: Optional[bool] = None,
                 audit_extension_enabled: Optional[bool] = None,
                 backend_ip_allow_list_enabled: Optional[bool] = None,
                 cluster_customization_defaults: Optional['outputs.InstanceArgocdSpecInstanceSpecClusterCustomizationDefaults'] = None,
                 declarative_management_enabled: Optional[bool] = None,
                 extensions: Optional[Sequence['outputs.InstanceArgocdSpecInstanceSpecExtension']] = None,
                 host_aliases: Optional[Sequence['outputs.InstanceArgocdSpecInstanceSpecHostAlias']] = None,
                 image_updater_delegate: Optional['outputs.InstanceArgocdSpecInstanceSpecImageUpdaterDelegate'] = None,
                 image_updater_enabled: Optional[bool] = None,
                 ip_allow_lists: Optional[Sequence['outputs.InstanceArgocdSpecInstanceSpecIpAllowList']] = None,
                 repo_server_delegate: Optional['outputs.InstanceArgocdSpecInstanceSpecRepoServerDelegate'] = None,
                 subdomain: Optional[str] = None,
                 sync_history_extension_enabled: Optional[bool] = None):
        """
        :param 'InstanceArgocdSpecInstanceSpecAppSetDelegateArgs' app_set_delegate: Select cluster in which you want to Install Application Set controller
        :param 'InstanceArgocdSpecInstanceSpecAppsetPolicyArgs' appset_policy: Configures Application Set policy settings.
        :param bool assistant_extension_enabled: Enable Powerful AI-powered assistant Extension. It helps analyze Kubernetes resources behavior and provides suggestions about resolving issues.
        :param bool audit_extension_enabled: Enable Audit Extension. Set this to `true` to install Audit Extension to Argo CD instance.
        :param bool backend_ip_allow_list_enabled: Enable ip allow list for cluster agents
        :param 'InstanceArgocdSpecInstanceSpecClusterCustomizationDefaultsArgs' cluster_customization_defaults: Default values for cluster agents
        :param bool declarative_management_enabled: Enable Declarative Management
        :param Sequence['InstanceArgocdSpecInstanceSpecExtensionArgs'] extensions: Extensions
        :param Sequence['InstanceArgocdSpecInstanceSpecHostAliasArgs'] host_aliases: Host Aliases that override the DNS entries for control plane Argo CD components such as API Server and Dex.
        :param 'InstanceArgocdSpecInstanceSpecImageUpdaterDelegateArgs' image_updater_delegate: Select cluster in which you want to Install Image Updater
        :param bool image_updater_enabled: Enable Image Updater
        :param Sequence['InstanceArgocdSpecInstanceSpecIpAllowListArgs'] ip_allow_lists: IP allow list
        :param 'InstanceArgocdSpecInstanceSpecRepoServerDelegateArgs' repo_server_delegate: In case some clusters don't have network access to your private Git provider you can delegate these operations to one specific cluster.
        :param str subdomain: Instance subdomain. By default equals to instance id
        :param bool sync_history_extension_enabled: Enable Sync History Extension. Sync count and duration graphs as well as event details table on Argo CD application details page.
        """
        if app_set_delegate is not None:
            pulumi.set(__self__, "app_set_delegate", app_set_delegate)
        if appset_policy is not None:
            pulumi.set(__self__, "appset_policy", appset_policy)
        if assistant_extension_enabled is not None:
            pulumi.set(__self__, "assistant_extension_enabled", assistant_extension_enabled)
        if audit_extension_enabled is not None:
            pulumi.set(__self__, "audit_extension_enabled", audit_extension_enabled)
        if backend_ip_allow_list_enabled is not None:
            pulumi.set(__self__, "backend_ip_allow_list_enabled", backend_ip_allow_list_enabled)
        if cluster_customization_defaults is not None:
            pulumi.set(__self__, "cluster_customization_defaults", cluster_customization_defaults)
        if declarative_management_enabled is not None:
            pulumi.set(__self__, "declarative_management_enabled", declarative_management_enabled)
        if extensions is not None:
            pulumi.set(__self__, "extensions", extensions)
        if host_aliases is not None:
            pulumi.set(__self__, "host_aliases", host_aliases)
        if image_updater_delegate is not None:
            pulumi.set(__self__, "image_updater_delegate", image_updater_delegate)
        if image_updater_enabled is not None:
            pulumi.set(__self__, "image_updater_enabled", image_updater_enabled)
        if ip_allow_lists is not None:
            pulumi.set(__self__, "ip_allow_lists", ip_allow_lists)
        if repo_server_delegate is not None:
            pulumi.set(__self__, "repo_server_delegate", repo_server_delegate)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if sync_history_extension_enabled is not None:
            pulumi.set(__self__, "sync_history_extension_enabled", sync_history_extension_enabled)

    @property
    @pulumi.getter(name="appSetDelegate")
    def app_set_delegate(self) -> Optional['outputs.InstanceArgocdSpecInstanceSpecAppSetDelegate']:
        """
        Select cluster in which you want to Install Application Set controller
        """
        return pulumi.get(self, "app_set_delegate")

    @property
    @pulumi.getter(name="appsetPolicy")
    def appset_policy(self) -> Optional['outputs.InstanceArgocdSpecInstanceSpecAppsetPolicy']:
        """
        Configures Application Set policy settings.
        """
        return pulumi.get(self, "appset_policy")

    @property
    @pulumi.getter(name="assistantExtensionEnabled")
    def assistant_extension_enabled(self) -> Optional[bool]:
        """
        Enable Powerful AI-powered assistant Extension. It helps analyze Kubernetes resources behavior and provides suggestions about resolving issues.
        """
        return pulumi.get(self, "assistant_extension_enabled")

    @property
    @pulumi.getter(name="auditExtensionEnabled")
    def audit_extension_enabled(self) -> Optional[bool]:
        """
        Enable Audit Extension. Set this to `true` to install Audit Extension to Argo CD instance.
        """
        return pulumi.get(self, "audit_extension_enabled")

    @property
    @pulumi.getter(name="backendIpAllowListEnabled")
    def backend_ip_allow_list_enabled(self) -> Optional[bool]:
        """
        Enable ip allow list for cluster agents
        """
        return pulumi.get(self, "backend_ip_allow_list_enabled")

    @property
    @pulumi.getter(name="clusterCustomizationDefaults")
    def cluster_customization_defaults(self) -> Optional['outputs.InstanceArgocdSpecInstanceSpecClusterCustomizationDefaults']:
        """
        Default values for cluster agents
        """
        return pulumi.get(self, "cluster_customization_defaults")

    @property
    @pulumi.getter(name="declarativeManagementEnabled")
    def declarative_management_enabled(self) -> Optional[bool]:
        """
        Enable Declarative Management
        """
        return pulumi.get(self, "declarative_management_enabled")

    @property
    @pulumi.getter
    def extensions(self) -> Optional[Sequence['outputs.InstanceArgocdSpecInstanceSpecExtension']]:
        """
        Extensions
        """
        return pulumi.get(self, "extensions")

    @property
    @pulumi.getter(name="hostAliases")
    def host_aliases(self) -> Optional[Sequence['outputs.InstanceArgocdSpecInstanceSpecHostAlias']]:
        """
        Host Aliases that override the DNS entries for control plane Argo CD components such as API Server and Dex.
        """
        return pulumi.get(self, "host_aliases")

    @property
    @pulumi.getter(name="imageUpdaterDelegate")
    def image_updater_delegate(self) -> Optional['outputs.InstanceArgocdSpecInstanceSpecImageUpdaterDelegate']:
        """
        Select cluster in which you want to Install Image Updater
        """
        return pulumi.get(self, "image_updater_delegate")

    @property
    @pulumi.getter(name="imageUpdaterEnabled")
    def image_updater_enabled(self) -> Optional[bool]:
        """
        Enable Image Updater
        """
        return pulumi.get(self, "image_updater_enabled")

    @property
    @pulumi.getter(name="ipAllowLists")
    def ip_allow_lists(self) -> Optional[Sequence['outputs.InstanceArgocdSpecInstanceSpecIpAllowList']]:
        """
        IP allow list
        """
        return pulumi.get(self, "ip_allow_lists")

    @property
    @pulumi.getter(name="repoServerDelegate")
    def repo_server_delegate(self) -> Optional['outputs.InstanceArgocdSpecInstanceSpecRepoServerDelegate']:
        """
        In case some clusters don't have network access to your private Git provider you can delegate these operations to one specific cluster.
        """
        return pulumi.get(self, "repo_server_delegate")

    @property
    @pulumi.getter
    def subdomain(self) -> Optional[str]:
        """
        Instance subdomain. By default equals to instance id
        """
        return pulumi.get(self, "subdomain")

    @property
    @pulumi.getter(name="syncHistoryExtensionEnabled")
    def sync_history_extension_enabled(self) -> Optional[bool]:
        """
        Enable Sync History Extension. Sync count and duration graphs as well as event details table on Argo CD application details page.
        """
        return pulumi.get(self, "sync_history_extension_enabled")


@pulumi.output_type
class InstanceArgocdSpecInstanceSpecAppSetDelegate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "managedCluster":
            suggest = "managed_cluster"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceArgocdSpecInstanceSpecAppSetDelegate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceArgocdSpecInstanceSpecAppSetDelegate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceArgocdSpecInstanceSpecAppSetDelegate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 managed_cluster: Optional['outputs.InstanceArgocdSpecInstanceSpecAppSetDelegateManagedCluster'] = None):
        """
        :param 'InstanceArgocdSpecInstanceSpecAppSetDelegateManagedClusterArgs' managed_cluster: Use managed cluster
        """
        if managed_cluster is not None:
            pulumi.set(__self__, "managed_cluster", managed_cluster)

    @property
    @pulumi.getter(name="managedCluster")
    def managed_cluster(self) -> Optional['outputs.InstanceArgocdSpecInstanceSpecAppSetDelegateManagedCluster']:
        """
        Use managed cluster
        """
        return pulumi.get(self, "managed_cluster")


@pulumi.output_type
class InstanceArgocdSpecInstanceSpecAppSetDelegateManagedCluster(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clusterName":
            suggest = "cluster_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceArgocdSpecInstanceSpecAppSetDelegateManagedCluster. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceArgocdSpecInstanceSpecAppSetDelegateManagedCluster.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceArgocdSpecInstanceSpecAppSetDelegateManagedCluster.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cluster_name: str):
        """
        :param str cluster_name: Cluster name
        """
        pulumi.set(__self__, "cluster_name", cluster_name)

    @property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> str:
        """
        Cluster name
        """
        return pulumi.get(self, "cluster_name")


@pulumi.output_type
class InstanceArgocdSpecInstanceSpecAppsetPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "overridePolicy":
            suggest = "override_policy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceArgocdSpecInstanceSpecAppsetPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceArgocdSpecInstanceSpecAppsetPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceArgocdSpecInstanceSpecAppsetPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 override_policy: Optional[bool] = None,
                 policy: Optional[str] = None):
        """
        :param bool override_policy: Allows per `ApplicationSet` sync policy.
        :param str policy: Policy restricts what types of modifications will be made to managed Argo CD `Application` resources.
               Available options: `sync`, `create-only`, `create-delete`, and `create-update`.
                 - Policy `sync`(default): Update and delete are allowed.
                 - Policy `create-only`: Prevents ApplicationSet controller from modifying or deleting Applications.
                 - Policy `create-update`: Prevents ApplicationSet controller from deleting Applications. Update is allowed.
                 - Policy `create-delete`: Prevents ApplicationSet controller from modifying Applications, Delete is allowed.
        """
        if override_policy is not None:
            pulumi.set(__self__, "override_policy", override_policy)
        if policy is not None:
            pulumi.set(__self__, "policy", policy)

    @property
    @pulumi.getter(name="overridePolicy")
    def override_policy(self) -> Optional[bool]:
        """
        Allows per `ApplicationSet` sync policy.
        """
        return pulumi.get(self, "override_policy")

    @property
    @pulumi.getter
    def policy(self) -> Optional[str]:
        """
        Policy restricts what types of modifications will be made to managed Argo CD `Application` resources.
        Available options: `sync`, `create-only`, `create-delete`, and `create-update`.
          - Policy `sync`(default): Update and delete are allowed.
          - Policy `create-only`: Prevents ApplicationSet controller from modifying or deleting Applications.
          - Policy `create-update`: Prevents ApplicationSet controller from deleting Applications. Update is allowed.
          - Policy `create-delete`: Prevents ApplicationSet controller from modifying Applications, Delete is allowed.
        """
        return pulumi.get(self, "policy")


@pulumi.output_type
class InstanceArgocdSpecInstanceSpecClusterCustomizationDefaults(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "appReplication":
            suggest = "app_replication"
        elif key == "autoUpgradeDisabled":
            suggest = "auto_upgrade_disabled"
        elif key == "redisTunneling":
            suggest = "redis_tunneling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceArgocdSpecInstanceSpecClusterCustomizationDefaults. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceArgocdSpecInstanceSpecClusterCustomizationDefaults.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceArgocdSpecInstanceSpecClusterCustomizationDefaults.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 app_replication: Optional[bool] = None,
                 auto_upgrade_disabled: Optional[bool] = None,
                 kustomization: Optional[str] = None,
                 redis_tunneling: Optional[bool] = None):
        """
        :param bool app_replication: Enables Argo CD state replication to the managed cluster that allows disconnecting the cluster from Akuity Platform without losing core Argocd features
        :param str kustomization: Kustomize configuration that will be applied to generated agent installation manifests
        :param bool redis_tunneling: Enables the ability to connect to Redis over a web-socket tunnel that allows using Akuity agent behind HTTPS proxy
        """
        if app_replication is not None:
            pulumi.set(__self__, "app_replication", app_replication)
        if auto_upgrade_disabled is not None:
            pulumi.set(__self__, "auto_upgrade_disabled", auto_upgrade_disabled)
        if kustomization is not None:
            pulumi.set(__self__, "kustomization", kustomization)
        if redis_tunneling is not None:
            pulumi.set(__self__, "redis_tunneling", redis_tunneling)

    @property
    @pulumi.getter(name="appReplication")
    def app_replication(self) -> Optional[bool]:
        """
        Enables Argo CD state replication to the managed cluster that allows disconnecting the cluster from Akuity Platform without losing core Argocd features
        """
        return pulumi.get(self, "app_replication")

    @property
    @pulumi.getter(name="autoUpgradeDisabled")
    def auto_upgrade_disabled(self) -> Optional[bool]:
        return pulumi.get(self, "auto_upgrade_disabled")

    @property
    @pulumi.getter
    def kustomization(self) -> Optional[str]:
        """
        Kustomize configuration that will be applied to generated agent installation manifests
        """
        return pulumi.get(self, "kustomization")

    @property
    @pulumi.getter(name="redisTunneling")
    def redis_tunneling(self) -> Optional[bool]:
        """
        Enables the ability to connect to Redis over a web-socket tunnel that allows using Akuity agent behind HTTPS proxy
        """
        return pulumi.get(self, "redis_tunneling")


@pulumi.output_type
class InstanceArgocdSpecInstanceSpecExtension(dict):
    def __init__(__self__, *,
                 id: str,
                 version: str):
        """
        :param str id: Extension ID
        :param str version: Extension version
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Extension ID
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def version(self) -> str:
        """
        Extension version
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class InstanceArgocdSpecInstanceSpecHostAlias(dict):
    def __init__(__self__, *,
                 ip: str,
                 hostnames: Optional[Sequence[str]] = None):
        """
        :param str ip: IP address
        :param Sequence[str] hostnames: List of hostnames
        """
        pulumi.set(__self__, "ip", ip)
        if hostnames is not None:
            pulumi.set(__self__, "hostnames", hostnames)

    @property
    @pulumi.getter
    def ip(self) -> str:
        """
        IP address
        """
        return pulumi.get(self, "ip")

    @property
    @pulumi.getter
    def hostnames(self) -> Optional[Sequence[str]]:
        """
        List of hostnames
        """
        return pulumi.get(self, "hostnames")


@pulumi.output_type
class InstanceArgocdSpecInstanceSpecImageUpdaterDelegate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "controlPlane":
            suggest = "control_plane"
        elif key == "managedCluster":
            suggest = "managed_cluster"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceArgocdSpecInstanceSpecImageUpdaterDelegate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceArgocdSpecInstanceSpecImageUpdaterDelegate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceArgocdSpecInstanceSpecImageUpdaterDelegate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 control_plane: bool,
                 managed_cluster: Optional['outputs.InstanceArgocdSpecInstanceSpecImageUpdaterDelegateManagedCluster'] = None):
        """
        :param bool control_plane: If use control plane or not
        :param 'InstanceArgocdSpecInstanceSpecImageUpdaterDelegateManagedClusterArgs' managed_cluster: If use managed cluster or not
        """
        pulumi.set(__self__, "control_plane", control_plane)
        if managed_cluster is not None:
            pulumi.set(__self__, "managed_cluster", managed_cluster)

    @property
    @pulumi.getter(name="controlPlane")
    def control_plane(self) -> bool:
        """
        If use control plane or not
        """
        return pulumi.get(self, "control_plane")

    @property
    @pulumi.getter(name="managedCluster")
    def managed_cluster(self) -> Optional['outputs.InstanceArgocdSpecInstanceSpecImageUpdaterDelegateManagedCluster']:
        """
        If use managed cluster or not
        """
        return pulumi.get(self, "managed_cluster")


@pulumi.output_type
class InstanceArgocdSpecInstanceSpecImageUpdaterDelegateManagedCluster(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clusterName":
            suggest = "cluster_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceArgocdSpecInstanceSpecImageUpdaterDelegateManagedCluster. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceArgocdSpecInstanceSpecImageUpdaterDelegateManagedCluster.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceArgocdSpecInstanceSpecImageUpdaterDelegateManagedCluster.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cluster_name: str):
        """
        :param str cluster_name: Cluster name
        """
        pulumi.set(__self__, "cluster_name", cluster_name)

    @property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> str:
        """
        Cluster name
        """
        return pulumi.get(self, "cluster_name")


@pulumi.output_type
class InstanceArgocdSpecInstanceSpecIpAllowList(dict):
    def __init__(__self__, *,
                 ip: str,
                 description: Optional[str] = None):
        """
        :param str ip: IP address
        :param str description: IP description
        """
        pulumi.set(__self__, "ip", ip)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter
    def ip(self) -> str:
        """
        IP address
        """
        return pulumi.get(self, "ip")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        IP description
        """
        return pulumi.get(self, "description")


@pulumi.output_type
class InstanceArgocdSpecInstanceSpecRepoServerDelegate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "controlPlane":
            suggest = "control_plane"
        elif key == "managedCluster":
            suggest = "managed_cluster"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceArgocdSpecInstanceSpecRepoServerDelegate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceArgocdSpecInstanceSpecRepoServerDelegate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceArgocdSpecInstanceSpecRepoServerDelegate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 control_plane: bool,
                 managed_cluster: Optional['outputs.InstanceArgocdSpecInstanceSpecRepoServerDelegateManagedCluster'] = None):
        """
        :param bool control_plane: If use control plane or not
        :param 'InstanceArgocdSpecInstanceSpecRepoServerDelegateManagedClusterArgs' managed_cluster: If use managed cluster or not
        """
        pulumi.set(__self__, "control_plane", control_plane)
        if managed_cluster is not None:
            pulumi.set(__self__, "managed_cluster", managed_cluster)

    @property
    @pulumi.getter(name="controlPlane")
    def control_plane(self) -> bool:
        """
        If use control plane or not
        """
        return pulumi.get(self, "control_plane")

    @property
    @pulumi.getter(name="managedCluster")
    def managed_cluster(self) -> Optional['outputs.InstanceArgocdSpecInstanceSpecRepoServerDelegateManagedCluster']:
        """
        If use managed cluster or not
        """
        return pulumi.get(self, "managed_cluster")


@pulumi.output_type
class InstanceArgocdSpecInstanceSpecRepoServerDelegateManagedCluster(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clusterName":
            suggest = "cluster_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceArgocdSpecInstanceSpecRepoServerDelegateManagedCluster. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceArgocdSpecInstanceSpecRepoServerDelegateManagedCluster.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceArgocdSpecInstanceSpecRepoServerDelegateManagedCluster.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cluster_name: str):
        """
        :param str cluster_name: Cluster name
        """
        pulumi.set(__self__, "cluster_name", cluster_name)

    @property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> str:
        """
        Cluster name
        """
        return pulumi.get(self, "cluster_name")


@pulumi.output_type
class InstanceConfigManagementPlugins(dict):
    def __init__(__self__, *,
                 image: str,
                 spec: 'outputs.InstanceConfigManagementPluginsSpec',
                 enabled: Optional[bool] = None):
        """
        :param str image: Image to use for the plugin
        :param 'InstanceConfigManagementPluginsSpecArgs' spec: Plugin spec
        :param bool enabled: Whether this plugin is enabled or not. Default to false.
        """
        pulumi.set(__self__, "image", image)
        pulumi.set(__self__, "spec", spec)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def image(self) -> str:
        """
        Image to use for the plugin
        """
        return pulumi.get(self, "image")

    @property
    @pulumi.getter
    def spec(self) -> 'outputs.InstanceConfigManagementPluginsSpec':
        """
        Plugin spec
        """
        return pulumi.get(self, "spec")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Whether this plugin is enabled or not. Default to false.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class InstanceConfigManagementPluginsSpec(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "preserveFileMode":
            suggest = "preserve_file_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceConfigManagementPluginsSpec. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceConfigManagementPluginsSpec.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceConfigManagementPluginsSpec.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 generate: 'outputs.InstanceConfigManagementPluginsSpecGenerate',
                 discover: Optional['outputs.InstanceConfigManagementPluginsSpecDiscover'] = None,
                 init: Optional['outputs.InstanceConfigManagementPluginsSpecInit'] = None,
                 parameters: Optional['outputs.InstanceConfigManagementPluginsSpecParameters'] = None,
                 preserve_file_mode: Optional[bool] = None,
                 version: Optional[str] = None):
        """
        :param 'InstanceConfigManagementPluginsSpecGenerateArgs' generate: The generate command runs in the Application source directory each time manifests are generated. Standard output must be ONLY valid Kubernetes Objects in either YAML or JSON. A non-zero exit code will fail manifest generation. Error output will be sent to the UI, so avoid printing sensitive information (such as secrets).
        :param 'InstanceConfigManagementPluginsSpecDiscoverArgs' discover: The discovery config is applied to a repository. If every configured discovery tool matches, then the plugin may be used to generate manifests for Applications using the repository. If the discovery config is omitted then the plugin will not match any application but can still be invoked explicitly by specifying the plugin name in the app spec. Only one of fileName, find.glob, or find.command should be specified. If multiple are specified then only the first (in that order) is evaluated.
        :param 'InstanceConfigManagementPluginsSpecInitArgs' init: The init command runs in the Application source directory at the beginning of each manifest generation. The init command can output anything. A non-zero status code will fail manifest generation. Init always happens immediately before generate, but its output is not treated as manifests. This is a good place to, for example, download chart dependencies.
        :param 'InstanceConfigManagementPluginsSpecParametersArgs' parameters: The parameters config describes what parameters the UI should display for an Application. It is up to the user to actually set parameters in the Application manifest (in spec.source.plugin.parameters). The announcements only inform the "Parameters" tab in the App Details page of the UI.
        :param bool preserve_file_mode: Whether the plugin receives repository files with original file mode. Dangerous since the repository might have executable files. Set to true only if you trust the CMP plugin authors. Set to false by default.
        :param str version: Plugin version
        """
        pulumi.set(__self__, "generate", generate)
        if discover is not None:
            pulumi.set(__self__, "discover", discover)
        if init is not None:
            pulumi.set(__self__, "init", init)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if preserve_file_mode is not None:
            pulumi.set(__self__, "preserve_file_mode", preserve_file_mode)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def generate(self) -> 'outputs.InstanceConfigManagementPluginsSpecGenerate':
        """
        The generate command runs in the Application source directory each time manifests are generated. Standard output must be ONLY valid Kubernetes Objects in either YAML or JSON. A non-zero exit code will fail manifest generation. Error output will be sent to the UI, so avoid printing sensitive information (such as secrets).
        """
        return pulumi.get(self, "generate")

    @property
    @pulumi.getter
    def discover(self) -> Optional['outputs.InstanceConfigManagementPluginsSpecDiscover']:
        """
        The discovery config is applied to a repository. If every configured discovery tool matches, then the plugin may be used to generate manifests for Applications using the repository. If the discovery config is omitted then the plugin will not match any application but can still be invoked explicitly by specifying the plugin name in the app spec. Only one of fileName, find.glob, or find.command should be specified. If multiple are specified then only the first (in that order) is evaluated.
        """
        return pulumi.get(self, "discover")

    @property
    @pulumi.getter
    def init(self) -> Optional['outputs.InstanceConfigManagementPluginsSpecInit']:
        """
        The init command runs in the Application source directory at the beginning of each manifest generation. The init command can output anything. A non-zero status code will fail manifest generation. Init always happens immediately before generate, but its output is not treated as manifests. This is a good place to, for example, download chart dependencies.
        """
        return pulumi.get(self, "init")

    @property
    @pulumi.getter
    def parameters(self) -> Optional['outputs.InstanceConfigManagementPluginsSpecParameters']:
        """
        The parameters config describes what parameters the UI should display for an Application. It is up to the user to actually set parameters in the Application manifest (in spec.source.plugin.parameters). The announcements only inform the "Parameters" tab in the App Details page of the UI.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter(name="preserveFileMode")
    def preserve_file_mode(self) -> Optional[bool]:
        """
        Whether the plugin receives repository files with original file mode. Dangerous since the repository might have executable files. Set to true only if you trust the CMP plugin authors. Set to false by default.
        """
        return pulumi.get(self, "preserve_file_mode")

    @property
    @pulumi.getter
    def version(self) -> Optional[str]:
        """
        Plugin version
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class InstanceConfigManagementPluginsSpecDiscover(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fileName":
            suggest = "file_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceConfigManagementPluginsSpecDiscover. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceConfigManagementPluginsSpecDiscover.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceConfigManagementPluginsSpecDiscover.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 file_name: Optional[str] = None,
                 find: Optional['outputs.InstanceConfigManagementPluginsSpecDiscoverFind'] = None):
        """
        :param str file_name: A glob pattern (https://pkg.go.dev/path/filepath#Glob) that is applied to the Application's source directory. If there is a match, this plugin may be used for the Application.
        :param 'InstanceConfigManagementPluginsSpecDiscoverFindArgs' find: Find config
        """
        if file_name is not None:
            pulumi.set(__self__, "file_name", file_name)
        if find is not None:
            pulumi.set(__self__, "find", find)

    @property
    @pulumi.getter(name="fileName")
    def file_name(self) -> Optional[str]:
        """
        A glob pattern (https://pkg.go.dev/path/filepath#Glob) that is applied to the Application's source directory. If there is a match, this plugin may be used for the Application.
        """
        return pulumi.get(self, "file_name")

    @property
    @pulumi.getter
    def find(self) -> Optional['outputs.InstanceConfigManagementPluginsSpecDiscoverFind']:
        """
        Find config
        """
        return pulumi.get(self, "find")


@pulumi.output_type
class InstanceConfigManagementPluginsSpecDiscoverFind(dict):
    def __init__(__self__, *,
                 args: Optional[Sequence[str]] = None,
                 commands: Optional[Sequence[str]] = None,
                 glob: Optional[str] = None):
        """
        :param Sequence[str] args: Arguments for the find command
        :param Sequence[str] commands: The find command runs in the repository's root directory. To match, it must exit with status code 0 and produce non-empty output to standard out.
        :param str glob: This does the same thing as `file_name`, but it supports double-start (nested directory) glob patterns.
        """
        if args is not None:
            pulumi.set(__self__, "args", args)
        if commands is not None:
            pulumi.set(__self__, "commands", commands)
        if glob is not None:
            pulumi.set(__self__, "glob", glob)

    @property
    @pulumi.getter
    def args(self) -> Optional[Sequence[str]]:
        """
        Arguments for the find command
        """
        return pulumi.get(self, "args")

    @property
    @pulumi.getter
    def commands(self) -> Optional[Sequence[str]]:
        """
        The find command runs in the repository's root directory. To match, it must exit with status code 0 and produce non-empty output to standard out.
        """
        return pulumi.get(self, "commands")

    @property
    @pulumi.getter
    def glob(self) -> Optional[str]:
        """
        This does the same thing as `file_name`, but it supports double-start (nested directory) glob patterns.
        """
        return pulumi.get(self, "glob")


@pulumi.output_type
class InstanceConfigManagementPluginsSpecGenerate(dict):
    def __init__(__self__, *,
                 commands: Sequence[str],
                 args: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] commands: Command
        :param Sequence[str] args: Arguments of the command
        """
        pulumi.set(__self__, "commands", commands)
        if args is not None:
            pulumi.set(__self__, "args", args)

    @property
    @pulumi.getter
    def commands(self) -> Sequence[str]:
        """
        Command
        """
        return pulumi.get(self, "commands")

    @property
    @pulumi.getter
    def args(self) -> Optional[Sequence[str]]:
        """
        Arguments of the command
        """
        return pulumi.get(self, "args")


@pulumi.output_type
class InstanceConfigManagementPluginsSpecInit(dict):
    def __init__(__self__, *,
                 commands: Sequence[str],
                 args: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] commands: Command
        :param Sequence[str] args: Arguments of the command
        """
        pulumi.set(__self__, "commands", commands)
        if args is not None:
            pulumi.set(__self__, "args", args)

    @property
    @pulumi.getter
    def commands(self) -> Sequence[str]:
        """
        Command
        """
        return pulumi.get(self, "commands")

    @property
    @pulumi.getter
    def args(self) -> Optional[Sequence[str]]:
        """
        Arguments of the command
        """
        return pulumi.get(self, "args")


@pulumi.output_type
class InstanceConfigManagementPluginsSpecParameters(dict):
    def __init__(__self__, *,
                 dynamic: Optional['outputs.InstanceConfigManagementPluginsSpecParametersDynamic'] = None,
                 statics: Optional[Sequence['outputs.InstanceConfigManagementPluginsSpecParametersStatic']] = None):
        """
        :param 'InstanceConfigManagementPluginsSpecParametersDynamicArgs' dynamic: Dynamic parameter announcements are announcements specific to an Application handled by this plugin. For example, the values for a Helm chart's values.yaml file could be sent as parameter announcements.
        :param Sequence['InstanceConfigManagementPluginsSpecParametersStaticArgs'] statics: Static parameter announcements are sent to the UI for all Applications handled by this plugin. Think of the `string`, `array`, and `map` values set here as defaults. It is up to the plugin author to make sure that these default values actually reflect the plugin's behavior if the user doesn't explicitly set different values for those parameters.
        """
        if dynamic is not None:
            pulumi.set(__self__, "dynamic", dynamic)
        if statics is not None:
            pulumi.set(__self__, "statics", statics)

    @property
    @pulumi.getter
    def dynamic(self) -> Optional['outputs.InstanceConfigManagementPluginsSpecParametersDynamic']:
        """
        Dynamic parameter announcements are announcements specific to an Application handled by this plugin. For example, the values for a Helm chart's values.yaml file could be sent as parameter announcements.
        """
        return pulumi.get(self, "dynamic")

    @property
    @pulumi.getter
    def statics(self) -> Optional[Sequence['outputs.InstanceConfigManagementPluginsSpecParametersStatic']]:
        """
        Static parameter announcements are sent to the UI for all Applications handled by this plugin. Think of the `string`, `array`, and `map` values set here as defaults. It is up to the plugin author to make sure that these default values actually reflect the plugin's behavior if the user doesn't explicitly set different values for those parameters.
        """
        return pulumi.get(self, "statics")


@pulumi.output_type
class InstanceConfigManagementPluginsSpecParametersDynamic(dict):
    def __init__(__self__, *,
                 args: Optional[Sequence[str]] = None,
                 commands: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] args: Arguments of the command
        :param Sequence[str] commands: The command will run in an Application's source directory. Standard output must be JSON matching the schema of the static parameter announcements list.
        """
        if args is not None:
            pulumi.set(__self__, "args", args)
        if commands is not None:
            pulumi.set(__self__, "commands", commands)

    @property
    @pulumi.getter
    def args(self) -> Optional[Sequence[str]]:
        """
        Arguments of the command
        """
        return pulumi.get(self, "args")

    @property
    @pulumi.getter
    def commands(self) -> Optional[Sequence[str]]:
        """
        The command will run in an Application's source directory. Standard output must be JSON matching the schema of the static parameter announcements list.
        """
        return pulumi.get(self, "commands")


@pulumi.output_type
class InstanceConfigManagementPluginsSpecParametersStatic(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "collectionType":
            suggest = "collection_type"
        elif key == "itemType":
            suggest = "item_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceConfigManagementPluginsSpecParametersStatic. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceConfigManagementPluginsSpecParametersStatic.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceConfigManagementPluginsSpecParametersStatic.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 arrays: Optional[Sequence[str]] = None,
                 collection_type: Optional[str] = None,
                 item_type: Optional[str] = None,
                 map: Optional[Mapping[str, str]] = None,
                 name: Optional[str] = None,
                 required: Optional[bool] = None,
                 string: Optional[str] = None,
                 title: Optional[str] = None,
                 tooltip: Optional[str] = None):
        """
        :param Sequence[str] arrays: This field communicates the parameter's default value to the UI if the parameter is an `array`.
        :param str collection_type: Collection Type describes what type of value this parameter accepts (string, array, or map) and allows the UI to present a form to match that type. Default is `string`. This field must be present for non-string types. It will not be inferred from the presence of an `array` or `map` field.
        :param str item_type: Item type tells the UI how to present the parameter's value (or, for arrays and maps, values). Default is `string`. Examples of other types which may be supported in the future are `boolean` or `number`. Even if the itemType is not `string`, the parameter value from the Application spec will be sent to the plugin as a string. It's up to the plugin to do the appropriate conversion.
        :param Mapping[str, str] map: This field communicates the parameter's default value to the UI if the parameter is a `map`.
        :param str name: Parameter name
        :param bool required: Whether the Parameter is required or not. If this field is set to true, the UI will indicate to the user that they must set the value. Default to false.
        :param str string: This field communicates the parameter's default value to the UI if the parameter is a `string`.
        :param str title: Title and description of the parameter
        :param str tooltip: Tooltip of the Parameter, will be shown when hovering over the title
        """
        if arrays is not None:
            pulumi.set(__self__, "arrays", arrays)
        if collection_type is not None:
            pulumi.set(__self__, "collection_type", collection_type)
        if item_type is not None:
            pulumi.set(__self__, "item_type", item_type)
        if map is not None:
            pulumi.set(__self__, "map", map)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if required is not None:
            pulumi.set(__self__, "required", required)
        if string is not None:
            pulumi.set(__self__, "string", string)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if tooltip is not None:
            pulumi.set(__self__, "tooltip", tooltip)

    @property
    @pulumi.getter
    def arrays(self) -> Optional[Sequence[str]]:
        """
        This field communicates the parameter's default value to the UI if the parameter is an `array`.
        """
        return pulumi.get(self, "arrays")

    @property
    @pulumi.getter(name="collectionType")
    def collection_type(self) -> Optional[str]:
        """
        Collection Type describes what type of value this parameter accepts (string, array, or map) and allows the UI to present a form to match that type. Default is `string`. This field must be present for non-string types. It will not be inferred from the presence of an `array` or `map` field.
        """
        return pulumi.get(self, "collection_type")

    @property
    @pulumi.getter(name="itemType")
    def item_type(self) -> Optional[str]:
        """
        Item type tells the UI how to present the parameter's value (or, for arrays and maps, values). Default is `string`. Examples of other types which may be supported in the future are `boolean` or `number`. Even if the itemType is not `string`, the parameter value from the Application spec will be sent to the plugin as a string. It's up to the plugin to do the appropriate conversion.
        """
        return pulumi.get(self, "item_type")

    @property
    @pulumi.getter
    def map(self) -> Optional[Mapping[str, str]]:
        """
        This field communicates the parameter's default value to the UI if the parameter is a `map`.
        """
        return pulumi.get(self, "map")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Parameter name
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def required(self) -> Optional[bool]:
        """
        Whether the Parameter is required or not. If this field is set to true, the UI will indicate to the user that they must set the value. Default to false.
        """
        return pulumi.get(self, "required")

    @property
    @pulumi.getter
    def string(self) -> Optional[str]:
        """
        This field communicates the parameter's default value to the UI if the parameter is a `string`.
        """
        return pulumi.get(self, "string")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        Title and description of the parameter
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter
    def tooltip(self) -> Optional[str]:
        """
        Tooltip of the Parameter, will be shown when hovering over the title
        """
        return pulumi.get(self, "tooltip")


@pulumi.output_type
class GetClusterKubeConfigResult(dict):
    def __init__(__self__, *,
                 client_certificate: str,
                 client_key: str,
                 cluster_ca_certificate: str,
                 config_context: str,
                 config_context_auth_info: str,
                 config_context_cluster: str,
                 config_path: str,
                 config_paths: Sequence[str],
                 host: str,
                 insecure: bool,
                 password: str,
                 proxy_url: str,
                 token: str,
                 username: str):
        """
        :param str client_certificate: PEM-encoded client certificate for TLS authentication.
        :param str client_key: PEM-encoded client certificate key for TLS authentication.
        :param str cluster_ca_certificate: PEM-encoded root certificates bundle for TLS authentication.
        :param str config_context: Context name to load from the kube config file.
        :param str config_path: Path to the kube config file.
        :param Sequence[str] config_paths: A list of paths to kube config files.
        :param str host: The hostname (in form of URI) of Kubernetes master.
        :param bool insecure: Whether server should be accessed without verifying the TLS certificate.
        :param str password: The password to use for HTTP basic authentication when accessing the Kubernetes master endpoint.
        :param str proxy_url: URL to the proxy to be used for all API requests
        :param str token: Token to authenticate an service account
        :param str username: The username to use for HTTP basic authentication when accessing the Kubernetes master endpoint.
        """
        pulumi.set(__self__, "client_certificate", client_certificate)
        pulumi.set(__self__, "client_key", client_key)
        pulumi.set(__self__, "cluster_ca_certificate", cluster_ca_certificate)
        pulumi.set(__self__, "config_context", config_context)
        pulumi.set(__self__, "config_context_auth_info", config_context_auth_info)
        pulumi.set(__self__, "config_context_cluster", config_context_cluster)
        pulumi.set(__self__, "config_path", config_path)
        pulumi.set(__self__, "config_paths", config_paths)
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "insecure", insecure)
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "proxy_url", proxy_url)
        pulumi.set(__self__, "token", token)
        pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="clientCertificate")
    def client_certificate(self) -> str:
        """
        PEM-encoded client certificate for TLS authentication.
        """
        return pulumi.get(self, "client_certificate")

    @property
    @pulumi.getter(name="clientKey")
    def client_key(self) -> str:
        """
        PEM-encoded client certificate key for TLS authentication.
        """
        return pulumi.get(self, "client_key")

    @property
    @pulumi.getter(name="clusterCaCertificate")
    def cluster_ca_certificate(self) -> str:
        """
        PEM-encoded root certificates bundle for TLS authentication.
        """
        return pulumi.get(self, "cluster_ca_certificate")

    @property
    @pulumi.getter(name="configContext")
    def config_context(self) -> str:
        """
        Context name to load from the kube config file.
        """
        return pulumi.get(self, "config_context")

    @property
    @pulumi.getter(name="configContextAuthInfo")
    def config_context_auth_info(self) -> str:
        return pulumi.get(self, "config_context_auth_info")

    @property
    @pulumi.getter(name="configContextCluster")
    def config_context_cluster(self) -> str:
        return pulumi.get(self, "config_context_cluster")

    @property
    @pulumi.getter(name="configPath")
    def config_path(self) -> str:
        """
        Path to the kube config file.
        """
        return pulumi.get(self, "config_path")

    @property
    @pulumi.getter(name="configPaths")
    def config_paths(self) -> Sequence[str]:
        """
        A list of paths to kube config files.
        """
        return pulumi.get(self, "config_paths")

    @property
    @pulumi.getter
    def host(self) -> str:
        """
        The hostname (in form of URI) of Kubernetes master.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def insecure(self) -> bool:
        """
        Whether server should be accessed without verifying the TLS certificate.
        """
        return pulumi.get(self, "insecure")

    @property
    @pulumi.getter
    def password(self) -> str:
        """
        The password to use for HTTP basic authentication when accessing the Kubernetes master endpoint.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter(name="proxyUrl")
    def proxy_url(self) -> str:
        """
        URL to the proxy to be used for all API requests
        """
        return pulumi.get(self, "proxy_url")

    @property
    @pulumi.getter
    def token(self) -> str:
        """
        Token to authenticate an service account
        """
        return pulumi.get(self, "token")

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        The username to use for HTTP basic authentication when accessing the Kubernetes master endpoint.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GetClusterSpecResult(dict):
    def __init__(__self__, *,
                 data: 'outputs.GetClusterSpecDataResult',
                 description: str,
                 namespace_scoped: bool):
        """
        :param 'GetClusterSpecDataArgs' data: Cluster data
        :param str description: Cluster description
        :param bool namespace_scoped: If the agent is namespace scoped
        """
        pulumi.set(__self__, "data", data)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "namespace_scoped", namespace_scoped)

    @property
    @pulumi.getter
    def data(self) -> 'outputs.GetClusterSpecDataResult':
        """
        Cluster data
        """
        return pulumi.get(self, "data")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        Cluster description
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="namespaceScoped")
    def namespace_scoped(self) -> bool:
        """
        If the agent is namespace scoped
        """
        return pulumi.get(self, "namespace_scoped")


@pulumi.output_type
class GetClusterSpecDataResult(dict):
    def __init__(__self__, *,
                 app_replication: bool,
                 auto_upgrade_disabled: bool,
                 kustomization: str,
                 redis_tunneling: bool,
                 size: str,
                 target_version: str):
        """
        :param bool app_replication: Enables Argo CD state replication to the managed cluster that allows disconnecting the cluster from Akuity Platform without losing core Argocd features
        :param str kustomization: Kustomize configuration that will be applied to generated agent installation manifests
        :param bool redis_tunneling: Enables the ability to connect to Redis over a web-socket tunnel that allows using Akuity agent behind HTTPS proxy
        :param str size: Cluster Size. One of `small`, `medium` or `large`
        :param str target_version: The version of the agent to install on your cluster
        """
        pulumi.set(__self__, "app_replication", app_replication)
        pulumi.set(__self__, "auto_upgrade_disabled", auto_upgrade_disabled)
        pulumi.set(__self__, "kustomization", kustomization)
        pulumi.set(__self__, "redis_tunneling", redis_tunneling)
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "target_version", target_version)

    @property
    @pulumi.getter(name="appReplication")
    def app_replication(self) -> bool:
        """
        Enables Argo CD state replication to the managed cluster that allows disconnecting the cluster from Akuity Platform without losing core Argocd features
        """
        return pulumi.get(self, "app_replication")

    @property
    @pulumi.getter(name="autoUpgradeDisabled")
    def auto_upgrade_disabled(self) -> bool:
        return pulumi.get(self, "auto_upgrade_disabled")

    @property
    @pulumi.getter
    def kustomization(self) -> str:
        """
        Kustomize configuration that will be applied to generated agent installation manifests
        """
        return pulumi.get(self, "kustomization")

    @property
    @pulumi.getter(name="redisTunneling")
    def redis_tunneling(self) -> bool:
        """
        Enables the ability to connect to Redis over a web-socket tunnel that allows using Akuity agent behind HTTPS proxy
        """
        return pulumi.get(self, "redis_tunneling")

    @property
    @pulumi.getter
    def size(self) -> str:
        """
        Cluster Size. One of `small`, `medium` or `large`
        """
        return pulumi.get(self, "size")

    @property
    @pulumi.getter(name="targetVersion")
    def target_version(self) -> str:
        """
        The version of the agent to install on your cluster
        """
        return pulumi.get(self, "target_version")


@pulumi.output_type
class GetClustersClusterResult(dict):
    def __init__(__self__, *,
                 annotations: Mapping[str, str],
                 id: str,
                 instance_id: str,
                 kube_config: 'outputs.GetClustersClusterKubeConfigResult',
                 labels: Mapping[str, str],
                 name: str,
                 namespace: str,
                 remove_agent_resources_on_destroy: bool,
                 spec: 'outputs.GetClustersClusterSpecResult'):
        """
        :param Mapping[str, str] annotations: Annotations
        :param str id: Cluster ID
        :param str instance_id: Argo CD instance ID
        :param Mapping[str, str] labels: Labels
        :param str name: Cluster name
        :param str namespace: Agent installation namespace
        :param bool remove_agent_resources_on_destroy: Remove agent Kubernetes resources from the managed cluster when destroying cluster
        :param 'GetClustersClusterSpecArgs' spec: Cluster spec
        """
        pulumi.set(__self__, "annotations", annotations)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "instance_id", instance_id)
        pulumi.set(__self__, "kube_config", kube_config)
        pulumi.set(__self__, "labels", labels)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "namespace", namespace)
        pulumi.set(__self__, "remove_agent_resources_on_destroy", remove_agent_resources_on_destroy)
        pulumi.set(__self__, "spec", spec)

    @property
    @pulumi.getter
    def annotations(self) -> Mapping[str, str]:
        """
        Annotations
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Cluster ID
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> str:
        """
        Argo CD instance ID
        """
        return pulumi.get(self, "instance_id")

    @property
    @pulumi.getter(name="kubeConfig")
    def kube_config(self) -> 'outputs.GetClustersClusterKubeConfigResult':
        return pulumi.get(self, "kube_config")

    @property
    @pulumi.getter
    def labels(self) -> Mapping[str, str]:
        """
        Labels
        """
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Cluster name
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def namespace(self) -> str:
        """
        Agent installation namespace
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter(name="removeAgentResourcesOnDestroy")
    def remove_agent_resources_on_destroy(self) -> bool:
        """
        Remove agent Kubernetes resources from the managed cluster when destroying cluster
        """
        return pulumi.get(self, "remove_agent_resources_on_destroy")

    @property
    @pulumi.getter
    def spec(self) -> 'outputs.GetClustersClusterSpecResult':
        """
        Cluster spec
        """
        return pulumi.get(self, "spec")


@pulumi.output_type
class GetClustersClusterKubeConfigResult(dict):
    def __init__(__self__, *,
                 client_certificate: str,
                 client_key: str,
                 cluster_ca_certificate: str,
                 config_context: str,
                 config_context_auth_info: str,
                 config_context_cluster: str,
                 config_path: str,
                 config_paths: Sequence[str],
                 host: str,
                 insecure: bool,
                 password: str,
                 proxy_url: str,
                 token: str,
                 username: str):
        """
        :param str client_certificate: PEM-encoded client certificate for TLS authentication.
        :param str client_key: PEM-encoded client certificate key for TLS authentication.
        :param str cluster_ca_certificate: PEM-encoded root certificates bundle for TLS authentication.
        :param str config_context: Context name to load from the kube config file.
        :param str config_path: Path to the kube config file.
        :param Sequence[str] config_paths: A list of paths to kube config files.
        :param str host: The hostname (in form of URI) of Kubernetes master.
        :param bool insecure: Whether server should be accessed without verifying the TLS certificate.
        :param str password: The password to use for HTTP basic authentication when accessing the Kubernetes master endpoint.
        :param str proxy_url: URL to the proxy to be used for all API requests
        :param str token: Token to authenticate an service account
        :param str username: The username to use for HTTP basic authentication when accessing the Kubernetes master endpoint.
        """
        pulumi.set(__self__, "client_certificate", client_certificate)
        pulumi.set(__self__, "client_key", client_key)
        pulumi.set(__self__, "cluster_ca_certificate", cluster_ca_certificate)
        pulumi.set(__self__, "config_context", config_context)
        pulumi.set(__self__, "config_context_auth_info", config_context_auth_info)
        pulumi.set(__self__, "config_context_cluster", config_context_cluster)
        pulumi.set(__self__, "config_path", config_path)
        pulumi.set(__self__, "config_paths", config_paths)
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "insecure", insecure)
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "proxy_url", proxy_url)
        pulumi.set(__self__, "token", token)
        pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="clientCertificate")
    def client_certificate(self) -> str:
        """
        PEM-encoded client certificate for TLS authentication.
        """
        return pulumi.get(self, "client_certificate")

    @property
    @pulumi.getter(name="clientKey")
    def client_key(self) -> str:
        """
        PEM-encoded client certificate key for TLS authentication.
        """
        return pulumi.get(self, "client_key")

    @property
    @pulumi.getter(name="clusterCaCertificate")
    def cluster_ca_certificate(self) -> str:
        """
        PEM-encoded root certificates bundle for TLS authentication.
        """
        return pulumi.get(self, "cluster_ca_certificate")

    @property
    @pulumi.getter(name="configContext")
    def config_context(self) -> str:
        """
        Context name to load from the kube config file.
        """
        return pulumi.get(self, "config_context")

    @property
    @pulumi.getter(name="configContextAuthInfo")
    def config_context_auth_info(self) -> str:
        return pulumi.get(self, "config_context_auth_info")

    @property
    @pulumi.getter(name="configContextCluster")
    def config_context_cluster(self) -> str:
        return pulumi.get(self, "config_context_cluster")

    @property
    @pulumi.getter(name="configPath")
    def config_path(self) -> str:
        """
        Path to the kube config file.
        """
        return pulumi.get(self, "config_path")

    @property
    @pulumi.getter(name="configPaths")
    def config_paths(self) -> Sequence[str]:
        """
        A list of paths to kube config files.
        """
        return pulumi.get(self, "config_paths")

    @property
    @pulumi.getter
    def host(self) -> str:
        """
        The hostname (in form of URI) of Kubernetes master.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def insecure(self) -> bool:
        """
        Whether server should be accessed without verifying the TLS certificate.
        """
        return pulumi.get(self, "insecure")

    @property
    @pulumi.getter
    def password(self) -> str:
        """
        The password to use for HTTP basic authentication when accessing the Kubernetes master endpoint.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter(name="proxyUrl")
    def proxy_url(self) -> str:
        """
        URL to the proxy to be used for all API requests
        """
        return pulumi.get(self, "proxy_url")

    @property
    @pulumi.getter
    def token(self) -> str:
        """
        Token to authenticate an service account
        """
        return pulumi.get(self, "token")

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        The username to use for HTTP basic authentication when accessing the Kubernetes master endpoint.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GetClustersClusterSpecResult(dict):
    def __init__(__self__, *,
                 data: 'outputs.GetClustersClusterSpecDataResult',
                 description: str,
                 namespace_scoped: bool):
        """
        :param 'GetClustersClusterSpecDataArgs' data: Cluster data
        :param str description: Cluster description
        :param bool namespace_scoped: If the agent is namespace scoped
        """
        pulumi.set(__self__, "data", data)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "namespace_scoped", namespace_scoped)

    @property
    @pulumi.getter
    def data(self) -> 'outputs.GetClustersClusterSpecDataResult':
        """
        Cluster data
        """
        return pulumi.get(self, "data")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        Cluster description
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="namespaceScoped")
    def namespace_scoped(self) -> bool:
        """
        If the agent is namespace scoped
        """
        return pulumi.get(self, "namespace_scoped")


@pulumi.output_type
class GetClustersClusterSpecDataResult(dict):
    def __init__(__self__, *,
                 app_replication: bool,
                 auto_upgrade_disabled: bool,
                 kustomization: str,
                 redis_tunneling: bool,
                 size: str,
                 target_version: str):
        """
        :param bool app_replication: Enables Argo CD state replication to the managed cluster that allows disconnecting the cluster from Akuity Platform without losing core Argocd features
        :param str kustomization: Kustomize configuration that will be applied to generated agent installation manifests
        :param bool redis_tunneling: Enables the ability to connect to Redis over a web-socket tunnel that allows using Akuity agent behind HTTPS proxy
        :param str size: Cluster Size. One of `small`, `medium` or `large`
        :param str target_version: The version of the agent to install on your cluster
        """
        pulumi.set(__self__, "app_replication", app_replication)
        pulumi.set(__self__, "auto_upgrade_disabled", auto_upgrade_disabled)
        pulumi.set(__self__, "kustomization", kustomization)
        pulumi.set(__self__, "redis_tunneling", redis_tunneling)
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "target_version", target_version)

    @property
    @pulumi.getter(name="appReplication")
    def app_replication(self) -> bool:
        """
        Enables Argo CD state replication to the managed cluster that allows disconnecting the cluster from Akuity Platform without losing core Argocd features
        """
        return pulumi.get(self, "app_replication")

    @property
    @pulumi.getter(name="autoUpgradeDisabled")
    def auto_upgrade_disabled(self) -> bool:
        return pulumi.get(self, "auto_upgrade_disabled")

    @property
    @pulumi.getter
    def kustomization(self) -> str:
        """
        Kustomize configuration that will be applied to generated agent installation manifests
        """
        return pulumi.get(self, "kustomization")

    @property
    @pulumi.getter(name="redisTunneling")
    def redis_tunneling(self) -> bool:
        """
        Enables the ability to connect to Redis over a web-socket tunnel that allows using Akuity agent behind HTTPS proxy
        """
        return pulumi.get(self, "redis_tunneling")

    @property
    @pulumi.getter
    def size(self) -> str:
        """
        Cluster Size. One of `small`, `medium` or `large`
        """
        return pulumi.get(self, "size")

    @property
    @pulumi.getter(name="targetVersion")
    def target_version(self) -> str:
        """
        The version of the agent to install on your cluster
        """
        return pulumi.get(self, "target_version")


@pulumi.output_type
class GetInstanceArgocdResult(dict):
    def __init__(__self__, *,
                 spec: 'outputs.GetInstanceArgocdSpecResult'):
        """
        :param 'GetInstanceArgocdSpecArgs' spec: Argo CD instance spec
        """
        pulumi.set(__self__, "spec", spec)

    @property
    @pulumi.getter
    def spec(self) -> 'outputs.GetInstanceArgocdSpecResult':
        """
        Argo CD instance spec
        """
        return pulumi.get(self, "spec")


@pulumi.output_type
class GetInstanceArgocdSpecResult(dict):
    def __init__(__self__, *,
                 description: str,
                 instance_spec: 'outputs.GetInstanceArgocdSpecInstanceSpecResult',
                 version: str):
        """
        :param str description: Instance description
        :param 'GetInstanceArgocdSpecInstanceSpecArgs' instance_spec: Argo CD instance spec
        :param str version: Argo CD version. Should be equal to any Akuity [`argocd` image tag](https://quay.io/repository/akuity/argocd?tab=tags).
        """
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "instance_spec", instance_spec)
        pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        Instance description
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="instanceSpec")
    def instance_spec(self) -> 'outputs.GetInstanceArgocdSpecInstanceSpecResult':
        """
        Argo CD instance spec
        """
        return pulumi.get(self, "instance_spec")

    @property
    @pulumi.getter
    def version(self) -> str:
        """
        Argo CD version. Should be equal to any Akuity [`argocd` image tag](https://quay.io/repository/akuity/argocd?tab=tags).
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class GetInstanceArgocdSpecInstanceSpecResult(dict):
    def __init__(__self__, *,
                 app_set_delegate: 'outputs.GetInstanceArgocdSpecInstanceSpecAppSetDelegateResult',
                 appset_policy: 'outputs.GetInstanceArgocdSpecInstanceSpecAppsetPolicyResult',
                 assistant_extension_enabled: bool,
                 audit_extension_enabled: bool,
                 backend_ip_allow_list_enabled: bool,
                 cluster_customization_defaults: 'outputs.GetInstanceArgocdSpecInstanceSpecClusterCustomizationDefaultsResult',
                 declarative_management_enabled: bool,
                 extensions: Sequence['outputs.GetInstanceArgocdSpecInstanceSpecExtensionResult'],
                 host_aliases: Sequence['outputs.GetInstanceArgocdSpecInstanceSpecHostAliasResult'],
                 image_updater_delegate: 'outputs.GetInstanceArgocdSpecInstanceSpecImageUpdaterDelegateResult',
                 image_updater_enabled: bool,
                 ip_allow_lists: Sequence['outputs.GetInstanceArgocdSpecInstanceSpecIpAllowListResult'],
                 repo_server_delegate: 'outputs.GetInstanceArgocdSpecInstanceSpecRepoServerDelegateResult',
                 subdomain: str,
                 sync_history_extension_enabled: bool):
        """
        :param 'GetInstanceArgocdSpecInstanceSpecAppSetDelegateArgs' app_set_delegate: Select cluster in which you want to Install Application Set controller
        :param 'GetInstanceArgocdSpecInstanceSpecAppsetPolicyArgs' appset_policy: Configures Application Set policy settings.
        :param bool assistant_extension_enabled: Enable Powerful AI-powered assistant Extension. It helps analyze Kubernetes resources behavior and provides suggestions about resolving issues.
        :param bool audit_extension_enabled: Enable Audit Extension. Set this to `true` to install Audit Extension to Argo CD instance.
        :param bool backend_ip_allow_list_enabled: Enable ip allow list for cluster agents
        :param 'GetInstanceArgocdSpecInstanceSpecClusterCustomizationDefaultsArgs' cluster_customization_defaults: Default values for cluster agents
        :param bool declarative_management_enabled: Enable Declarative Management
        :param Sequence['GetInstanceArgocdSpecInstanceSpecExtensionArgs'] extensions: Extensions
        :param Sequence['GetInstanceArgocdSpecInstanceSpecHostAliasArgs'] host_aliases: Host Aliases that override the DNS entries for control plane Argo CD components such as API Server and Dex.
        :param 'GetInstanceArgocdSpecInstanceSpecImageUpdaterDelegateArgs' image_updater_delegate: Select cluster in which you want to Install Image Updater
        :param bool image_updater_enabled: Enable Image Updater
        :param Sequence['GetInstanceArgocdSpecInstanceSpecIpAllowListArgs'] ip_allow_lists: IP allow list
        :param 'GetInstanceArgocdSpecInstanceSpecRepoServerDelegateArgs' repo_server_delegate: In case some clusters don't have network access to your private Git provider you can delegate these operations to one specific cluster.
        :param str subdomain: Instance subdomain. By default equals to instance id
        :param bool sync_history_extension_enabled: Enable Sync History Extension. Sync count and duration graphs as well as event details table on Argo CD application details page.
        """
        pulumi.set(__self__, "app_set_delegate", app_set_delegate)
        pulumi.set(__self__, "appset_policy", appset_policy)
        pulumi.set(__self__, "assistant_extension_enabled", assistant_extension_enabled)
        pulumi.set(__self__, "audit_extension_enabled", audit_extension_enabled)
        pulumi.set(__self__, "backend_ip_allow_list_enabled", backend_ip_allow_list_enabled)
        pulumi.set(__self__, "cluster_customization_defaults", cluster_customization_defaults)
        pulumi.set(__self__, "declarative_management_enabled", declarative_management_enabled)
        pulumi.set(__self__, "extensions", extensions)
        pulumi.set(__self__, "host_aliases", host_aliases)
        pulumi.set(__self__, "image_updater_delegate", image_updater_delegate)
        pulumi.set(__self__, "image_updater_enabled", image_updater_enabled)
        pulumi.set(__self__, "ip_allow_lists", ip_allow_lists)
        pulumi.set(__self__, "repo_server_delegate", repo_server_delegate)
        pulumi.set(__self__, "subdomain", subdomain)
        pulumi.set(__self__, "sync_history_extension_enabled", sync_history_extension_enabled)

    @property
    @pulumi.getter(name="appSetDelegate")
    def app_set_delegate(self) -> 'outputs.GetInstanceArgocdSpecInstanceSpecAppSetDelegateResult':
        """
        Select cluster in which you want to Install Application Set controller
        """
        return pulumi.get(self, "app_set_delegate")

    @property
    @pulumi.getter(name="appsetPolicy")
    def appset_policy(self) -> 'outputs.GetInstanceArgocdSpecInstanceSpecAppsetPolicyResult':
        """
        Configures Application Set policy settings.
        """
        return pulumi.get(self, "appset_policy")

    @property
    @pulumi.getter(name="assistantExtensionEnabled")
    def assistant_extension_enabled(self) -> bool:
        """
        Enable Powerful AI-powered assistant Extension. It helps analyze Kubernetes resources behavior and provides suggestions about resolving issues.
        """
        return pulumi.get(self, "assistant_extension_enabled")

    @property
    @pulumi.getter(name="auditExtensionEnabled")
    def audit_extension_enabled(self) -> bool:
        """
        Enable Audit Extension. Set this to `true` to install Audit Extension to Argo CD instance.
        """
        return pulumi.get(self, "audit_extension_enabled")

    @property
    @pulumi.getter(name="backendIpAllowListEnabled")
    def backend_ip_allow_list_enabled(self) -> bool:
        """
        Enable ip allow list for cluster agents
        """
        return pulumi.get(self, "backend_ip_allow_list_enabled")

    @property
    @pulumi.getter(name="clusterCustomizationDefaults")
    def cluster_customization_defaults(self) -> 'outputs.GetInstanceArgocdSpecInstanceSpecClusterCustomizationDefaultsResult':
        """
        Default values for cluster agents
        """
        return pulumi.get(self, "cluster_customization_defaults")

    @property
    @pulumi.getter(name="declarativeManagementEnabled")
    def declarative_management_enabled(self) -> bool:
        """
        Enable Declarative Management
        """
        return pulumi.get(self, "declarative_management_enabled")

    @property
    @pulumi.getter
    def extensions(self) -> Sequence['outputs.GetInstanceArgocdSpecInstanceSpecExtensionResult']:
        """
        Extensions
        """
        return pulumi.get(self, "extensions")

    @property
    @pulumi.getter(name="hostAliases")
    def host_aliases(self) -> Sequence['outputs.GetInstanceArgocdSpecInstanceSpecHostAliasResult']:
        """
        Host Aliases that override the DNS entries for control plane Argo CD components such as API Server and Dex.
        """
        return pulumi.get(self, "host_aliases")

    @property
    @pulumi.getter(name="imageUpdaterDelegate")
    def image_updater_delegate(self) -> 'outputs.GetInstanceArgocdSpecInstanceSpecImageUpdaterDelegateResult':
        """
        Select cluster in which you want to Install Image Updater
        """
        return pulumi.get(self, "image_updater_delegate")

    @property
    @pulumi.getter(name="imageUpdaterEnabled")
    def image_updater_enabled(self) -> bool:
        """
        Enable Image Updater
        """
        return pulumi.get(self, "image_updater_enabled")

    @property
    @pulumi.getter(name="ipAllowLists")
    def ip_allow_lists(self) -> Sequence['outputs.GetInstanceArgocdSpecInstanceSpecIpAllowListResult']:
        """
        IP allow list
        """
        return pulumi.get(self, "ip_allow_lists")

    @property
    @pulumi.getter(name="repoServerDelegate")
    def repo_server_delegate(self) -> 'outputs.GetInstanceArgocdSpecInstanceSpecRepoServerDelegateResult':
        """
        In case some clusters don't have network access to your private Git provider you can delegate these operations to one specific cluster.
        """
        return pulumi.get(self, "repo_server_delegate")

    @property
    @pulumi.getter
    def subdomain(self) -> str:
        """
        Instance subdomain. By default equals to instance id
        """
        return pulumi.get(self, "subdomain")

    @property
    @pulumi.getter(name="syncHistoryExtensionEnabled")
    def sync_history_extension_enabled(self) -> bool:
        """
        Enable Sync History Extension. Sync count and duration graphs as well as event details table on Argo CD application details page.
        """
        return pulumi.get(self, "sync_history_extension_enabled")


@pulumi.output_type
class GetInstanceArgocdSpecInstanceSpecAppSetDelegateResult(dict):
    def __init__(__self__, *,
                 managed_cluster: 'outputs.GetInstanceArgocdSpecInstanceSpecAppSetDelegateManagedClusterResult'):
        """
        :param 'GetInstanceArgocdSpecInstanceSpecAppSetDelegateManagedClusterArgs' managed_cluster: Use managed cluster
        """
        pulumi.set(__self__, "managed_cluster", managed_cluster)

    @property
    @pulumi.getter(name="managedCluster")
    def managed_cluster(self) -> 'outputs.GetInstanceArgocdSpecInstanceSpecAppSetDelegateManagedClusterResult':
        """
        Use managed cluster
        """
        return pulumi.get(self, "managed_cluster")


@pulumi.output_type
class GetInstanceArgocdSpecInstanceSpecAppSetDelegateManagedClusterResult(dict):
    def __init__(__self__, *,
                 cluster_name: str):
        """
        :param str cluster_name: Cluster name
        """
        pulumi.set(__self__, "cluster_name", cluster_name)

    @property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> str:
        """
        Cluster name
        """
        return pulumi.get(self, "cluster_name")


@pulumi.output_type
class GetInstanceArgocdSpecInstanceSpecAppsetPolicyResult(dict):
    def __init__(__self__, *,
                 override_policy: bool,
                 policy: str):
        """
        :param bool override_policy: Allows per `ApplicationSet` sync policy.
        :param str policy: Policy restricts what types of modifications will be made to managed Argo CD `Application` resources.
               Available options: `sync`, `create-only`, `create-delete`, and `create-update`.
                 - Policy `sync`(default): Update and delete are allowed.
                 - Policy `create-only`: Prevents ApplicationSet controller from modifying or deleting Applications.
                 - Policy `create-update`: Prevents ApplicationSet controller from deleting Applications. Update is allowed.
                 - Policy `create-delete`: Prevents ApplicationSet controller from modifying Applications, Delete is allowed.
        """
        pulumi.set(__self__, "override_policy", override_policy)
        pulumi.set(__self__, "policy", policy)

    @property
    @pulumi.getter(name="overridePolicy")
    def override_policy(self) -> bool:
        """
        Allows per `ApplicationSet` sync policy.
        """
        return pulumi.get(self, "override_policy")

    @property
    @pulumi.getter
    def policy(self) -> str:
        """
        Policy restricts what types of modifications will be made to managed Argo CD `Application` resources.
        Available options: `sync`, `create-only`, `create-delete`, and `create-update`.
          - Policy `sync`(default): Update and delete are allowed.
          - Policy `create-only`: Prevents ApplicationSet controller from modifying or deleting Applications.
          - Policy `create-update`: Prevents ApplicationSet controller from deleting Applications. Update is allowed.
          - Policy `create-delete`: Prevents ApplicationSet controller from modifying Applications, Delete is allowed.
        """
        return pulumi.get(self, "policy")


@pulumi.output_type
class GetInstanceArgocdSpecInstanceSpecClusterCustomizationDefaultsResult(dict):
    def __init__(__self__, *,
                 app_replication: bool,
                 auto_upgrade_disabled: bool,
                 kustomization: str,
                 redis_tunneling: bool):
        """
        :param bool app_replication: Enables Argo CD state replication to the managed cluster that allows disconnecting the cluster from Akuity Platform without losing core Argocd features
        :param str kustomization: Kustomize configuration that will be applied to generated agent installation manifests
        :param bool redis_tunneling: Enables the ability to connect to Redis over a web-socket tunnel that allows using Akuity agent behind HTTPS proxy
        """
        pulumi.set(__self__, "app_replication", app_replication)
        pulumi.set(__self__, "auto_upgrade_disabled", auto_upgrade_disabled)
        pulumi.set(__self__, "kustomization", kustomization)
        pulumi.set(__self__, "redis_tunneling", redis_tunneling)

    @property
    @pulumi.getter(name="appReplication")
    def app_replication(self) -> bool:
        """
        Enables Argo CD state replication to the managed cluster that allows disconnecting the cluster from Akuity Platform without losing core Argocd features
        """
        return pulumi.get(self, "app_replication")

    @property
    @pulumi.getter(name="autoUpgradeDisabled")
    def auto_upgrade_disabled(self) -> bool:
        return pulumi.get(self, "auto_upgrade_disabled")

    @property
    @pulumi.getter
    def kustomization(self) -> str:
        """
        Kustomize configuration that will be applied to generated agent installation manifests
        """
        return pulumi.get(self, "kustomization")

    @property
    @pulumi.getter(name="redisTunneling")
    def redis_tunneling(self) -> bool:
        """
        Enables the ability to connect to Redis over a web-socket tunnel that allows using Akuity agent behind HTTPS proxy
        """
        return pulumi.get(self, "redis_tunneling")


@pulumi.output_type
class GetInstanceArgocdSpecInstanceSpecExtensionResult(dict):
    def __init__(__self__, *,
                 id: str,
                 version: str):
        """
        :param str id: Extension ID
        :param str version: Extension version
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Extension ID
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def version(self) -> str:
        """
        Extension version
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class GetInstanceArgocdSpecInstanceSpecHostAliasResult(dict):
    def __init__(__self__, *,
                 hostnames: Sequence[str],
                 ip: str):
        """
        :param Sequence[str] hostnames: Hostnames
        :param str ip: IP address
        """
        pulumi.set(__self__, "hostnames", hostnames)
        pulumi.set(__self__, "ip", ip)

    @property
    @pulumi.getter
    def hostnames(self) -> Sequence[str]:
        """
        Hostnames
        """
        return pulumi.get(self, "hostnames")

    @property
    @pulumi.getter
    def ip(self) -> str:
        """
        IP address
        """
        return pulumi.get(self, "ip")


@pulumi.output_type
class GetInstanceArgocdSpecInstanceSpecImageUpdaterDelegateResult(dict):
    def __init__(__self__, *,
                 control_plane: bool,
                 managed_cluster: 'outputs.GetInstanceArgocdSpecInstanceSpecImageUpdaterDelegateManagedClusterResult'):
        """
        :param bool control_plane: If use control plane or not
        :param 'GetInstanceArgocdSpecInstanceSpecImageUpdaterDelegateManagedClusterArgs' managed_cluster: If use managed cluster or not
        """
        pulumi.set(__self__, "control_plane", control_plane)
        pulumi.set(__self__, "managed_cluster", managed_cluster)

    @property
    @pulumi.getter(name="controlPlane")
    def control_plane(self) -> bool:
        """
        If use control plane or not
        """
        return pulumi.get(self, "control_plane")

    @property
    @pulumi.getter(name="managedCluster")
    def managed_cluster(self) -> 'outputs.GetInstanceArgocdSpecInstanceSpecImageUpdaterDelegateManagedClusterResult':
        """
        If use managed cluster or not
        """
        return pulumi.get(self, "managed_cluster")


@pulumi.output_type
class GetInstanceArgocdSpecInstanceSpecImageUpdaterDelegateManagedClusterResult(dict):
    def __init__(__self__, *,
                 cluster_name: str):
        """
        :param str cluster_name: Cluster name
        """
        pulumi.set(__self__, "cluster_name", cluster_name)

    @property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> str:
        """
        Cluster name
        """
        return pulumi.get(self, "cluster_name")


@pulumi.output_type
class GetInstanceArgocdSpecInstanceSpecIpAllowListResult(dict):
    def __init__(__self__, *,
                 description: str,
                 ip: str):
        """
        :param str description: IP description
        :param str ip: IP address
        """
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "ip", ip)

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        IP description
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def ip(self) -> str:
        """
        IP address
        """
        return pulumi.get(self, "ip")


@pulumi.output_type
class GetInstanceArgocdSpecInstanceSpecRepoServerDelegateResult(dict):
    def __init__(__self__, *,
                 control_plane: bool,
                 managed_cluster: 'outputs.GetInstanceArgocdSpecInstanceSpecRepoServerDelegateManagedClusterResult'):
        """
        :param bool control_plane: If use control plane or not
        :param 'GetInstanceArgocdSpecInstanceSpecRepoServerDelegateManagedClusterArgs' managed_cluster: If use managed cluster or not
        """
        pulumi.set(__self__, "control_plane", control_plane)
        pulumi.set(__self__, "managed_cluster", managed_cluster)

    @property
    @pulumi.getter(name="controlPlane")
    def control_plane(self) -> bool:
        """
        If use control plane or not
        """
        return pulumi.get(self, "control_plane")

    @property
    @pulumi.getter(name="managedCluster")
    def managed_cluster(self) -> 'outputs.GetInstanceArgocdSpecInstanceSpecRepoServerDelegateManagedClusterResult':
        """
        If use managed cluster or not
        """
        return pulumi.get(self, "managed_cluster")


@pulumi.output_type
class GetInstanceArgocdSpecInstanceSpecRepoServerDelegateManagedClusterResult(dict):
    def __init__(__self__, *,
                 cluster_name: str):
        """
        :param str cluster_name: Cluster name
        """
        pulumi.set(__self__, "cluster_name", cluster_name)

    @property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> str:
        """
        Cluster name
        """
        return pulumi.get(self, "cluster_name")


@pulumi.output_type
class GetInstanceConfigManagementPluginsResult(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 image: str,
                 spec: 'outputs.GetInstanceConfigManagementPluginsSpecResult'):
        """
        :param bool enabled: Whether this plugin is enabled or not. Default to false.
        :param str image: Image to use for the plugin
        :param 'GetInstanceConfigManagementPluginsSpecArgs' spec: Plugin spec
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "image", image)
        pulumi.set(__self__, "spec", spec)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Whether this plugin is enabled or not. Default to false.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def image(self) -> str:
        """
        Image to use for the plugin
        """
        return pulumi.get(self, "image")

    @property
    @pulumi.getter
    def spec(self) -> 'outputs.GetInstanceConfigManagementPluginsSpecResult':
        """
        Plugin spec
        """
        return pulumi.get(self, "spec")


@pulumi.output_type
class GetInstanceConfigManagementPluginsSpecResult(dict):
    def __init__(__self__, *,
                 discover: 'outputs.GetInstanceConfigManagementPluginsSpecDiscoverResult',
                 generate: 'outputs.GetInstanceConfigManagementPluginsSpecGenerateResult',
                 init: 'outputs.GetInstanceConfigManagementPluginsSpecInitResult',
                 parameters: 'outputs.GetInstanceConfigManagementPluginsSpecParametersResult',
                 preserve_file_mode: bool,
                 version: str):
        """
        :param 'GetInstanceConfigManagementPluginsSpecDiscoverArgs' discover: The discovery config is applied to a repository. If every configured discovery tool matches, then the plugin may be used to generate manifests for Applications using the repository. If the discovery config is omitted then the plugin will not match any application but can still be invoked explicitly by specifying the plugin name in the app spec. Only one of fileName, find.glob, or find.command should be specified. If multiple are specified then only the first (in that order) is evaluated.
        :param 'GetInstanceConfigManagementPluginsSpecGenerateArgs' generate: The generate command runs in the Application source directory each time manifests are generated. Standard output must be ONLY valid Kubernetes Objects in either YAML or JSON. A non-zero exit code will fail manifest generation. Error output will be sent to the UI, so avoid printing sensitive information (such as secrets).
        :param 'GetInstanceConfigManagementPluginsSpecInitArgs' init: The init command runs in the Application source directory at the beginning of each manifest generation. The init command can output anything. A non-zero status code will fail manifest generation. Init always happens immediately before generate, but its output is not treated as manifests. This is a good place to, for example, download chart dependencies.
        :param 'GetInstanceConfigManagementPluginsSpecParametersArgs' parameters: The parameters config describes what parameters the UI should display for an Application. It is up to the user to actually set parameters in the Application manifest (in spec.source.plugin.parameters). The announcements only inform the "Parameters" tab in the App Details page of the UI.
        :param bool preserve_file_mode: Whether the plugin receives repository files with original file mode. Dangerous since the repository might have executable files. Set to true only if you trust the CMP plugin authors. Set to false by default.
        :param str version: Plugin version
        """
        pulumi.set(__self__, "discover", discover)
        pulumi.set(__self__, "generate", generate)
        pulumi.set(__self__, "init", init)
        pulumi.set(__self__, "parameters", parameters)
        pulumi.set(__self__, "preserve_file_mode", preserve_file_mode)
        pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def discover(self) -> 'outputs.GetInstanceConfigManagementPluginsSpecDiscoverResult':
        """
        The discovery config is applied to a repository. If every configured discovery tool matches, then the plugin may be used to generate manifests for Applications using the repository. If the discovery config is omitted then the plugin will not match any application but can still be invoked explicitly by specifying the plugin name in the app spec. Only one of fileName, find.glob, or find.command should be specified. If multiple are specified then only the first (in that order) is evaluated.
        """
        return pulumi.get(self, "discover")

    @property
    @pulumi.getter
    def generate(self) -> 'outputs.GetInstanceConfigManagementPluginsSpecGenerateResult':
        """
        The generate command runs in the Application source directory each time manifests are generated. Standard output must be ONLY valid Kubernetes Objects in either YAML or JSON. A non-zero exit code will fail manifest generation. Error output will be sent to the UI, so avoid printing sensitive information (such as secrets).
        """
        return pulumi.get(self, "generate")

    @property
    @pulumi.getter
    def init(self) -> 'outputs.GetInstanceConfigManagementPluginsSpecInitResult':
        """
        The init command runs in the Application source directory at the beginning of each manifest generation. The init command can output anything. A non-zero status code will fail manifest generation. Init always happens immediately before generate, but its output is not treated as manifests. This is a good place to, for example, download chart dependencies.
        """
        return pulumi.get(self, "init")

    @property
    @pulumi.getter
    def parameters(self) -> 'outputs.GetInstanceConfigManagementPluginsSpecParametersResult':
        """
        The parameters config describes what parameters the UI should display for an Application. It is up to the user to actually set parameters in the Application manifest (in spec.source.plugin.parameters). The announcements only inform the "Parameters" tab in the App Details page of the UI.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter(name="preserveFileMode")
    def preserve_file_mode(self) -> bool:
        """
        Whether the plugin receives repository files with original file mode. Dangerous since the repository might have executable files. Set to true only if you trust the CMP plugin authors. Set to false by default.
        """
        return pulumi.get(self, "preserve_file_mode")

    @property
    @pulumi.getter
    def version(self) -> str:
        """
        Plugin version
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class GetInstanceConfigManagementPluginsSpecDiscoverResult(dict):
    def __init__(__self__, *,
                 file_name: str,
                 find: 'outputs.GetInstanceConfigManagementPluginsSpecDiscoverFindResult'):
        """
        :param str file_name: A glob pattern (https://pkg.go.dev/path/filepath#Glob) that is applied to the Application's source directory. If there is a match, this plugin may be used for the Application.
        :param 'GetInstanceConfigManagementPluginsSpecDiscoverFindArgs' find: Find config
        """
        pulumi.set(__self__, "file_name", file_name)
        pulumi.set(__self__, "find", find)

    @property
    @pulumi.getter(name="fileName")
    def file_name(self) -> str:
        """
        A glob pattern (https://pkg.go.dev/path/filepath#Glob) that is applied to the Application's source directory. If there is a match, this plugin may be used for the Application.
        """
        return pulumi.get(self, "file_name")

    @property
    @pulumi.getter
    def find(self) -> 'outputs.GetInstanceConfigManagementPluginsSpecDiscoverFindResult':
        """
        Find config
        """
        return pulumi.get(self, "find")


@pulumi.output_type
class GetInstanceConfigManagementPluginsSpecDiscoverFindResult(dict):
    def __init__(__self__, *,
                 args: Sequence[str],
                 commands: Sequence[str],
                 glob: str):
        """
        :param Sequence[str] args: Arguments for the find command
        :param Sequence[str] commands: The find command runs in the repository's root directory. To match, it must exit with status code 0 and produce non-empty output to standard out.
        :param str glob: This does the same thing as `file_name`, but it supports double-start (nested directory) glob patterns.
        """
        pulumi.set(__self__, "args", args)
        pulumi.set(__self__, "commands", commands)
        pulumi.set(__self__, "glob", glob)

    @property
    @pulumi.getter
    def args(self) -> Sequence[str]:
        """
        Arguments for the find command
        """
        return pulumi.get(self, "args")

    @property
    @pulumi.getter
    def commands(self) -> Sequence[str]:
        """
        The find command runs in the repository's root directory. To match, it must exit with status code 0 and produce non-empty output to standard out.
        """
        return pulumi.get(self, "commands")

    @property
    @pulumi.getter
    def glob(self) -> str:
        """
        This does the same thing as `file_name`, but it supports double-start (nested directory) glob patterns.
        """
        return pulumi.get(self, "glob")


@pulumi.output_type
class GetInstanceConfigManagementPluginsSpecGenerateResult(dict):
    def __init__(__self__, *,
                 args: Sequence[str],
                 commands: Sequence[str]):
        """
        :param Sequence[str] args: Arguments of the command
        :param Sequence[str] commands: Command
        """
        pulumi.set(__self__, "args", args)
        pulumi.set(__self__, "commands", commands)

    @property
    @pulumi.getter
    def args(self) -> Sequence[str]:
        """
        Arguments of the command
        """
        return pulumi.get(self, "args")

    @property
    @pulumi.getter
    def commands(self) -> Sequence[str]:
        """
        Command
        """
        return pulumi.get(self, "commands")


@pulumi.output_type
class GetInstanceConfigManagementPluginsSpecInitResult(dict):
    def __init__(__self__, *,
                 args: Sequence[str],
                 commands: Sequence[str]):
        """
        :param Sequence[str] args: Arguments of the command
        :param Sequence[str] commands: Command
        """
        pulumi.set(__self__, "args", args)
        pulumi.set(__self__, "commands", commands)

    @property
    @pulumi.getter
    def args(self) -> Sequence[str]:
        """
        Arguments of the command
        """
        return pulumi.get(self, "args")

    @property
    @pulumi.getter
    def commands(self) -> Sequence[str]:
        """
        Command
        """
        return pulumi.get(self, "commands")


@pulumi.output_type
class GetInstanceConfigManagementPluginsSpecParametersResult(dict):
    def __init__(__self__, *,
                 dynamic: 'outputs.GetInstanceConfigManagementPluginsSpecParametersDynamicResult',
                 statics: Sequence['outputs.GetInstanceConfigManagementPluginsSpecParametersStaticResult']):
        """
        :param 'GetInstanceConfigManagementPluginsSpecParametersDynamicArgs' dynamic: Dynamic parameter announcements are announcements specific to an Application handled by this plugin. For example, the values for a Helm chart's values.yaml file could be sent as parameter announcements.
        :param Sequence['GetInstanceConfigManagementPluginsSpecParametersStaticArgs'] statics: Static parameter announcements are sent to the UI for all Applications handled by this plugin. Think of the `string`, `array`, and `map` values set here as defaults. It is up to the plugin author to make sure that these default values actually reflect the plugin's behavior if the user doesn't explicitly set different values for those parameters.
        """
        pulumi.set(__self__, "dynamic", dynamic)
        pulumi.set(__self__, "statics", statics)

    @property
    @pulumi.getter
    def dynamic(self) -> 'outputs.GetInstanceConfigManagementPluginsSpecParametersDynamicResult':
        """
        Dynamic parameter announcements are announcements specific to an Application handled by this plugin. For example, the values for a Helm chart's values.yaml file could be sent as parameter announcements.
        """
        return pulumi.get(self, "dynamic")

    @property
    @pulumi.getter
    def statics(self) -> Sequence['outputs.GetInstanceConfigManagementPluginsSpecParametersStaticResult']:
        """
        Static parameter announcements are sent to the UI for all Applications handled by this plugin. Think of the `string`, `array`, and `map` values set here as defaults. It is up to the plugin author to make sure that these default values actually reflect the plugin's behavior if the user doesn't explicitly set different values for those parameters.
        """
        return pulumi.get(self, "statics")


@pulumi.output_type
class GetInstanceConfigManagementPluginsSpecParametersDynamicResult(dict):
    def __init__(__self__, *,
                 args: Sequence[str],
                 commands: Sequence[str]):
        """
        :param Sequence[str] args: Arguments of the command
        :param Sequence[str] commands: The command will run in an Application's source directory. Standard output must be JSON matching the schema of the static parameter announcements list.
        """
        pulumi.set(__self__, "args", args)
        pulumi.set(__self__, "commands", commands)

    @property
    @pulumi.getter
    def args(self) -> Sequence[str]:
        """
        Arguments of the command
        """
        return pulumi.get(self, "args")

    @property
    @pulumi.getter
    def commands(self) -> Sequence[str]:
        """
        The command will run in an Application's source directory. Standard output must be JSON matching the schema of the static parameter announcements list.
        """
        return pulumi.get(self, "commands")


@pulumi.output_type
class GetInstanceConfigManagementPluginsSpecParametersStaticResult(dict):
    def __init__(__self__, *,
                 arrays: Sequence[str],
                 collection_type: str,
                 item_type: str,
                 map: Mapping[str, str],
                 name: str,
                 required: bool,
                 string: str,
                 title: str,
                 tooltip: str):
        """
        :param Sequence[str] arrays: This field communicates the parameter's default value to the UI if the parameter is an `array`.
        :param str collection_type: Collection Type describes what type of value this parameter accepts (string, array, or map) and allows the UI to present a form to match that type. Default is `string`. This field must be present for non-string types. It will not be inferred from the presence of an `array` or `map` field.
        :param str item_type: Item type tells the UI how to present the parameter's value (or, for arrays and maps, values). Default is `string`. Examples of other types which may be supported in the future are `boolean` or `number`. Even if the itemType is not `string`, the parameter value from the Application spec will be sent to the plugin as a string. It's up to the plugin to do the appropriate conversion.
        :param Mapping[str, str] map: This field communicates the parameter's default value to the UI if the parameter is a `map`.
        :param str name: Parameter name
        :param bool required: Whether the Parameter is required or not. If this field is set to true, the UI will indicate to the user that they must set the value. Default to false.
        :param str string: This field communicates the parameter's default value to the UI if the parameter is a `string`.
        :param str title: Title and description of the parameter
        :param str tooltip: Tooltip of the Parameter, will be shown when hovering over the title
        """
        pulumi.set(__self__, "arrays", arrays)
        pulumi.set(__self__, "collection_type", collection_type)
        pulumi.set(__self__, "item_type", item_type)
        pulumi.set(__self__, "map", map)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "required", required)
        pulumi.set(__self__, "string", string)
        pulumi.set(__self__, "title", title)
        pulumi.set(__self__, "tooltip", tooltip)

    @property
    @pulumi.getter
    def arrays(self) -> Sequence[str]:
        """
        This field communicates the parameter's default value to the UI if the parameter is an `array`.
        """
        return pulumi.get(self, "arrays")

    @property
    @pulumi.getter(name="collectionType")
    def collection_type(self) -> str:
        """
        Collection Type describes what type of value this parameter accepts (string, array, or map) and allows the UI to present a form to match that type. Default is `string`. This field must be present for non-string types. It will not be inferred from the presence of an `array` or `map` field.
        """
        return pulumi.get(self, "collection_type")

    @property
    @pulumi.getter(name="itemType")
    def item_type(self) -> str:
        """
        Item type tells the UI how to present the parameter's value (or, for arrays and maps, values). Default is `string`. Examples of other types which may be supported in the future are `boolean` or `number`. Even if the itemType is not `string`, the parameter value from the Application spec will be sent to the plugin as a string. It's up to the plugin to do the appropriate conversion.
        """
        return pulumi.get(self, "item_type")

    @property
    @pulumi.getter
    def map(self) -> Mapping[str, str]:
        """
        This field communicates the parameter's default value to the UI if the parameter is a `map`.
        """
        return pulumi.get(self, "map")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Parameter name
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def required(self) -> bool:
        """
        Whether the Parameter is required or not. If this field is set to true, the UI will indicate to the user that they must set the value. Default to false.
        """
        return pulumi.get(self, "required")

    @property
    @pulumi.getter
    def string(self) -> str:
        """
        This field communicates the parameter's default value to the UI if the parameter is a `string`.
        """
        return pulumi.get(self, "string")

    @property
    @pulumi.getter
    def title(self) -> str:
        """
        Title and description of the parameter
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter
    def tooltip(self) -> str:
        """
        Tooltip of the Parameter, will be shown when hovering over the title
        """
        return pulumi.get(self, "tooltip")


