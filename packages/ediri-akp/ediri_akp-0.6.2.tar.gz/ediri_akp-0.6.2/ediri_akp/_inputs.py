# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from . import _utilities

__all__ = [
    'ClusterKubeConfigArgs',
    'ClusterSpecArgs',
    'ClusterSpecDataArgs',
    'InstanceArgocdArgs',
    'InstanceArgocdSpecArgs',
    'InstanceArgocdSpecInstanceSpecArgs',
    'InstanceArgocdSpecInstanceSpecAppSetDelegateArgs',
    'InstanceArgocdSpecInstanceSpecAppSetDelegateManagedClusterArgs',
    'InstanceArgocdSpecInstanceSpecAppsetPolicyArgs',
    'InstanceArgocdSpecInstanceSpecClusterCustomizationDefaultsArgs',
    'InstanceArgocdSpecInstanceSpecExtensionArgs',
    'InstanceArgocdSpecInstanceSpecHostAliasArgs',
    'InstanceArgocdSpecInstanceSpecImageUpdaterDelegateArgs',
    'InstanceArgocdSpecInstanceSpecImageUpdaterDelegateManagedClusterArgs',
    'InstanceArgocdSpecInstanceSpecIpAllowListArgs',
    'InstanceArgocdSpecInstanceSpecRepoServerDelegateArgs',
    'InstanceArgocdSpecInstanceSpecRepoServerDelegateManagedClusterArgs',
    'InstanceConfigManagementPluginsArgs',
    'InstanceConfigManagementPluginsSpecArgs',
    'InstanceConfigManagementPluginsSpecDiscoverArgs',
    'InstanceConfigManagementPluginsSpecDiscoverFindArgs',
    'InstanceConfigManagementPluginsSpecGenerateArgs',
    'InstanceConfigManagementPluginsSpecInitArgs',
    'InstanceConfigManagementPluginsSpecParametersArgs',
    'InstanceConfigManagementPluginsSpecParametersDynamicArgs',
    'InstanceConfigManagementPluginsSpecParametersStaticArgs',
]

@pulumi.input_type
class ClusterKubeConfigArgs:
    def __init__(__self__, *,
                 client_certificate: Optional[pulumi.Input[str]] = None,
                 client_key: Optional[pulumi.Input[str]] = None,
                 cluster_ca_certificate: Optional[pulumi.Input[str]] = None,
                 config_context: Optional[pulumi.Input[str]] = None,
                 config_context_auth_info: Optional[pulumi.Input[str]] = None,
                 config_context_cluster: Optional[pulumi.Input[str]] = None,
                 config_path: Optional[pulumi.Input[str]] = None,
                 config_paths: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 host: Optional[pulumi.Input[str]] = None,
                 insecure: Optional[pulumi.Input[bool]] = None,
                 password: Optional[pulumi.Input[str]] = None,
                 proxy_url: Optional[pulumi.Input[str]] = None,
                 token: Optional[pulumi.Input[str]] = None,
                 username: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] client_certificate: PEM-encoded client certificate for TLS authentication.
        :param pulumi.Input[str] client_key: PEM-encoded client certificate key for TLS authentication.
        :param pulumi.Input[str] cluster_ca_certificate: PEM-encoded root certificates bundle for TLS authentication.
        :param pulumi.Input[str] config_context: Context name to load from the kube config file.
        :param pulumi.Input[str] config_path: Path to the kube config file.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] config_paths: A list of paths to kube config files.
        :param pulumi.Input[str] host: The hostname (in form of URI) of Kubernetes master.
        :param pulumi.Input[bool] insecure: Whether server should be accessed without verifying the TLS certificate.
        :param pulumi.Input[str] password: The password to use for HTTP basic authentication when accessing the Kubernetes master endpoint.
        :param pulumi.Input[str] proxy_url: URL to the proxy to be used for all API requests
        :param pulumi.Input[str] token: Token to authenticate an service account
        :param pulumi.Input[str] username: The username to use for HTTP basic authentication when accessing the Kubernetes master endpoint.
        """
        if client_certificate is not None:
            pulumi.set(__self__, "client_certificate", client_certificate)
        if client_key is not None:
            pulumi.set(__self__, "client_key", client_key)
        if cluster_ca_certificate is not None:
            pulumi.set(__self__, "cluster_ca_certificate", cluster_ca_certificate)
        if config_context is not None:
            pulumi.set(__self__, "config_context", config_context)
        if config_context_auth_info is not None:
            pulumi.set(__self__, "config_context_auth_info", config_context_auth_info)
        if config_context_cluster is not None:
            pulumi.set(__self__, "config_context_cluster", config_context_cluster)
        if config_path is not None:
            pulumi.set(__self__, "config_path", config_path)
        if config_paths is not None:
            pulumi.set(__self__, "config_paths", config_paths)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if insecure is not None:
            pulumi.set(__self__, "insecure", insecure)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if proxy_url is not None:
            pulumi.set(__self__, "proxy_url", proxy_url)
        if token is not None:
            pulumi.set(__self__, "token", token)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="clientCertificate")
    def client_certificate(self) -> Optional[pulumi.Input[str]]:
        """
        PEM-encoded client certificate for TLS authentication.
        """
        return pulumi.get(self, "client_certificate")

    @client_certificate.setter
    def client_certificate(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_certificate", value)

    @property
    @pulumi.getter(name="clientKey")
    def client_key(self) -> Optional[pulumi.Input[str]]:
        """
        PEM-encoded client certificate key for TLS authentication.
        """
        return pulumi.get(self, "client_key")

    @client_key.setter
    def client_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_key", value)

    @property
    @pulumi.getter(name="clusterCaCertificate")
    def cluster_ca_certificate(self) -> Optional[pulumi.Input[str]]:
        """
        PEM-encoded root certificates bundle for TLS authentication.
        """
        return pulumi.get(self, "cluster_ca_certificate")

    @cluster_ca_certificate.setter
    def cluster_ca_certificate(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cluster_ca_certificate", value)

    @property
    @pulumi.getter(name="configContext")
    def config_context(self) -> Optional[pulumi.Input[str]]:
        """
        Context name to load from the kube config file.
        """
        return pulumi.get(self, "config_context")

    @config_context.setter
    def config_context(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "config_context", value)

    @property
    @pulumi.getter(name="configContextAuthInfo")
    def config_context_auth_info(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "config_context_auth_info")

    @config_context_auth_info.setter
    def config_context_auth_info(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "config_context_auth_info", value)

    @property
    @pulumi.getter(name="configContextCluster")
    def config_context_cluster(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "config_context_cluster")

    @config_context_cluster.setter
    def config_context_cluster(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "config_context_cluster", value)

    @property
    @pulumi.getter(name="configPath")
    def config_path(self) -> Optional[pulumi.Input[str]]:
        """
        Path to the kube config file.
        """
        return pulumi.get(self, "config_path")

    @config_path.setter
    def config_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "config_path", value)

    @property
    @pulumi.getter(name="configPaths")
    def config_paths(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of paths to kube config files.
        """
        return pulumi.get(self, "config_paths")

    @config_paths.setter
    def config_paths(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "config_paths", value)

    @property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[str]]:
        """
        The hostname (in form of URI) of Kubernetes master.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter
    def insecure(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether server should be accessed without verifying the TLS certificate.
        """
        return pulumi.get(self, "insecure")

    @insecure.setter
    def insecure(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "insecure", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[str]]:
        """
        The password to use for HTTP basic authentication when accessing the Kubernetes master endpoint.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter(name="proxyUrl")
    def proxy_url(self) -> Optional[pulumi.Input[str]]:
        """
        URL to the proxy to be used for all API requests
        """
        return pulumi.get(self, "proxy_url")

    @proxy_url.setter
    def proxy_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "proxy_url", value)

    @property
    @pulumi.getter
    def token(self) -> Optional[pulumi.Input[str]]:
        """
        Token to authenticate an service account
        """
        return pulumi.get(self, "token")

    @token.setter
    def token(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "token", value)

    @property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[str]]:
        """
        The username to use for HTTP basic authentication when accessing the Kubernetes master endpoint.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "username", value)


@pulumi.input_type
class ClusterSpecArgs:
    def __init__(__self__, *,
                 data: pulumi.Input['ClusterSpecDataArgs'],
                 description: Optional[pulumi.Input[str]] = None,
                 namespace_scoped: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input['ClusterSpecDataArgs'] data: Cluster data
        :param pulumi.Input[str] description: Cluster description
        :param pulumi.Input[bool] namespace_scoped: If the agent is namespace scoped
        """
        pulumi.set(__self__, "data", data)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if namespace_scoped is not None:
            pulumi.set(__self__, "namespace_scoped", namespace_scoped)

    @property
    @pulumi.getter
    def data(self) -> pulumi.Input['ClusterSpecDataArgs']:
        """
        Cluster data
        """
        return pulumi.get(self, "data")

    @data.setter
    def data(self, value: pulumi.Input['ClusterSpecDataArgs']):
        pulumi.set(self, "data", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Cluster description
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="namespaceScoped")
    def namespace_scoped(self) -> Optional[pulumi.Input[bool]]:
        """
        If the agent is namespace scoped
        """
        return pulumi.get(self, "namespace_scoped")

    @namespace_scoped.setter
    def namespace_scoped(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "namespace_scoped", value)


@pulumi.input_type
class ClusterSpecDataArgs:
    def __init__(__self__, *,
                 size: pulumi.Input[str],
                 app_replication: Optional[pulumi.Input[bool]] = None,
                 auto_upgrade_disabled: Optional[pulumi.Input[bool]] = None,
                 kustomization: Optional[pulumi.Input[str]] = None,
                 redis_tunneling: Optional[pulumi.Input[bool]] = None,
                 target_version: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] size: Cluster Size. One of `small`, `medium` or `large`
        :param pulumi.Input[bool] app_replication: Enables Argo CD state replication to the managed cluster that allows disconnecting the cluster from Akuity Platform without losing core Argocd features
        :param pulumi.Input[str] kustomization: Kustomize configuration that will be applied to generated agent installation manifests
        :param pulumi.Input[bool] redis_tunneling: Enables the ability to connect to Redis over a web-socket tunnel that allows using Akuity agent behind HTTPS proxy
        :param pulumi.Input[str] target_version: The version of the agent to install on your cluster
        """
        pulumi.set(__self__, "size", size)
        if app_replication is not None:
            pulumi.set(__self__, "app_replication", app_replication)
        if auto_upgrade_disabled is not None:
            pulumi.set(__self__, "auto_upgrade_disabled", auto_upgrade_disabled)
        if kustomization is not None:
            pulumi.set(__self__, "kustomization", kustomization)
        if redis_tunneling is not None:
            pulumi.set(__self__, "redis_tunneling", redis_tunneling)
        if target_version is not None:
            pulumi.set(__self__, "target_version", target_version)

    @property
    @pulumi.getter
    def size(self) -> pulumi.Input[str]:
        """
        Cluster Size. One of `small`, `medium` or `large`
        """
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: pulumi.Input[str]):
        pulumi.set(self, "size", value)

    @property
    @pulumi.getter(name="appReplication")
    def app_replication(self) -> Optional[pulumi.Input[bool]]:
        """
        Enables Argo CD state replication to the managed cluster that allows disconnecting the cluster from Akuity Platform without losing core Argocd features
        """
        return pulumi.get(self, "app_replication")

    @app_replication.setter
    def app_replication(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "app_replication", value)

    @property
    @pulumi.getter(name="autoUpgradeDisabled")
    def auto_upgrade_disabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "auto_upgrade_disabled")

    @auto_upgrade_disabled.setter
    def auto_upgrade_disabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "auto_upgrade_disabled", value)

    @property
    @pulumi.getter
    def kustomization(self) -> Optional[pulumi.Input[str]]:
        """
        Kustomize configuration that will be applied to generated agent installation manifests
        """
        return pulumi.get(self, "kustomization")

    @kustomization.setter
    def kustomization(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kustomization", value)

    @property
    @pulumi.getter(name="redisTunneling")
    def redis_tunneling(self) -> Optional[pulumi.Input[bool]]:
        """
        Enables the ability to connect to Redis over a web-socket tunnel that allows using Akuity agent behind HTTPS proxy
        """
        return pulumi.get(self, "redis_tunneling")

    @redis_tunneling.setter
    def redis_tunneling(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "redis_tunneling", value)

    @property
    @pulumi.getter(name="targetVersion")
    def target_version(self) -> Optional[pulumi.Input[str]]:
        """
        The version of the agent to install on your cluster
        """
        return pulumi.get(self, "target_version")

    @target_version.setter
    def target_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "target_version", value)


@pulumi.input_type
class InstanceArgocdArgs:
    def __init__(__self__, *,
                 spec: pulumi.Input['InstanceArgocdSpecArgs']):
        """
        :param pulumi.Input['InstanceArgocdSpecArgs'] spec: Argo CD instance spec
        """
        pulumi.set(__self__, "spec", spec)

    @property
    @pulumi.getter
    def spec(self) -> pulumi.Input['InstanceArgocdSpecArgs']:
        """
        Argo CD instance spec
        """
        return pulumi.get(self, "spec")

    @spec.setter
    def spec(self, value: pulumi.Input['InstanceArgocdSpecArgs']):
        pulumi.set(self, "spec", value)


@pulumi.input_type
class InstanceArgocdSpecArgs:
    def __init__(__self__, *,
                 instance_spec: pulumi.Input['InstanceArgocdSpecInstanceSpecArgs'],
                 version: pulumi.Input[str],
                 description: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['InstanceArgocdSpecInstanceSpecArgs'] instance_spec: Argo CD instance spec
        :param pulumi.Input[str] version: Argo CD version. Should be equal to any Akuity [`argocd` image tag](https://quay.io/repository/akuity/argocd?tab=tags).
        :param pulumi.Input[str] description: Instance description
        """
        pulumi.set(__self__, "instance_spec", instance_spec)
        pulumi.set(__self__, "version", version)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter(name="instanceSpec")
    def instance_spec(self) -> pulumi.Input['InstanceArgocdSpecInstanceSpecArgs']:
        """
        Argo CD instance spec
        """
        return pulumi.get(self, "instance_spec")

    @instance_spec.setter
    def instance_spec(self, value: pulumi.Input['InstanceArgocdSpecInstanceSpecArgs']):
        pulumi.set(self, "instance_spec", value)

    @property
    @pulumi.getter
    def version(self) -> pulumi.Input[str]:
        """
        Argo CD version. Should be equal to any Akuity [`argocd` image tag](https://quay.io/repository/akuity/argocd?tab=tags).
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: pulumi.Input[str]):
        pulumi.set(self, "version", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Instance description
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)


@pulumi.input_type
class InstanceArgocdSpecInstanceSpecArgs:
    def __init__(__self__, *,
                 app_set_delegate: Optional[pulumi.Input['InstanceArgocdSpecInstanceSpecAppSetDelegateArgs']] = None,
                 appset_policy: Optional[pulumi.Input['InstanceArgocdSpecInstanceSpecAppsetPolicyArgs']] = None,
                 assistant_extension_enabled: Optional[pulumi.Input[bool]] = None,
                 audit_extension_enabled: Optional[pulumi.Input[bool]] = None,
                 backend_ip_allow_list_enabled: Optional[pulumi.Input[bool]] = None,
                 cluster_customization_defaults: Optional[pulumi.Input['InstanceArgocdSpecInstanceSpecClusterCustomizationDefaultsArgs']] = None,
                 declarative_management_enabled: Optional[pulumi.Input[bool]] = None,
                 extensions: Optional[pulumi.Input[Sequence[pulumi.Input['InstanceArgocdSpecInstanceSpecExtensionArgs']]]] = None,
                 host_aliases: Optional[pulumi.Input[Sequence[pulumi.Input['InstanceArgocdSpecInstanceSpecHostAliasArgs']]]] = None,
                 image_updater_delegate: Optional[pulumi.Input['InstanceArgocdSpecInstanceSpecImageUpdaterDelegateArgs']] = None,
                 image_updater_enabled: Optional[pulumi.Input[bool]] = None,
                 ip_allow_lists: Optional[pulumi.Input[Sequence[pulumi.Input['InstanceArgocdSpecInstanceSpecIpAllowListArgs']]]] = None,
                 repo_server_delegate: Optional[pulumi.Input['InstanceArgocdSpecInstanceSpecRepoServerDelegateArgs']] = None,
                 subdomain: Optional[pulumi.Input[str]] = None,
                 sync_history_extension_enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input['InstanceArgocdSpecInstanceSpecAppSetDelegateArgs'] app_set_delegate: Select cluster in which you want to Install Application Set controller
        :param pulumi.Input['InstanceArgocdSpecInstanceSpecAppsetPolicyArgs'] appset_policy: Configures Application Set policy settings.
        :param pulumi.Input[bool] assistant_extension_enabled: Enable Powerful AI-powered assistant Extension. It helps analyze Kubernetes resources behavior and provides suggestions about resolving issues.
        :param pulumi.Input[bool] audit_extension_enabled: Enable Audit Extension. Set this to `true` to install Audit Extension to Argo CD instance.
        :param pulumi.Input[bool] backend_ip_allow_list_enabled: Enable ip allow list for cluster agents
        :param pulumi.Input['InstanceArgocdSpecInstanceSpecClusterCustomizationDefaultsArgs'] cluster_customization_defaults: Default values for cluster agents
        :param pulumi.Input[bool] declarative_management_enabled: Enable Declarative Management
        :param pulumi.Input[Sequence[pulumi.Input['InstanceArgocdSpecInstanceSpecExtensionArgs']]] extensions: Extensions
        :param pulumi.Input[Sequence[pulumi.Input['InstanceArgocdSpecInstanceSpecHostAliasArgs']]] host_aliases: Host Aliases that override the DNS entries for control plane Argo CD components such as API Server and Dex.
        :param pulumi.Input['InstanceArgocdSpecInstanceSpecImageUpdaterDelegateArgs'] image_updater_delegate: Select cluster in which you want to Install Image Updater
        :param pulumi.Input[bool] image_updater_enabled: Enable Image Updater
        :param pulumi.Input[Sequence[pulumi.Input['InstanceArgocdSpecInstanceSpecIpAllowListArgs']]] ip_allow_lists: IP allow list
        :param pulumi.Input['InstanceArgocdSpecInstanceSpecRepoServerDelegateArgs'] repo_server_delegate: In case some clusters don't have network access to your private Git provider you can delegate these operations to one specific cluster.
        :param pulumi.Input[str] subdomain: Instance subdomain. By default equals to instance id
        :param pulumi.Input[bool] sync_history_extension_enabled: Enable Sync History Extension. Sync count and duration graphs as well as event details table on Argo CD application details page.
        """
        if app_set_delegate is not None:
            pulumi.set(__self__, "app_set_delegate", app_set_delegate)
        if appset_policy is not None:
            pulumi.set(__self__, "appset_policy", appset_policy)
        if assistant_extension_enabled is not None:
            pulumi.set(__self__, "assistant_extension_enabled", assistant_extension_enabled)
        if audit_extension_enabled is not None:
            pulumi.set(__self__, "audit_extension_enabled", audit_extension_enabled)
        if backend_ip_allow_list_enabled is not None:
            pulumi.set(__self__, "backend_ip_allow_list_enabled", backend_ip_allow_list_enabled)
        if cluster_customization_defaults is not None:
            pulumi.set(__self__, "cluster_customization_defaults", cluster_customization_defaults)
        if declarative_management_enabled is not None:
            pulumi.set(__self__, "declarative_management_enabled", declarative_management_enabled)
        if extensions is not None:
            pulumi.set(__self__, "extensions", extensions)
        if host_aliases is not None:
            pulumi.set(__self__, "host_aliases", host_aliases)
        if image_updater_delegate is not None:
            pulumi.set(__self__, "image_updater_delegate", image_updater_delegate)
        if image_updater_enabled is not None:
            pulumi.set(__self__, "image_updater_enabled", image_updater_enabled)
        if ip_allow_lists is not None:
            pulumi.set(__self__, "ip_allow_lists", ip_allow_lists)
        if repo_server_delegate is not None:
            pulumi.set(__self__, "repo_server_delegate", repo_server_delegate)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if sync_history_extension_enabled is not None:
            pulumi.set(__self__, "sync_history_extension_enabled", sync_history_extension_enabled)

    @property
    @pulumi.getter(name="appSetDelegate")
    def app_set_delegate(self) -> Optional[pulumi.Input['InstanceArgocdSpecInstanceSpecAppSetDelegateArgs']]:
        """
        Select cluster in which you want to Install Application Set controller
        """
        return pulumi.get(self, "app_set_delegate")

    @app_set_delegate.setter
    def app_set_delegate(self, value: Optional[pulumi.Input['InstanceArgocdSpecInstanceSpecAppSetDelegateArgs']]):
        pulumi.set(self, "app_set_delegate", value)

    @property
    @pulumi.getter(name="appsetPolicy")
    def appset_policy(self) -> Optional[pulumi.Input['InstanceArgocdSpecInstanceSpecAppsetPolicyArgs']]:
        """
        Configures Application Set policy settings.
        """
        return pulumi.get(self, "appset_policy")

    @appset_policy.setter
    def appset_policy(self, value: Optional[pulumi.Input['InstanceArgocdSpecInstanceSpecAppsetPolicyArgs']]):
        pulumi.set(self, "appset_policy", value)

    @property
    @pulumi.getter(name="assistantExtensionEnabled")
    def assistant_extension_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable Powerful AI-powered assistant Extension. It helps analyze Kubernetes resources behavior and provides suggestions about resolving issues.
        """
        return pulumi.get(self, "assistant_extension_enabled")

    @assistant_extension_enabled.setter
    def assistant_extension_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "assistant_extension_enabled", value)

    @property
    @pulumi.getter(name="auditExtensionEnabled")
    def audit_extension_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable Audit Extension. Set this to `true` to install Audit Extension to Argo CD instance.
        """
        return pulumi.get(self, "audit_extension_enabled")

    @audit_extension_enabled.setter
    def audit_extension_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "audit_extension_enabled", value)

    @property
    @pulumi.getter(name="backendIpAllowListEnabled")
    def backend_ip_allow_list_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable ip allow list for cluster agents
        """
        return pulumi.get(self, "backend_ip_allow_list_enabled")

    @backend_ip_allow_list_enabled.setter
    def backend_ip_allow_list_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "backend_ip_allow_list_enabled", value)

    @property
    @pulumi.getter(name="clusterCustomizationDefaults")
    def cluster_customization_defaults(self) -> Optional[pulumi.Input['InstanceArgocdSpecInstanceSpecClusterCustomizationDefaultsArgs']]:
        """
        Default values for cluster agents
        """
        return pulumi.get(self, "cluster_customization_defaults")

    @cluster_customization_defaults.setter
    def cluster_customization_defaults(self, value: Optional[pulumi.Input['InstanceArgocdSpecInstanceSpecClusterCustomizationDefaultsArgs']]):
        pulumi.set(self, "cluster_customization_defaults", value)

    @property
    @pulumi.getter(name="declarativeManagementEnabled")
    def declarative_management_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable Declarative Management
        """
        return pulumi.get(self, "declarative_management_enabled")

    @declarative_management_enabled.setter
    def declarative_management_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "declarative_management_enabled", value)

    @property
    @pulumi.getter
    def extensions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['InstanceArgocdSpecInstanceSpecExtensionArgs']]]]:
        """
        Extensions
        """
        return pulumi.get(self, "extensions")

    @extensions.setter
    def extensions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['InstanceArgocdSpecInstanceSpecExtensionArgs']]]]):
        pulumi.set(self, "extensions", value)

    @property
    @pulumi.getter(name="hostAliases")
    def host_aliases(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['InstanceArgocdSpecInstanceSpecHostAliasArgs']]]]:
        """
        Host Aliases that override the DNS entries for control plane Argo CD components such as API Server and Dex.
        """
        return pulumi.get(self, "host_aliases")

    @host_aliases.setter
    def host_aliases(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['InstanceArgocdSpecInstanceSpecHostAliasArgs']]]]):
        pulumi.set(self, "host_aliases", value)

    @property
    @pulumi.getter(name="imageUpdaterDelegate")
    def image_updater_delegate(self) -> Optional[pulumi.Input['InstanceArgocdSpecInstanceSpecImageUpdaterDelegateArgs']]:
        """
        Select cluster in which you want to Install Image Updater
        """
        return pulumi.get(self, "image_updater_delegate")

    @image_updater_delegate.setter
    def image_updater_delegate(self, value: Optional[pulumi.Input['InstanceArgocdSpecInstanceSpecImageUpdaterDelegateArgs']]):
        pulumi.set(self, "image_updater_delegate", value)

    @property
    @pulumi.getter(name="imageUpdaterEnabled")
    def image_updater_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable Image Updater
        """
        return pulumi.get(self, "image_updater_enabled")

    @image_updater_enabled.setter
    def image_updater_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "image_updater_enabled", value)

    @property
    @pulumi.getter(name="ipAllowLists")
    def ip_allow_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['InstanceArgocdSpecInstanceSpecIpAllowListArgs']]]]:
        """
        IP allow list
        """
        return pulumi.get(self, "ip_allow_lists")

    @ip_allow_lists.setter
    def ip_allow_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['InstanceArgocdSpecInstanceSpecIpAllowListArgs']]]]):
        pulumi.set(self, "ip_allow_lists", value)

    @property
    @pulumi.getter(name="repoServerDelegate")
    def repo_server_delegate(self) -> Optional[pulumi.Input['InstanceArgocdSpecInstanceSpecRepoServerDelegateArgs']]:
        """
        In case some clusters don't have network access to your private Git provider you can delegate these operations to one specific cluster.
        """
        return pulumi.get(self, "repo_server_delegate")

    @repo_server_delegate.setter
    def repo_server_delegate(self, value: Optional[pulumi.Input['InstanceArgocdSpecInstanceSpecRepoServerDelegateArgs']]):
        pulumi.set(self, "repo_server_delegate", value)

    @property
    @pulumi.getter
    def subdomain(self) -> Optional[pulumi.Input[str]]:
        """
        Instance subdomain. By default equals to instance id
        """
        return pulumi.get(self, "subdomain")

    @subdomain.setter
    def subdomain(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subdomain", value)

    @property
    @pulumi.getter(name="syncHistoryExtensionEnabled")
    def sync_history_extension_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable Sync History Extension. Sync count and duration graphs as well as event details table on Argo CD application details page.
        """
        return pulumi.get(self, "sync_history_extension_enabled")

    @sync_history_extension_enabled.setter
    def sync_history_extension_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "sync_history_extension_enabled", value)


@pulumi.input_type
class InstanceArgocdSpecInstanceSpecAppSetDelegateArgs:
    def __init__(__self__, *,
                 managed_cluster: Optional[pulumi.Input['InstanceArgocdSpecInstanceSpecAppSetDelegateManagedClusterArgs']] = None):
        """
        :param pulumi.Input['InstanceArgocdSpecInstanceSpecAppSetDelegateManagedClusterArgs'] managed_cluster: Use managed cluster
        """
        if managed_cluster is not None:
            pulumi.set(__self__, "managed_cluster", managed_cluster)

    @property
    @pulumi.getter(name="managedCluster")
    def managed_cluster(self) -> Optional[pulumi.Input['InstanceArgocdSpecInstanceSpecAppSetDelegateManagedClusterArgs']]:
        """
        Use managed cluster
        """
        return pulumi.get(self, "managed_cluster")

    @managed_cluster.setter
    def managed_cluster(self, value: Optional[pulumi.Input['InstanceArgocdSpecInstanceSpecAppSetDelegateManagedClusterArgs']]):
        pulumi.set(self, "managed_cluster", value)


@pulumi.input_type
class InstanceArgocdSpecInstanceSpecAppSetDelegateManagedClusterArgs:
    def __init__(__self__, *,
                 cluster_name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] cluster_name: Cluster name
        """
        pulumi.set(__self__, "cluster_name", cluster_name)

    @property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> pulumi.Input[str]:
        """
        Cluster name
        """
        return pulumi.get(self, "cluster_name")

    @cluster_name.setter
    def cluster_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "cluster_name", value)


@pulumi.input_type
class InstanceArgocdSpecInstanceSpecAppsetPolicyArgs:
    def __init__(__self__, *,
                 override_policy: Optional[pulumi.Input[bool]] = None,
                 policy: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] override_policy: Allows per `ApplicationSet` sync policy.
        :param pulumi.Input[str] policy: Policy restricts what types of modifications will be made to managed Argo CD `Application` resources.
               Available options: `sync`, `create-only`, `create-delete`, and `create-update`.
                 - Policy `sync`(default): Update and delete are allowed.
                 - Policy `create-only`: Prevents ApplicationSet controller from modifying or deleting Applications.
                 - Policy `create-update`: Prevents ApplicationSet controller from deleting Applications. Update is allowed.
                 - Policy `create-delete`: Prevents ApplicationSet controller from modifying Applications, Delete is allowed.
        """
        if override_policy is not None:
            pulumi.set(__self__, "override_policy", override_policy)
        if policy is not None:
            pulumi.set(__self__, "policy", policy)

    @property
    @pulumi.getter(name="overridePolicy")
    def override_policy(self) -> Optional[pulumi.Input[bool]]:
        """
        Allows per `ApplicationSet` sync policy.
        """
        return pulumi.get(self, "override_policy")

    @override_policy.setter
    def override_policy(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "override_policy", value)

    @property
    @pulumi.getter
    def policy(self) -> Optional[pulumi.Input[str]]:
        """
        Policy restricts what types of modifications will be made to managed Argo CD `Application` resources.
        Available options: `sync`, `create-only`, `create-delete`, and `create-update`.
          - Policy `sync`(default): Update and delete are allowed.
          - Policy `create-only`: Prevents ApplicationSet controller from modifying or deleting Applications.
          - Policy `create-update`: Prevents ApplicationSet controller from deleting Applications. Update is allowed.
          - Policy `create-delete`: Prevents ApplicationSet controller from modifying Applications, Delete is allowed.
        """
        return pulumi.get(self, "policy")

    @policy.setter
    def policy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "policy", value)


@pulumi.input_type
class InstanceArgocdSpecInstanceSpecClusterCustomizationDefaultsArgs:
    def __init__(__self__, *,
                 app_replication: Optional[pulumi.Input[bool]] = None,
                 auto_upgrade_disabled: Optional[pulumi.Input[bool]] = None,
                 kustomization: Optional[pulumi.Input[str]] = None,
                 redis_tunneling: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] app_replication: Enables Argo CD state replication to the managed cluster that allows disconnecting the cluster from Akuity Platform without losing core Argocd features
        :param pulumi.Input[str] kustomization: Kustomize configuration that will be applied to generated agent installation manifests
        :param pulumi.Input[bool] redis_tunneling: Enables the ability to connect to Redis over a web-socket tunnel that allows using Akuity agent behind HTTPS proxy
        """
        if app_replication is not None:
            pulumi.set(__self__, "app_replication", app_replication)
        if auto_upgrade_disabled is not None:
            pulumi.set(__self__, "auto_upgrade_disabled", auto_upgrade_disabled)
        if kustomization is not None:
            pulumi.set(__self__, "kustomization", kustomization)
        if redis_tunneling is not None:
            pulumi.set(__self__, "redis_tunneling", redis_tunneling)

    @property
    @pulumi.getter(name="appReplication")
    def app_replication(self) -> Optional[pulumi.Input[bool]]:
        """
        Enables Argo CD state replication to the managed cluster that allows disconnecting the cluster from Akuity Platform without losing core Argocd features
        """
        return pulumi.get(self, "app_replication")

    @app_replication.setter
    def app_replication(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "app_replication", value)

    @property
    @pulumi.getter(name="autoUpgradeDisabled")
    def auto_upgrade_disabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "auto_upgrade_disabled")

    @auto_upgrade_disabled.setter
    def auto_upgrade_disabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "auto_upgrade_disabled", value)

    @property
    @pulumi.getter
    def kustomization(self) -> Optional[pulumi.Input[str]]:
        """
        Kustomize configuration that will be applied to generated agent installation manifests
        """
        return pulumi.get(self, "kustomization")

    @kustomization.setter
    def kustomization(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kustomization", value)

    @property
    @pulumi.getter(name="redisTunneling")
    def redis_tunneling(self) -> Optional[pulumi.Input[bool]]:
        """
        Enables the ability to connect to Redis over a web-socket tunnel that allows using Akuity agent behind HTTPS proxy
        """
        return pulumi.get(self, "redis_tunneling")

    @redis_tunneling.setter
    def redis_tunneling(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "redis_tunneling", value)


@pulumi.input_type
class InstanceArgocdSpecInstanceSpecExtensionArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str],
                 version: pulumi.Input[str]):
        """
        :param pulumi.Input[str] id: Extension ID
        :param pulumi.Input[str] version: Extension version
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        Extension ID
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def version(self) -> pulumi.Input[str]:
        """
        Extension version
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: pulumi.Input[str]):
        pulumi.set(self, "version", value)


@pulumi.input_type
class InstanceArgocdSpecInstanceSpecHostAliasArgs:
    def __init__(__self__, *,
                 ip: pulumi.Input[str],
                 hostnames: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] ip: IP address
        :param pulumi.Input[Sequence[pulumi.Input[str]]] hostnames: List of hostnames
        """
        pulumi.set(__self__, "ip", ip)
        if hostnames is not None:
            pulumi.set(__self__, "hostnames", hostnames)

    @property
    @pulumi.getter
    def ip(self) -> pulumi.Input[str]:
        """
        IP address
        """
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: pulumi.Input[str]):
        pulumi.set(self, "ip", value)

    @property
    @pulumi.getter
    def hostnames(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of hostnames
        """
        return pulumi.get(self, "hostnames")

    @hostnames.setter
    def hostnames(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "hostnames", value)


@pulumi.input_type
class InstanceArgocdSpecInstanceSpecImageUpdaterDelegateArgs:
    def __init__(__self__, *,
                 control_plane: pulumi.Input[bool],
                 managed_cluster: Optional[pulumi.Input['InstanceArgocdSpecInstanceSpecImageUpdaterDelegateManagedClusterArgs']] = None):
        """
        :param pulumi.Input[bool] control_plane: If use control plane or not
        :param pulumi.Input['InstanceArgocdSpecInstanceSpecImageUpdaterDelegateManagedClusterArgs'] managed_cluster: If use managed cluster or not
        """
        pulumi.set(__self__, "control_plane", control_plane)
        if managed_cluster is not None:
            pulumi.set(__self__, "managed_cluster", managed_cluster)

    @property
    @pulumi.getter(name="controlPlane")
    def control_plane(self) -> pulumi.Input[bool]:
        """
        If use control plane or not
        """
        return pulumi.get(self, "control_plane")

    @control_plane.setter
    def control_plane(self, value: pulumi.Input[bool]):
        pulumi.set(self, "control_plane", value)

    @property
    @pulumi.getter(name="managedCluster")
    def managed_cluster(self) -> Optional[pulumi.Input['InstanceArgocdSpecInstanceSpecImageUpdaterDelegateManagedClusterArgs']]:
        """
        If use managed cluster or not
        """
        return pulumi.get(self, "managed_cluster")

    @managed_cluster.setter
    def managed_cluster(self, value: Optional[pulumi.Input['InstanceArgocdSpecInstanceSpecImageUpdaterDelegateManagedClusterArgs']]):
        pulumi.set(self, "managed_cluster", value)


@pulumi.input_type
class InstanceArgocdSpecInstanceSpecImageUpdaterDelegateManagedClusterArgs:
    def __init__(__self__, *,
                 cluster_name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] cluster_name: Cluster name
        """
        pulumi.set(__self__, "cluster_name", cluster_name)

    @property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> pulumi.Input[str]:
        """
        Cluster name
        """
        return pulumi.get(self, "cluster_name")

    @cluster_name.setter
    def cluster_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "cluster_name", value)


@pulumi.input_type
class InstanceArgocdSpecInstanceSpecIpAllowListArgs:
    def __init__(__self__, *,
                 ip: pulumi.Input[str],
                 description: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] ip: IP address
        :param pulumi.Input[str] description: IP description
        """
        pulumi.set(__self__, "ip", ip)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter
    def ip(self) -> pulumi.Input[str]:
        """
        IP address
        """
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: pulumi.Input[str]):
        pulumi.set(self, "ip", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        IP description
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)


@pulumi.input_type
class InstanceArgocdSpecInstanceSpecRepoServerDelegateArgs:
    def __init__(__self__, *,
                 control_plane: pulumi.Input[bool],
                 managed_cluster: Optional[pulumi.Input['InstanceArgocdSpecInstanceSpecRepoServerDelegateManagedClusterArgs']] = None):
        """
        :param pulumi.Input[bool] control_plane: If use control plane or not
        :param pulumi.Input['InstanceArgocdSpecInstanceSpecRepoServerDelegateManagedClusterArgs'] managed_cluster: If use managed cluster or not
        """
        pulumi.set(__self__, "control_plane", control_plane)
        if managed_cluster is not None:
            pulumi.set(__self__, "managed_cluster", managed_cluster)

    @property
    @pulumi.getter(name="controlPlane")
    def control_plane(self) -> pulumi.Input[bool]:
        """
        If use control plane or not
        """
        return pulumi.get(self, "control_plane")

    @control_plane.setter
    def control_plane(self, value: pulumi.Input[bool]):
        pulumi.set(self, "control_plane", value)

    @property
    @pulumi.getter(name="managedCluster")
    def managed_cluster(self) -> Optional[pulumi.Input['InstanceArgocdSpecInstanceSpecRepoServerDelegateManagedClusterArgs']]:
        """
        If use managed cluster or not
        """
        return pulumi.get(self, "managed_cluster")

    @managed_cluster.setter
    def managed_cluster(self, value: Optional[pulumi.Input['InstanceArgocdSpecInstanceSpecRepoServerDelegateManagedClusterArgs']]):
        pulumi.set(self, "managed_cluster", value)


@pulumi.input_type
class InstanceArgocdSpecInstanceSpecRepoServerDelegateManagedClusterArgs:
    def __init__(__self__, *,
                 cluster_name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] cluster_name: Cluster name
        """
        pulumi.set(__self__, "cluster_name", cluster_name)

    @property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> pulumi.Input[str]:
        """
        Cluster name
        """
        return pulumi.get(self, "cluster_name")

    @cluster_name.setter
    def cluster_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "cluster_name", value)


@pulumi.input_type
class InstanceConfigManagementPluginsArgs:
    def __init__(__self__, *,
                 image: pulumi.Input[str],
                 spec: pulumi.Input['InstanceConfigManagementPluginsSpecArgs'],
                 enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] image: Image to use for the plugin
        :param pulumi.Input['InstanceConfigManagementPluginsSpecArgs'] spec: Plugin spec
        :param pulumi.Input[bool] enabled: Whether this plugin is enabled or not. Default to false.
        """
        pulumi.set(__self__, "image", image)
        pulumi.set(__self__, "spec", spec)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def image(self) -> pulumi.Input[str]:
        """
        Image to use for the plugin
        """
        return pulumi.get(self, "image")

    @image.setter
    def image(self, value: pulumi.Input[str]):
        pulumi.set(self, "image", value)

    @property
    @pulumi.getter
    def spec(self) -> pulumi.Input['InstanceConfigManagementPluginsSpecArgs']:
        """
        Plugin spec
        """
        return pulumi.get(self, "spec")

    @spec.setter
    def spec(self, value: pulumi.Input['InstanceConfigManagementPluginsSpecArgs']):
        pulumi.set(self, "spec", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether this plugin is enabled or not. Default to false.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)


@pulumi.input_type
class InstanceConfigManagementPluginsSpecArgs:
    def __init__(__self__, *,
                 generate: pulumi.Input['InstanceConfigManagementPluginsSpecGenerateArgs'],
                 discover: Optional[pulumi.Input['InstanceConfigManagementPluginsSpecDiscoverArgs']] = None,
                 init: Optional[pulumi.Input['InstanceConfigManagementPluginsSpecInitArgs']] = None,
                 parameters: Optional[pulumi.Input['InstanceConfigManagementPluginsSpecParametersArgs']] = None,
                 preserve_file_mode: Optional[pulumi.Input[bool]] = None,
                 version: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['InstanceConfigManagementPluginsSpecGenerateArgs'] generate: The generate command runs in the Application source directory each time manifests are generated. Standard output must be ONLY valid Kubernetes Objects in either YAML or JSON. A non-zero exit code will fail manifest generation. Error output will be sent to the UI, so avoid printing sensitive information (such as secrets).
        :param pulumi.Input['InstanceConfigManagementPluginsSpecDiscoverArgs'] discover: The discovery config is applied to a repository. If every configured discovery tool matches, then the plugin may be used to generate manifests for Applications using the repository. If the discovery config is omitted then the plugin will not match any application but can still be invoked explicitly by specifying the plugin name in the app spec. Only one of fileName, find.glob, or find.command should be specified. If multiple are specified then only the first (in that order) is evaluated.
        :param pulumi.Input['InstanceConfigManagementPluginsSpecInitArgs'] init: The init command runs in the Application source directory at the beginning of each manifest generation. The init command can output anything. A non-zero status code will fail manifest generation. Init always happens immediately before generate, but its output is not treated as manifests. This is a good place to, for example, download chart dependencies.
        :param pulumi.Input['InstanceConfigManagementPluginsSpecParametersArgs'] parameters: The parameters config describes what parameters the UI should display for an Application. It is up to the user to actually set parameters in the Application manifest (in spec.source.plugin.parameters). The announcements only inform the "Parameters" tab in the App Details page of the UI.
        :param pulumi.Input[bool] preserve_file_mode: Whether the plugin receives repository files with original file mode. Dangerous since the repository might have executable files. Set to true only if you trust the CMP plugin authors. Set to false by default.
        :param pulumi.Input[str] version: Plugin version
        """
        pulumi.set(__self__, "generate", generate)
        if discover is not None:
            pulumi.set(__self__, "discover", discover)
        if init is not None:
            pulumi.set(__self__, "init", init)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if preserve_file_mode is not None:
            pulumi.set(__self__, "preserve_file_mode", preserve_file_mode)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def generate(self) -> pulumi.Input['InstanceConfigManagementPluginsSpecGenerateArgs']:
        """
        The generate command runs in the Application source directory each time manifests are generated. Standard output must be ONLY valid Kubernetes Objects in either YAML or JSON. A non-zero exit code will fail manifest generation. Error output will be sent to the UI, so avoid printing sensitive information (such as secrets).
        """
        return pulumi.get(self, "generate")

    @generate.setter
    def generate(self, value: pulumi.Input['InstanceConfigManagementPluginsSpecGenerateArgs']):
        pulumi.set(self, "generate", value)

    @property
    @pulumi.getter
    def discover(self) -> Optional[pulumi.Input['InstanceConfigManagementPluginsSpecDiscoverArgs']]:
        """
        The discovery config is applied to a repository. If every configured discovery tool matches, then the plugin may be used to generate manifests for Applications using the repository. If the discovery config is omitted then the plugin will not match any application but can still be invoked explicitly by specifying the plugin name in the app spec. Only one of fileName, find.glob, or find.command should be specified. If multiple are specified then only the first (in that order) is evaluated.
        """
        return pulumi.get(self, "discover")

    @discover.setter
    def discover(self, value: Optional[pulumi.Input['InstanceConfigManagementPluginsSpecDiscoverArgs']]):
        pulumi.set(self, "discover", value)

    @property
    @pulumi.getter
    def init(self) -> Optional[pulumi.Input['InstanceConfigManagementPluginsSpecInitArgs']]:
        """
        The init command runs in the Application source directory at the beginning of each manifest generation. The init command can output anything. A non-zero status code will fail manifest generation. Init always happens immediately before generate, but its output is not treated as manifests. This is a good place to, for example, download chart dependencies.
        """
        return pulumi.get(self, "init")

    @init.setter
    def init(self, value: Optional[pulumi.Input['InstanceConfigManagementPluginsSpecInitArgs']]):
        pulumi.set(self, "init", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input['InstanceConfigManagementPluginsSpecParametersArgs']]:
        """
        The parameters config describes what parameters the UI should display for an Application. It is up to the user to actually set parameters in the Application manifest (in spec.source.plugin.parameters). The announcements only inform the "Parameters" tab in the App Details page of the UI.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input['InstanceConfigManagementPluginsSpecParametersArgs']]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter(name="preserveFileMode")
    def preserve_file_mode(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether the plugin receives repository files with original file mode. Dangerous since the repository might have executable files. Set to true only if you trust the CMP plugin authors. Set to false by default.
        """
        return pulumi.get(self, "preserve_file_mode")

    @preserve_file_mode.setter
    def preserve_file_mode(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "preserve_file_mode", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[str]]:
        """
        Plugin version
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "version", value)


@pulumi.input_type
class InstanceConfigManagementPluginsSpecDiscoverArgs:
    def __init__(__self__, *,
                 file_name: Optional[pulumi.Input[str]] = None,
                 find: Optional[pulumi.Input['InstanceConfigManagementPluginsSpecDiscoverFindArgs']] = None):
        """
        :param pulumi.Input[str] file_name: A glob pattern (https://pkg.go.dev/path/filepath#Glob) that is applied to the Application's source directory. If there is a match, this plugin may be used for the Application.
        :param pulumi.Input['InstanceConfigManagementPluginsSpecDiscoverFindArgs'] find: Find config
        """
        if file_name is not None:
            pulumi.set(__self__, "file_name", file_name)
        if find is not None:
            pulumi.set(__self__, "find", find)

    @property
    @pulumi.getter(name="fileName")
    def file_name(self) -> Optional[pulumi.Input[str]]:
        """
        A glob pattern (https://pkg.go.dev/path/filepath#Glob) that is applied to the Application's source directory. If there is a match, this plugin may be used for the Application.
        """
        return pulumi.get(self, "file_name")

    @file_name.setter
    def file_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "file_name", value)

    @property
    @pulumi.getter
    def find(self) -> Optional[pulumi.Input['InstanceConfigManagementPluginsSpecDiscoverFindArgs']]:
        """
        Find config
        """
        return pulumi.get(self, "find")

    @find.setter
    def find(self, value: Optional[pulumi.Input['InstanceConfigManagementPluginsSpecDiscoverFindArgs']]):
        pulumi.set(self, "find", value)


@pulumi.input_type
class InstanceConfigManagementPluginsSpecDiscoverFindArgs:
    def __init__(__self__, *,
                 args: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 commands: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 glob: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] args: Arguments for the find command
        :param pulumi.Input[Sequence[pulumi.Input[str]]] commands: The find command runs in the repository's root directory. To match, it must exit with status code 0 and produce non-empty output to standard out.
        :param pulumi.Input[str] glob: This does the same thing as `file_name`, but it supports double-start (nested directory) glob patterns.
        """
        if args is not None:
            pulumi.set(__self__, "args", args)
        if commands is not None:
            pulumi.set(__self__, "commands", commands)
        if glob is not None:
            pulumi.set(__self__, "glob", glob)

    @property
    @pulumi.getter
    def args(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Arguments for the find command
        """
        return pulumi.get(self, "args")

    @args.setter
    def args(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "args", value)

    @property
    @pulumi.getter
    def commands(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The find command runs in the repository's root directory. To match, it must exit with status code 0 and produce non-empty output to standard out.
        """
        return pulumi.get(self, "commands")

    @commands.setter
    def commands(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "commands", value)

    @property
    @pulumi.getter
    def glob(self) -> Optional[pulumi.Input[str]]:
        """
        This does the same thing as `file_name`, but it supports double-start (nested directory) glob patterns.
        """
        return pulumi.get(self, "glob")

    @glob.setter
    def glob(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "glob", value)


@pulumi.input_type
class InstanceConfigManagementPluginsSpecGenerateArgs:
    def __init__(__self__, *,
                 commands: pulumi.Input[Sequence[pulumi.Input[str]]],
                 args: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] commands: Command
        :param pulumi.Input[Sequence[pulumi.Input[str]]] args: Arguments of the command
        """
        pulumi.set(__self__, "commands", commands)
        if args is not None:
            pulumi.set(__self__, "args", args)

    @property
    @pulumi.getter
    def commands(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Command
        """
        return pulumi.get(self, "commands")

    @commands.setter
    def commands(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "commands", value)

    @property
    @pulumi.getter
    def args(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Arguments of the command
        """
        return pulumi.get(self, "args")

    @args.setter
    def args(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "args", value)


@pulumi.input_type
class InstanceConfigManagementPluginsSpecInitArgs:
    def __init__(__self__, *,
                 commands: pulumi.Input[Sequence[pulumi.Input[str]]],
                 args: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] commands: Command
        :param pulumi.Input[Sequence[pulumi.Input[str]]] args: Arguments of the command
        """
        pulumi.set(__self__, "commands", commands)
        if args is not None:
            pulumi.set(__self__, "args", args)

    @property
    @pulumi.getter
    def commands(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Command
        """
        return pulumi.get(self, "commands")

    @commands.setter
    def commands(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "commands", value)

    @property
    @pulumi.getter
    def args(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Arguments of the command
        """
        return pulumi.get(self, "args")

    @args.setter
    def args(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "args", value)


@pulumi.input_type
class InstanceConfigManagementPluginsSpecParametersArgs:
    def __init__(__self__, *,
                 dynamic: Optional[pulumi.Input['InstanceConfigManagementPluginsSpecParametersDynamicArgs']] = None,
                 statics: Optional[pulumi.Input[Sequence[pulumi.Input['InstanceConfigManagementPluginsSpecParametersStaticArgs']]]] = None):
        """
        :param pulumi.Input['InstanceConfigManagementPluginsSpecParametersDynamicArgs'] dynamic: Dynamic parameter announcements are announcements specific to an Application handled by this plugin. For example, the values for a Helm chart's values.yaml file could be sent as parameter announcements.
        :param pulumi.Input[Sequence[pulumi.Input['InstanceConfigManagementPluginsSpecParametersStaticArgs']]] statics: Static parameter announcements are sent to the UI for all Applications handled by this plugin. Think of the `string`, `array`, and `map` values set here as defaults. It is up to the plugin author to make sure that these default values actually reflect the plugin's behavior if the user doesn't explicitly set different values for those parameters.
        """
        if dynamic is not None:
            pulumi.set(__self__, "dynamic", dynamic)
        if statics is not None:
            pulumi.set(__self__, "statics", statics)

    @property
    @pulumi.getter
    def dynamic(self) -> Optional[pulumi.Input['InstanceConfigManagementPluginsSpecParametersDynamicArgs']]:
        """
        Dynamic parameter announcements are announcements specific to an Application handled by this plugin. For example, the values for a Helm chart's values.yaml file could be sent as parameter announcements.
        """
        return pulumi.get(self, "dynamic")

    @dynamic.setter
    def dynamic(self, value: Optional[pulumi.Input['InstanceConfigManagementPluginsSpecParametersDynamicArgs']]):
        pulumi.set(self, "dynamic", value)

    @property
    @pulumi.getter
    def statics(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['InstanceConfigManagementPluginsSpecParametersStaticArgs']]]]:
        """
        Static parameter announcements are sent to the UI for all Applications handled by this plugin. Think of the `string`, `array`, and `map` values set here as defaults. It is up to the plugin author to make sure that these default values actually reflect the plugin's behavior if the user doesn't explicitly set different values for those parameters.
        """
        return pulumi.get(self, "statics")

    @statics.setter
    def statics(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['InstanceConfigManagementPluginsSpecParametersStaticArgs']]]]):
        pulumi.set(self, "statics", value)


@pulumi.input_type
class InstanceConfigManagementPluginsSpecParametersDynamicArgs:
    def __init__(__self__, *,
                 args: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 commands: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] args: Arguments of the command
        :param pulumi.Input[Sequence[pulumi.Input[str]]] commands: The command will run in an Application's source directory. Standard output must be JSON matching the schema of the static parameter announcements list.
        """
        if args is not None:
            pulumi.set(__self__, "args", args)
        if commands is not None:
            pulumi.set(__self__, "commands", commands)

    @property
    @pulumi.getter
    def args(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Arguments of the command
        """
        return pulumi.get(self, "args")

    @args.setter
    def args(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "args", value)

    @property
    @pulumi.getter
    def commands(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The command will run in an Application's source directory. Standard output must be JSON matching the schema of the static parameter announcements list.
        """
        return pulumi.get(self, "commands")

    @commands.setter
    def commands(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "commands", value)


@pulumi.input_type
class InstanceConfigManagementPluginsSpecParametersStaticArgs:
    def __init__(__self__, *,
                 arrays: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 collection_type: Optional[pulumi.Input[str]] = None,
                 item_type: Optional[pulumi.Input[str]] = None,
                 map: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 required: Optional[pulumi.Input[bool]] = None,
                 string: Optional[pulumi.Input[str]] = None,
                 title: Optional[pulumi.Input[str]] = None,
                 tooltip: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] arrays: This field communicates the parameter's default value to the UI if the parameter is an `array`.
        :param pulumi.Input[str] collection_type: Collection Type describes what type of value this parameter accepts (string, array, or map) and allows the UI to present a form to match that type. Default is `string`. This field must be present for non-string types. It will not be inferred from the presence of an `array` or `map` field.
        :param pulumi.Input[str] item_type: Item type tells the UI how to present the parameter's value (or, for arrays and maps, values). Default is `string`. Examples of other types which may be supported in the future are `boolean` or `number`. Even if the itemType is not `string`, the parameter value from the Application spec will be sent to the plugin as a string. It's up to the plugin to do the appropriate conversion.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] map: This field communicates the parameter's default value to the UI if the parameter is a `map`.
        :param pulumi.Input[str] name: Parameter name
        :param pulumi.Input[bool] required: Whether the Parameter is required or not. If this field is set to true, the UI will indicate to the user that they must set the value. Default to false.
        :param pulumi.Input[str] string: This field communicates the parameter's default value to the UI if the parameter is a `string`.
        :param pulumi.Input[str] title: Title and description of the parameter
        :param pulumi.Input[str] tooltip: Tooltip of the Parameter, will be shown when hovering over the title
        """
        if arrays is not None:
            pulumi.set(__self__, "arrays", arrays)
        if collection_type is not None:
            pulumi.set(__self__, "collection_type", collection_type)
        if item_type is not None:
            pulumi.set(__self__, "item_type", item_type)
        if map is not None:
            pulumi.set(__self__, "map", map)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if required is not None:
            pulumi.set(__self__, "required", required)
        if string is not None:
            pulumi.set(__self__, "string", string)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if tooltip is not None:
            pulumi.set(__self__, "tooltip", tooltip)

    @property
    @pulumi.getter
    def arrays(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        This field communicates the parameter's default value to the UI if the parameter is an `array`.
        """
        return pulumi.get(self, "arrays")

    @arrays.setter
    def arrays(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "arrays", value)

    @property
    @pulumi.getter(name="collectionType")
    def collection_type(self) -> Optional[pulumi.Input[str]]:
        """
        Collection Type describes what type of value this parameter accepts (string, array, or map) and allows the UI to present a form to match that type. Default is `string`. This field must be present for non-string types. It will not be inferred from the presence of an `array` or `map` field.
        """
        return pulumi.get(self, "collection_type")

    @collection_type.setter
    def collection_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "collection_type", value)

    @property
    @pulumi.getter(name="itemType")
    def item_type(self) -> Optional[pulumi.Input[str]]:
        """
        Item type tells the UI how to present the parameter's value (or, for arrays and maps, values). Default is `string`. Examples of other types which may be supported in the future are `boolean` or `number`. Even if the itemType is not `string`, the parameter value from the Application spec will be sent to the plugin as a string. It's up to the plugin to do the appropriate conversion.
        """
        return pulumi.get(self, "item_type")

    @item_type.setter
    def item_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "item_type", value)

    @property
    @pulumi.getter
    def map(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        This field communicates the parameter's default value to the UI if the parameter is a `map`.
        """
        return pulumi.get(self, "map")

    @map.setter
    def map(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "map", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Parameter name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def required(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether the Parameter is required or not. If this field is set to true, the UI will indicate to the user that they must set the value. Default to false.
        """
        return pulumi.get(self, "required")

    @required.setter
    def required(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "required", value)

    @property
    @pulumi.getter
    def string(self) -> Optional[pulumi.Input[str]]:
        """
        This field communicates the parameter's default value to the UI if the parameter is a `string`.
        """
        return pulumi.get(self, "string")

    @string.setter
    def string(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "string", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        """
        Title and description of the parameter
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter
    def tooltip(self) -> Optional[pulumi.Input[str]]:
        """
        Tooltip of the Parameter, will be shown when hovering over the title
        """
        return pulumi.get(self, "tooltip")

    @tooltip.setter
    def tooltip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tooltip", value)


