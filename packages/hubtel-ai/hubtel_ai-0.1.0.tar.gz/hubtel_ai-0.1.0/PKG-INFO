Metadata-Version: 2.1
Name: hubtel-ai
Version: 0.1.0
Summary: Hubtel AI is a CLI tool for managing your Hubtel AI deployment projects.
Author: Ing Michael Kofi Armah
Author-email: mikeyarmah@gmail.com
Requires-Python: >=3.11,<4.0
Classifier: Programming Language :: Python :: 3
Classifier: Programming Language :: Python :: 3.11
Classifier: Programming Language :: Python :: 3.12
Requires-Dist: cookiecutter (>=2.5.0,<3.0.0)
Requires-Dist: rich (>=13.7.0,<14.0.0)
Requires-Dist: tomli (>=2.0.1,<3.0.0)
Description-Content-Type: text/markdown

# Introduction 
## [AWS Serverless Application Model (SAM)](https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/sam-specification.html)



## Docker

Let's dive deeper into the concept of multi-stage builds in Docker, especially focusing on how it's beneficial for creating optimized Docker images, such as for AWS Lambda functions.

### The Basics of Multi-Stage Builds

Multi-stage builds in Docker are designed to optimize the process of building Docker images, especially for applications that require a compilation or build step. Here's a step-by-step explanation of how it works:

1. **Multiple FROM Statements**: A typical Dockerfile starts with a `FROM` instruction to specify the base image. In multi-stage builds, you can use multiple `FROM` instructions. Each `FROM` instruction begins a new stage of the build.

2. **Build Stage**: In the initial stages, you might use a larger image with all the necessary tools and dependencies to compile or build your application. This stage is where you perform actions like downloading dependencies, compiling code, running tests, etc.

3. **Runtime Stage**: After the build stage, you start a new stage with a lighter base image, often just containing the runtime environment necessary to run your application (like a slimmed-down version of a Python or Node.js image).

4. **Copying Artifacts**: You then copy only the necessary artifacts (like compiled binaries, specific libraries, or other required files) from the build stage to the runtime stage. This step is crucial as it allows you to include only what your application needs to run, excluding all the build-time tools and dependencies.

5. **Resulting Image**: The final image that comes out of the last stage is much smaller than it would be if it contained all the build tools and intermediate artifacts. This image is what you deploy.

### Example with More Details

Letâ€™s expand on the previous Python Lambda function example with more details:

```Dockerfile
# Stage 1: Build stage
FROM python:3.11 AS build-stage
WORKDIR /build
COPY requirements.txt .
RUN pip install --target=/build/python/lib/python3.11/site-packages -r requirements.txt

# Stage 2: Runtime stage
FROM public.ecr.aws/lambda/python:3.11 AS runtime-stage
COPY --from=build-stage /build/python /var/runtime
COPY src/ /var/task/
CMD ["app.handler"]
```

#### Explanation

- **Build Stage**: 
    - We start with a full Python image (`python:3.11`) because it contains all the necessary tools for compiling Python packages.
    - The dependencies are defined in `requirements.txt` and are installed in a custom directory (`/build/python/lib/python3.11/site-packages`).

- **Runtime Stage**: 
    - We then switch to a lighter base image specifically provided by AWS for Python Lambda (`public.ecr.aws/lambda/python:3.11`).
    - We copy only the installed packages from the build stage. No build tools or source code are copied, just the compiled packages.
    - The application source code is located in the `src/` directory and is copied directly into the runtime stage.

### Benefits in a Lambda Context

In the context of AWS Lambda:
- **Reduced Size**: The final Docker image is smaller, which translates to quicker upload times, faster Lambda deployment, and potentially reduced cold start times.
- **Security**: Minimizing the contents of the image reduces the potential attack surface as there are fewer components that could contain vulnerabilities.
- **Clean Environment**: The runtime environment contains only what is necessary for running the application, making it easier to manage and understand.

### Conclusion

Multi-stage builds are particularly useful when you need to compile or process code and then run it in a different, usually leaner, environment. This technique aligns well with best practices in Docker image creation, ensuring efficient, secure, and maintainable container images.
