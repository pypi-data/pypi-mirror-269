#   ____       _    _                                     
#  |  _ \  ___| | _(_)_ __ ___   ___    Copyright  | Title   : Hapyscript
#  | | | |/ _ \ |/ / | '_ ` _ \ / _ \   (c) 2020   | Project : -
#  | |_| |  __/   <| | | | | | | (_) |   Dekimo    | Authors : MVR
#  |____/ \___|_|\_\_|_| |_| |_|\___/   Products   | Created : 15/5/2020
#__________________________________________________|_________________________________________________________

import os, traceback, logging, time, re, sys, datetime, threading, inspect, traceback
import wx
import wx.aui
from wx.lib import plot as wxplot
from wx.lib.embeddedimage import PyEmbeddedImage
import wx.py as py
from enum import Enum, IntEnum
import yaml
import queue
import configparser 
import importlib.util

#try:
#    from agw import aui
#except ImportError: # if it's not there locally, try the wxPython lib.
#    import wx.lib.agw.aui as aui
imglib_breakpoint_grey = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAARnQU1B'
    b'AACxjwv8YQUAAAAJcEhZcwAADsIAAA7CARUoSoAAAAGaSURBVFhH7ZRbbsMgEEVxJC/BC8qi'
    b'8ue9+SfLyX8efrUXeSgMMwOhlfrRHgkxCRzPhVhx//w23TF7xnHc53n29b7vfuYMw+Aul0vi'
    b'ES3+6Zjd9Xrd7/e7W5bF4SEY67r6ge+ovt1uh5Gi+fhs+SEAgeQYp9PXUteJBxZ5108CSDIH'
    b'6xo1zbkfdkoyh8sxrX6yW5K3bfOz1ZxoCR8M6arQHN+jxkCt/Z6aT7Xmi5GxGZCAz9bpOLFP'
    b'zTXffCqlfad5TE34bIWujZpz6HQa3OfNuR9WsUC/eUvzVj+JJ8n8RbIoNTcDaM3xHclWA80H'
    b'lh8C4P/6+Xz6gf90DNSv18s9Ho9QY5bQfMyWn70DGJQY0CkArUlofrxf8pN3ANAG7apLcL/0'
    b'nCRATXN+gpgWP7sBLscC6tKJSs35ehKg1LxEi5/dAEECHhrXtUjNJV8MIAktzWvCZwF+sjlh'
    b'+UmAUlpAeyRqmnM/uwFLQG2FA6XwfD0JUGpeosUPAc7nc2KTgIfGdd/3vuZoPrD8NPIn0zTJ'
    b'UQ94I853/b+Gcx8dj9/qrpRBkAAAAABJRU5ErkJggg==')
imglib_breakpoint_red = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAARnQU1B'
    b'AACxjwv8YQUAAAAJcEhZcwAADsIAAA7CARUoSoAAAAHoSURBVFhH3ZfPSsNAEIc37aG+ghT0'
    b'iQTBB/CN9K7PIAgefBqPBU/FSi+mm8b80p1tZnb2Txeh4Ach03S/zC+TPbSNqaDve1cdaZqq'
    b'W5mZO5+Nswdgc/u4ve/7th3rzoRjBhfLS3P19BDMG6+g1L9+fvS+n8D69b3vtluzH25g25/x'
    b'3LS78cBNqd6tPp3BiflwU37wCvZDcmSfT4Yz44NKcqrPAmiyJDZaUNJc+j5ASXOsiVHrswlo'
    b'MiVONSdqwvsAclQQ0BxX6emwJtYk5lMd84NNCCgtlkLCp9TTSaY+NY8HT0BPdUrzKSXhgwA0'
    b'NjlSQu5iifRlc+n7APTOsDzWnEarUeuzCWgyJaZ3mSLXXPN9AIhac1whGXV8M+k+SPk+wM++'
    b'M9+dHY+13Y3Hxlqz7TrzNZyp3gzXNWI+zin/uAeGHxnWHUiMA+Dz8BPE19bVkph/OMd9tgcA'
    b'iXyc+tg1pH9oEPdZAL05h9ZolISXfjAB2XwqoE6FA7nw8nsWINc8R40fTIAgATed1qVozTVf'
    b'DaAJNc1LwgcB/rI5kfJZgFxaQGs0SppLP5hASkCdCgdy4eX3LECueY4a3wdY3t0wmwTcdFrP'
    b'F4uxlsR8kPJ55IHVy5se1YFGqT+nJb4rR4IAJfyjf8fG/AKtoHDgD8UI9QAAAABJRU5ErkJg'
    b'gg==')
imglib_charts = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAAAAXNSR0IArs4c6QAAAARnQU1B'
    b'AACxjwv8YQUAAAMAUExURQAAAAICAgMDAwQEBAUFBQYGBgcHBwkJCQ0NDRAQEBERERMTExQU'
    b'FBUVFRYWFhcXFxgYGBkZGRoaGhwcHCIiIiYmJjY2Njw8PEREREtLS1FRUXp6ent7ewln7gln'
    b'7wto7gto7wxo7hNj5R907xpx8B908CJ28CR38CV48Cl68Eh64DmE8UqO8lCT81WW812b9F+c'
    b'82Od82Gd9GWf9Gag9Gih9G6l9XOo9Xir9Xyu9oU3fp4tZ7IlVbIlVrImVbInVrInV7IoV7Mp'
    b'WLMqWbQtW7YyX7g4Zbk9Z7tAarxDbL1Fbr5Kcb9Mc8Vbf5pRi8hkhsloicpqi8xvkNB8nY2N'
    b'jY6Ojo+Pj5iYmJ6enqCgoLW1tb6+vo249r6r0J3B+Z/E+KDE+KTH+KnJ+LfS+bzV+b7X+tGA'
    b'nNSGoNSHodWLpNeQqNqYr9KXst2hteKwweOyw+W3x+a7yue8z9HR0dLS0sHY+sPa+sbb+sjd'
    b'+8re+sre+87g+9Tk++zL1+3M1+3P2e7S2+/T3fDW3wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA'
    b'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA'
    b'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA'
    b'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA'
    b'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA'
    b'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA'
    b'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA'
    b'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAF2/0aAAAAEAdFJOU///////////////////'
    b'////////////////////////////////////////////////////////////////////////'
    b'////////////////////////////////////////////////////////////////////////'
    b'////////////////////////////////////////////////////////////////////////'
    b'////////////////////////////////////////////////////////////////////////'
    b'/////////////////////////////////wBT9wclAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAA'
    b'GHRFWHRTb2Z0d2FyZQBwYWludC5uZXQgNC4wLjlsM35OAAABe0lEQVQ4T62OZ1MCMRCGY++K'
    b'Agrqxa6gYMGCJYqeYsNeqPaOCnbs9Y+vySXHKHPgF5+Z231355nNIfBDShAUV4moDVpDeSJq'
    b'g3y5phuRNUGg94qozX8IJX8IurQkQszZskFbkicO+xowbt6jSVMYaMTY4rxXspZwh1v6n0TW'
    b'FGy1LyJRkDk7UXiQ2kVioEB+omCXnkViJDxxBfCM7WJQ+C0skRNox/EfZPwUPqbJxMimZBMj'
    b'BwULVCEiy2df40P1MTFzUHmmEJbJ1BvAOVngo4r6BD2/yHrXIImyHkcIEXnsTJlrWt1uJQCE'
    b'XUe0coGfp/Ti/Qsyz9Knh3hYV4RLfh62OuraAFYIPXY6OhZWdsiYTi+8A2w7mjDG1gO6m5Sj'
    b'c2SW7hQhVOiFx24LxpK1Z5fvroeJ65hH8UQntjh2xIKxOvMqkvqTKUgp3NKPCpXeZJhyq6lQ'
    b'YWDo01jNKaJFl8ViRqnBkI/K/IgfA9CxYg7QEixn0RgC8K0DfAPuyCFCkk3CEgAAAABJRU5E'
    b'rkJggg==')
imglib_controls = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAARnQU1B'
    b'AACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAbuSURBVFhHxZd5UNNHFMe/CUm5E6wE'
    b'QUUQEYQIaBHvcxSh2tbWtqNOq3bsjB3baacdteqMR9UetLWOoqA4Wu14Me1Qj1HrgYJKq6io'
    b'aAmI1iJXIOEIJEhIAum+zS9BSGj/kn5mNtl9+97b99vj7e8HmUy+TiqVmgBYe7PQmDS2iCrf'
    b'pvwgDQgIYPLeQ6PRYNXq5WYRILIeOpgJDw8Poat3MBqNeHfhfEiENjL2pKOivFxoOTNm7DiM'
    b'ih+N9F2psHbQLDojEovw4bJPcKvgBvKvXxOkzgQPGoTFi5bwuiOAe/cKsf6j/ggL9hYknZy7'
    b'Wot8VQnCBg+BpbUcqRtGCj1d+WTjHTQ01KP0QQmSJ7QjaVI/oaeTxxUt2JRWKLSeCYCYMMof'
    b'ccPkQquTqtpWFoCtLvORInlKoK3RDeqzMzxC5lKvsKSJ/Vajo6Od/Vsh5tL/Ab2+hf93mYE9'
    b'Rx8jUOG8GW//2ch+Q3hdrTVi885iXu8O9dk5dUmNak1n204N17GiuVnP245TkJt7CdXqKi50'
    b'RWxMHIYOjcCx41ls+joEaVfEYjHeeP1NPHxYinv3O9e5OzJfOZTKWKxbv6ozgN48hhUVVTAY'
    b'9DyALktA5P1+FXlXL0PXpENgYBBmzkxGdJRS6LXR3NyM06dPokj1J28ro4dj9uzXWFaV8bYd'
    b'VXERzp8/i5oaNfzkfpg0aQpiYkbAZKLEa8OxCa1WK3bs3IYTmbswN8YIbXUZXovUYUvKBpw6'
    b'dVLQYuusVmPFyk8h1l5HZJ8mXqhOMhrIDtmQLfkgX+TzOPOdlr6dj2XHEcAV9tSPVfkwGC1Y'
    b'NCMER1aPwZTYALhLxTjx6yE8eVLG9SgR9XFvg6+XBF8vjuGF6iRLS0/lOqRLNmRLPsgX+STf'
    b'mvIi3LlbwPUIxxJcvpyDtQuikBwfiKA+HpApFfDxlODG9hn49pcS5OVdgbu7B9QVj6DKSIKE'
    b'ZT2Zl+3cp7wXAwvLjtEfnGOzUMN1500eiFVvD0NIgBcMrRZ4e7jhFvN1tqAGW367ieHKGG7r'
    b'mAGtVoMPUgvwoFKPqrpWhC05AxHbopmXy7H79F/Q1mnRqGuAzmDC1M9zofBzx8YjRbxQnWTU'
    b'RzqkSzZkSz7IF/kk3zRGY2ODMOozAdCG2/tZAhJHsvRJZ0OQr2ZPseyVIQjsFwj/vv6Qe7+A'
    b'2zsTbZeqHVYnGfWRDumSDdkS3Bf7Id97Px2FvkzHjiOA6dMT8fVRFbRNbWy6JFg4nSUe5vjO'
    b'Yx2O5FZh8pRpUCgCEBquxNqf7nObhIgXeSFIRn2kM3nyVBxmNrf/0nEf5It8apjvrzKLMTph'
    b'LLch3FhoX8yd+xZCQwejoqYBm/ZmQ+ImRkyoHAcvPsHHuwvxzsKliI2N4wa0dmmHzyG74AnC'
    b'+/ugzdyBNQfu42KxBStXrIGXlxd8fWXw8fXD8q2/QtdixujIF3Hxrgbvb7uJ4PB4dhynob29'
    b'HTk52c6J6O7dO7iax/JAYyOC+g9A4oyZCAkJ5X126C6/cOEciopsM6FkQSUmJnVJZnV19Sgp'
    b'KUb+jWusruVBjRwRj4gI27KYTG2uM6Fer+dJyE6AQgGLpR1ZWT+jvr4OSUmzEB3dNTE9C51x'
    b'rbaO+TEIEtfYA3DKhKk7tkL1qAxu7p4wtzRjzuxZqKysQHDtI8xVyLExZRO+25oGf//OjWSH'
    b'7ojaWg2ePm0VJP+NUwAWiwWjl36P4DGzUHj0G9auQmlpCfZOjYDSzxtZZRqUl5ehuroKN2/l'
    b'c5uEUWMQFRXNckAtezIzl9m5kH0WLS0GuLm5seVMZjPtKfTYcJwCV9B00kah3L80rxgfXXsA'
    b'ldGK8PAIXM//A62tT3nJZUmssrLaaXCakdzcbIwdm8D3SyPbV93pMQDV8R0oOZWBsLBw7MnY'
    b'D+WcBdBEj8fmL79zXDoeHu68mNpMPV7RhI+vL5sB10P1GEDfofEIGfcqPwE0YNLMlzF//jsI'
    b'Cgri/VHshtRqWdZjJTLStrO7I2JpcNy4iThz+iwGDw6HnN2I3ekxgH7K8fDyHyC0OqHzq2G7'
    b'3Mdbhri4kbwMGDhI6O0KBRDLrl/SGRH3Ejw9nd85/nUPPAvtB52uiW3ASujZ69SlnAu4mLmP'
    b'lxxWdwUtS8aeNBQdO4BD+3fxi6o7LgMw6jQw1PwNUwu9wVJuMLC3mEqWBxoca03fBvMG+PDS'
    b'03eCDSsyRigQ4M6SrgucAujHLpLSX1KQuzYZ6j+ymETEPqO0MJstNgUBuZ8f0tUWXqjuCloC'
    b'ungm3tShUeLVJVPaccqE9ITNLBs26Zp5Tnhe2DOhWCqVoK3NyPJ7G3vSOvY2U4H6uobnOjhB'
    b'74Xswxgib2+ffWywJdToTcxmEyQS6Y//AOtoH1MQoa1kAAAAAElFTkSuQmCC')
imglib_controls2 = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAARnQU1B'
    b'AACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAnBSURBVFhHxVdbb1xXFf7ObW62xx57'
    b'PLbHjuNbWrvElCQlidMYqUkDKbShICGkhqYJBCFViIcGCcED4gUkCC0vESpCAsQLSamQQBjU'
    b'hNy4xLlQQrmERk5i10mIY3s89ozncs6cC9/aZ5zAL2CPzsw5+6y9Lt9a69t7tCAI8P8c2sGX'
    b'v0kXfN6ZQOAhYpgwIwnO8JnTgR7A0ICa7yGQGwTgFLRAh6Zp8LwaXNfmdE0pVAFxnl/1S1as'
    b'fdOS70PXZG2AfO4+tJe/8noQtSwElI1VlmC5FdSa2lBBAqYy4iEaN+FTacmmIXDO5yXvRC8V'
    b'hcp9pVQZ41dAI3Kv15913kQiOh324TiB0nv/3gz0d/9xicIBrMCHMXUZ1UsTSJTzSrnHUD3D'
    b'xWB/FhsfHaAM0ZA3lNcUDDSqrImp+o9EolZrjFTeKgkkIhY2b3wM2UyGy2RG9FDGdUrKG98u'
    b'4PE2DU9vSCFiryplPj+uV0FvdwaDfb1wHVst1jlvVwuo2kVU+GvXSlRGHYGLanWV86uoVIqU'
    b'KdOQB9d36IyD0ZF+tLUkqJNIClqSDoZJGR9vXz6H1dxttDRoOHN6AsViHl7NxuT5c7DLBViM'
    b'9vSpCRoso1xexTnK/O43b+DUb4/jwvm34NZqWFlZwqm3foGTEz/HyV+fwJWL51lWHvKLc5j8'
    b'42k0xi3MzlzH3965rDDSdUNQMlSCam6V8HkKFrtW5Yuw+Fy7Qmc9Fp6Lml1iEbEYeXmM1Kss'
    b'w3CKMOwy30vOWbVENHBWoLkFQugyQuLlObCJiujzaw6cWkXZYQKYAjio8eMScwJBGMNK9VkT'
    b'nhjjs8aC4gpe4QiYZ8c0Yfd0w85k4TEIQ2qI6y2vio3REtYZVRjSHRw65TW5aDQ0zLoQO7x0'
    b'XVcNpyZtdkONbcjJ+qXBMAwlLPcypHx8ylTjcQx9+lPoee5ZlCMGfJ0oUUczQ/rS2CA+OpRB'
    b'1JfWpB7fpINiRexIDYWBKr1Eml6H6P91fgW/n7mHss/+dl0l4LoOzp47g19N/JLPnlIQsB5c'
    b'doETj8KJRuBQoytaOaKMtI1oxFiUYNpUHxjs+eUcTpz4Gf557e+UkjCYMiJbrwGNEURwZs7D'
    b'T/5VQE5rZNGRkCRnzOPxN07gBz86xjTVGAn7WTpBwSqR01nC6rFB2Qfw6KRF5yzO6YHD/Nus'
    b'GRfzuXm8+r1X8acLLEwGIFjE4y2CGiFmNfqEyEEDKnojalpITNIkAROkmwmmoIH3UeW1vBPk'
    b'dIUIoa8Tk8Ql3OGSOwgiL+qmI6GTTEMsyee40kmFMJhyo3fD6DeyPQNUROjSHUh3ZNHZmUUL'
    b'70XANC20tXaivXMdMl3r0cp5aIQ9EUXk0T7E/QgyJa5NtlHWRNJ0sKWphqKVxErzAKLpHhql'
    b'6/EEMh296OjsRTrTjWQyBdtxoO185oXgie1PsW2EsyQe5k1IginxGarJfEp3kfoUZUhHCBWv'
    b'RFxcXL6LBjqztakLpqtqG43lu+j5y5sot3UiP7gLq/E2rmcqCI/GYtRZV9IJgnpxtchnKvf4'
    b'1idEASHTYbEkYgpS9gBVMh0GL12qmPWi0hIg4gBdKz4yZSpk/yraZuE5ZiNuJkdxt+ER2HoM'
    b'Ot+xSVlPTIEhGRf4FQEph6XReCNB8ls5J0ZlThzglHyJx/Irz4zAp0SUcqPd/RhKdzEKijAS'
    b'Qc6L0OjIGHM7CkjthGa4kM77olvahXPUo1SP7z0QbNk2TjhsuFWyIZUI9Io06kNuZcHawrWx'
    b'JqO2WOENPnukXplXTinj8hFZQS7UG4lEkUjEaJOMuXPvi8GWrTuxQA5YmLuHYmGBQqzsOvHI'
    b'oGp+PzQsQ2wrpTROvlRVbbGTAqZO2lInCYl5WScf9gVspqO5OY1sZx/S7RmsigPjH3kx2CwO'
    b'LOZx8/o1NCV8rCzNYWFh/kG0YTLEBnmd9Gwyj/FEAtFoVM2XuV+UBD0SH7PNtqNz5AxJi+Ag'
    b'tL5+sB8u01a1TQwPP4HW9k6USgU68OH9waat41jMLdOBd7jJ5Ln7FbnjcVNZc4ApkfumZBM2'
    b'b9qMsbHt6Fm3DrFYDJZlolAo4s7du7g0eQVXr76NpeIizbLYJJVcL2tbW1sVEtGGdgwNfxCp'
    b'9g6UaIenI+H8h9f8/TlCU1SGH44Ao6MbcfToUbx08CWM7djBrXeZ07JZ+VjOF/Dk2Dg+88J+'
    b'vPbt7+B973+MKyR2Rq/6T6NMHstL4UEnzF+oV5JLqCgqaNFT1eciIMvVL7B3714cOXIE2WwW'
    b'i4uMjtMjwyPo7e1Hd/c6DI88wnYrobI0i2TMx9e//DU898yzypBsZqJHLkEiLMlwiHYpXDFV'
    b'f5QrHBKZeL97924cPHQIXV1duDF1gynYhGRjEqlUCobJDmdPZ1JN6AgKaF2awnu3p5Eikx44'
    b'dAB79jzN/IdBPTCrbsInh0xInnDVQzgpvSzeitcG1vf24fOHv0D4VjAzM4vHP7CJZwwfldUS'
    b'qsUKKiUH1XIF0fs3cfvkcWRaM9jxod2YunWLJ6pVHD78WQyy+IQfFAmtoVt3oiYHGbn9r8A5'
    b'QiTk9Pr8J57H0lIODQ0NGBgYkILhtrqCG9Pv4fr0NK6/ew1zfz6DmYmfopxfRjUziIrrYcOQ'
    b'GAXm5+exb98+xQ3CFTL3v7akw6RIxKM61YWCmqrase1jzHOv2pAsbkwiGGHrJVPNmJm9iR8e'
    b'+xZe//5ruDKbQ9Pok6il0qRaC1HSdlNjI6MfwLZtW5FOp5VuGYLCmhMaC091gYKcuZRfyVmN'
    b'B8wNQ0OqaCYvTHLnapL6lCVoSbWgpTmBs2/+GB/L6ti1oQt/mJpDdHgrHWsn/dJR3UKMJ6bJ'
    b'yYvKkDji11EQnaoz5J6coo3v2c/dcBfmWd3TU1fR35PGv+/cUfBJockW69VYJ6qYQmp1eMiw'
    b'eIJ+ZXyQZwUT3z07haB1PXRSrDCeGDEpa7EDxGiOaRySFBKZuVwJg+SBtkwHFu5PCxPuD7aM'
    b'0YGFHG7fvIZl/l0SI5I3GayfB7wuOZSNSHa+COm6L2oTMRezdoynpZhgquTFAZGkqCxUjlss'
    b'woAUmeQ23TMwgvaOTizO3YK26+OfCzZu2oFcroBKkUdpoU/yudCnyZSEWmSEzSoOuPyIJTlm'
    b'e8L5slVzjTggzgYCMYcEIquk0tfuZSuOJ5OssRY6MAPti189FlhR+bciEdeFyOi8VcwYRsMh'
    b'kfAjz2suyT8nJSfycghVMpyqO7A2wjkpOBGoCzGA+Xuz0D65/5W6DSrmZKIxRY7n2Y2TUqBi'
    b'Tr2WhTLquvm/njhw13R5/MrluJanaHlJMVkrDCgjXCsOhKcMhYegxbt8cRH/ATrMs8B7yuZ8'
    b'AAAAAElFTkSuQmCC')
imglib_cross_grey = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAARnQU1B'
    b'AACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAa5SURBVFhHnZd7SNZnFMcf39e0N0q7'
    b'mN2sJBXJYmlY015yZlmyv2bBsPVPjLFg3aDVNizaXyP2z8AIzHD0R1D99ZJEYdm6SFbQxSUZ'
    b'vZJZll3MortlXnY+T57fnvdd1LYDh+d2nnO+5/I8v+cXY/4Dbdu2LfnOnTuFr169+mRgYCBp'
    b'yJAhWcz39fV1vH79ujUQCDRNmzbt5ObNmzvthn9BHwVQUVER19ra+vnLly+/FUPFQ4cOjU1I'
    b'SDDDhg0z8fHxJiYmxnR3dxtZN52dnfR7fT5fnaztyszMPCxgegZVvZc+CGD9+vXBFy9e/Ob3'
    b'++dOmDDBTJw40YwaNcrExsZaw2LIMn2RsXsePXpkWlpaTDgcZhgWIN8tWbLkxIoVKwasQBS9'
    b'F8CePXsCZ8+eLX/z5s2mSZMmxaemphrx3K65Rt02monK+fPnzdWrV4nUjmAw+MO6deu6rRKH'
    b'/gFg69atgcePH4ck3CUZGRlm5MiRnofRXrut9mGNENzR0WGOHDli3r59W5uUlLS0uro6AoRv'
    b'sLW0d+/ewJMnT0L9/f0l06dPN1JUpre3lyLzmLEos62uuX3Z660zJnXLli1DV8nDhw9DVVVV'
    b'gUFzlt4lbpAkxz/Lxq/T09ONVLidk2qPYCW3r8QcALSvMqRv8uTJ5tq1a+nXr19P3LJlS20o'
    b'FLJrHoANGzYE5XhViWBsXFyc3UwIaSV0ZsqUKUY8iFCsxFgNQxhjTo6mHbPGiRk7dqxpbm6e'
    b'e/PmzXpp21izANauXeuTcB2Q45UyYsQIpjxDGC8uLrZKCemDBw+8NVdOOS0tzcyYMcMa6+rq'
    b'MuKU5wi6Gd+/fz9P0rLr9OnTfbYGpNo/k9DnDB8+3MsfqEePHm0WL17snfdZs2YZakPzjqwr'
    b'T9GyTkFSP7m5ucbVyT7mpM1sa2tbjm0LQPK9iTyBEkWqHACkA+Mo5SRkZ2dbD1VOWS4dk5WV'
    b'FXEC2MulhSzGYWoLWSn2lbt37/b55bIJSASqBanY8HmhhCRUdhPh12MGiHHjxlmjrCM7c+ZM'
    b'C0yNQxi9cuWKkaKzfVcvEZW1VHGy0i8XxBc9PT1lXK2ukPYxggKOk952gBk/frwFkZycbMOq'
    b'9wR7iN7ly5epeisfrRNbUoTobfHn5OR8JWsFhCZaEMI4lwljuRU9EBhLSUmxDCAIGUA1NjZa'
    b'AxD7IVc3hGPCzf7Zs2d/KQpyXSVK7iZAoAyDGEdeWWVYv3DhgmlqavLmdD4aCB8uifyATwol'
    b'i0UtJi0WOHru3Llzpr6+3lOipIbk+2G9d/e6+7VPiog4R9LHRiZdEMrMucrYiDwR0GKDNPcQ'
    b'MsiqUWXVBatu2C/V+6l0ctULZRZVKUR/3rx5ZsGCBR6AaBDUCABIl0vRuqDbt2+TgnafbOxC'
    b'QL10UcMohDFeVFTk5dzdo6ApUDlVRuoK5V40kFXPleWdYZ49e9bgk1z86Rp0hWDm5s+fbxYt'
    b'WmQNKACUHzt2zDJyEFFAJi8vz8yZM8fOqwOqCzCM+a6MGTPmhl+u1zaZ/FEWbT0oaX/hwoVG'
    b'XjTeOYdRUFdXZ86cOWPa29utYh4tekQByWnBqLwh7Rz6MA4/ffrUyFXM/fG9/9KlS70SsnxR'
    b'ksGiS4S9tLTU8xrCOA8M+ZBYwxBGMAYIAEK03KC8jO7du+elCeJ2lBQ1Sv39ajXLzbSL1g0X'
    b'jKDc2d5G5g4dOmSOHz9u5QDMHPk+deqUlw71lmOm4GAAA4gClC9jhTwB+i0A+Yodlq9XGE8R'
    b'QhgD8t0227dvN/JEs/MHDx70jKuMhpV1QBw9etQCwPj+/fttitQ4rbywSVVYHj/7sO2dozVr'
    b'1hTJi/YPvEEBYAgjLaHklUTYGbtrtLAWKEwR3r1717LOQ1Q+t+TUqVNL5fl3gDkvufn5+Sfk'
    b'RPzCBg0tqOFbt25Zz9ULdw1WeWWKkz0qj1OEnheypHuHnKiaQbORr+KdO3cGGhoaQiJcQngh'
    b'11O3ytUzXVcvVc6dRxf/CjJXK6+rpeXl5d7LOAIAtHr1avsylvecBwKKNqZ9d07HygDBc6Ih'
    b'/drExMSlNTU1Ec/ydy45JD8TvQIiJF+rBHmoZEs9xKKMuoAh7RN67Ssr0eeLxxEk7AUFBd9I'
    b'hD/+Y+JSWVlZUBT9Lv99mYxRipdQtNfaAor/RApOaiosD5afCgsLa1atWvU3Ooc+CACSn8s4'
    b'8WK5HMWVUlCFFBWGool5TZkc6UbxukKM76usrPz/P6cuyf+iT8502sWLF3MkNTliJCitjQpv'
    b'vOfPnzdIjm/IcT0pd3zrxo0bI6/V95IxfwFU0LrnixUFSQAAAABJRU5ErkJggg==')
imglib_cross_red = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAARnQU1B'
    b'AACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAApESURBVFhHnVcLcFTVGf7uY/fuzSZZ'
    b'QhJSaCQJBEFQIfUFpQr1UTLaKCAqKLVWO3WkrbbTsXVap3TGaS0dp9XK2KnaFl/EZ4SqlKm1'
    b'Ila0HTEIRcybCAFCHkt2s7t377Pff3eLMDoy7Q9n796z5/z/97++c6Lgf5Btd3x/0lB/z2Ij'
    b'mTwbPqqCWMls3ffgefZALm/3eGUTd1eecfq2JQ/cf7S45ZRySgDb714bddp3X+6lh77l+e5l'
    b'ZiyqJ0qroJWVQTUNatBgZy24qWMYOnoI4/msG4H2qlOaeFibf9aWFb9abxdVfap8JoAty5Yv'
    b'1EdGfl0WuOfHGupRM6Ue8coqIKIDGrdyKCqfMrQIfIJJDY3iwL73Mfz+bmR0vcMpS6yZu+yq'
    b'1+d99/agqPYk+VQA7zz4G3P85Vd/HE0fu7Nq6mnG5MZGBHGTq1WoqgpFidCohkAAKAqfGl/5'
    b'G38P9MJzPJ9Dz5vvYP+e95Apr1zfdOElPzx33c9yRRPH5RMANq25xTT7B9sqMtnmybNnIT6x'
    b'HIGqM9JiVCkAUKOcKwAIjdK4RKIAhgB0DU6E8/wtuf8j7Nz8MrIetmamT1n+nRdfOgmEWnyG'
    b'sue3D5kV+4faJlhjzbVnnwnDjCNwfChOgMD14HssOMeFb9ucl+FwXp758DtcH/B8OFyj52xE'
    b'8w4mTanDohuuR5mpNMe6B9r+dc86hvJj0YrPUJZq2tqYlbq5cdoZTGmUMwH8gJ7yH79A9/jO'
    b'mNFPKAGNwSs++S6fsswnYNjwOCHvKn+PxQzU1E3HwT3tjX3d+xJ33b12659eeYU7TgCwdcU1'
    b'C0tHjv6+YcpUXTNoPAgt0agHq24qgtmz4Q58BM0VODRIQCIK7Qe0FOIoZtQ5cw6BEHA6y7cC'
    b'eI0gKmomYaC9/fzB3s7tLx8Y6JO1IYBXWlaqpbmxTdUlJbVl5WW0zU0EoLDHxxunILF6NYzT'
    b'Z8HmO/b3QmWoPYXfQyD8FDD8b8vLF5pgLJgPTJ0K60g/tLE0jfghyFjFBDipHEYPDsxfufTq'
    b'h9ve2+mFNaBnkosMy25KxEvh2cyr7VGpi/G6ekxYfTM0I8HiAsovXAx/4UVMtQPdcuEy7zJ8'
    b'14VNA/o550GncY0FGoslYF56BXLV1awbG1qe6aLeWQsugGn5M8c69q4S2yGAuO7eGTdY6eIJ'
    b'Qy4K/bwNdXINFKOExl16ocKPKIgvXgSXI0+vFNuHy7UOI6JccB6i8+cjypYUtYrqAqYJZWIl'
    b'C5WFSYdUgo3pEUyaNwPGwKGb9t57n6ptWXqdGR1PP1pjlEhHMVQML+Opsdo8httiqM3G05ks'
    b'lbzDFqMBo7YOmcCD1tMHhYWJRV9CfNFFLFw6wTVSDj7n7X+8iWDnLugu0xm4HKLZQ8ww0bV7'
    b'V/0hTf+d9rU5c5cmxpIrS0uiUBkByZWUrwCJsKWU7l5k2d9m/XQo7G8RSYdRNw15actpdTAv'
    b'uwQRTYyzP2Qv2y/75jaoO96GIS1MJ5RQL4HxozRWgp49u5BW9U7tG3U115fbzkUxMphAl4UC'
    b'RMpa/ukOPerqxLgeoKRhBplO4xohJIJonAFzegN0RYevina2qe1ibPvriGzbTj3MaEB+oB6V'
    b'7VnQWSjckUOHMXL48F7txvrTri13/XOj0kLUwf4popUhWwmCOfS7O5GjUbNxZsh6KgtNE9bj'
    b'U7YqjJZHANm/bQH+vj3cKxGk/1TJjikCEL3SZMNDRzHGPKmIxWfL5oDsxWqCQsZDcfhhhedZ'
    b'9XkYOQda2yYkX3xBUJ0kEnaWGFJ/+TOCv74Bzcmx6rmPBSp6FWFIh/nnEBs+O03qxR7P0gFS'
    b'lkcA7D8usMKBkFptekW1rHSVLeRzo+06ITeE4Wa+/yuSe4UeulLFPIS0PB3iXt+jHlK1Qn3s'
    b'Rc7RIQ6P8/xC/ewX38p84DE0gfQ/jcgIPSff+yymELEoZxtFWq5CxYprSa+SHo6iSJh5XqGy'
    b'uQXukouRZcXr0vfiMQtVPPePR4DzjG4+m0OEJ6zqacawAyEfMUyj9DJg6CQF0rcgCEcismIZ'
    b'Kq5bEebc4Snok4xcgguJiA4oPnufICq+uhRB8xLkXAsKyUoOKYmkUnQuPLRoK5sax/jY6Ftq'
    b'Op7YxYCwgCRsYpwgCMTjQo9ALJV8fu0qVKxaRS9ZqjQeYdokOIee24jhZ1q5jgWokhd4IVF1'
    b'HROXXA6vpQVWQBAkNM8mbdExFkUYEYnuyFAS+PzkXu26qQ19sbzzo1jeUjXJi6S3GGGbKY3e'
    b'cAsqv07jaqSQaw6pheTGxxB7ug3Kvz9EhsksOWMO13CDCLsjNqOBqfBgd3WQ1DgXsiwHv4/y'
    b'+tbbewDVX170A+3Z3k53dV3DAt3OzjAYGmlBnanySaXq8lWoue3W8JZTEDnr8xh5fCOM1mfg'
    b'BnlGI4DT0YkswZfwAuPLhUUOMtaoOWMWnEwGSlc360ZqhWkmE/Z2d+GIorWfOW/hulBzvqLy'
    b'YUszQhLRmDcrsHnYOLB27UY2eZj5lorndob62KNPIHjyMVhMl+IorKk8YpkclNanMdz6XJhC'
    b'usqzQoOVSQH7+pkippVpkNrKZ7PoGxiEWzXhgQX3rWXlUIxz52zJViQ6knGdRpiGPHmcxrQ9'
    b'72D429+DP3go5PbhRx6B98QfCdIKgap2hkGx4TASKsEHrU/h6FMbQ77x0yPI/vJeeB/u5KFF'
    b'UNQbsKW7e3uQikc7EnV1rWL7eDO/1LL8YuNA32uTR4YQ5WKNMfTJeD7vdvacuYg0NSH+5Iuw'
    b'TA9k/fAcDXPOdXIPBNOkI4IsLx56y5VQO/uBnl2I8AKrcJ1KzhvMZ7FjXyfcubOX3f7aG5vE'
    b'bhgBkc81X/p6zqz6+cEJ5aG3ITMSSJSpKHuvHdENG5BT2Ls5tpy0lkRKepvPkDmFL8ia8YyF'
    b'yPPPItj7Lqu4oEf4ZMzO4d0uFmxlzfqzrli5uWj24wiIvP/TdWbfq1vaEqMDzdXJFGLMs8rW'
    b'ctl+Gv3TNDnZGF6dRcZjORz8PYwA2zNgNOhreIMu3JTZlvwpQ4d2HOxDOlq29bwrrlz+xYfu'
    b'P34zPgmAyIZrrjIn9I+06eODzbWjxxAnSWi06vIyIoexdISEVK7o4RWc7FMAUJiXg8ohAEJj'
    b'VnSMuDm0HxlGyizbmq2tWv6Tt/950rW8cMCfIJs+6HDXrLmtbfTISHnaceblNU83WZAREkjY'
    b'yyENs8r4DEheqnSIUDmn5UM4RGNtW/zSmRrF3tEcxqpr1p9z8ZJv3rj5hVP/YXKiPL7g/IXx'
    b'vP8HLZmcmbCzSJDVDBrRaFAKUGjZ50XEY/g1vvt8zzICR3muHGDFZ0rNDtTX3nXWV67efMld'
    b'dwjET8hnAhB5+tbbokpX/ypv8MhNSt5abFppRNl28teCXDg0Xo9cemuR9VKMRkYzYVWUt8fM'
    b'iQ+gobb11uc3/v9/nJ4o/b94UN032De9b8dbTWYq1aSWli50cuR6SUHcQDo99lZQU907edac'
    b'bTONmp556+8RAj6FAP8BsLKYbNfzmUsAAAAASUVORK5CYII=')
imglib_Dash = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAAARnQU1B'
    b'AACxjwv8YQUAAAAJcEhZcwAADsEAAA7BAbiRa+0AAADbSURBVDhP7ZJNagJBEIW/nh9nIkaD'
    b'JJts1CN4AY+ROwRcC66crHKMXMODBLLNNsOAqMg4Q6bLakfFtS7c+JrmNV1Vrx5UGRHhGngH'
    b'vhh3AdhPwRgDs++A7kuPf1pYW0FhMaGlcmMSi++SEJqtFX+dVBJ9nwTe1MloPSHwP8mX+ntm'
    b'TKgwlMpGT0gQf5EtxpL0CxeuM4c/bez2nXIjeL4KaLPj9Yyv/KCtYh6fc5bpnI/BvtihdpD8'
    b'hjxFr2o3hrVWRXXU2a8agkoQNSx5njHtLVzouID3Tby9AOwAV95P2h7OoNYAAAAASUVORK5C'
    b'YII=')
imglib_disable = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAAAAXNSR0IArs4c6QAAAARnQU1B'
    b'AACxjwv8YQUAAAMAUExURQAAAB4eHh8fHyAgICEhISIiIiMjIyUlJSYmJicnJygoKCkpKSoq'
    b'KisrKywsLC0tLS4uLi8vLzAwMDExMTIyMjMzMzQ0NDU1NTY2Njc3Nzg4ODk5OTo6Ojs7Ozw8'
    b'PD09PT4+Pj8/P0BAQEFBQUJCQkNDQ0REREVFRUZGRkdHR0hISElJSUpKSktLS0xMTE1NTU5O'
    b'Tk9PT1BQUFFRUVJSUlNTU1RUVFVVVVZWVldXV1hYWFlZWVpaWltbW1xcXF1dXV5eXl9fX2Bg'
    b'YGFhYWJiYmNjY2RkZGVlZWZmZmdnZ2hoaGlpaWtra2xsbG1tbW5ubm9vb3BwcHFxcXJycnNz'
    b'c3R0dHV1dXZ2dnd3d3h4eHl5eXp6ent7e3x8fH19fX5+fn9/f4CAgIGBgYKCgoODg4SEhIWF'
    b'hYaGhoeHh4iIiImJiYqKiouLi4yMjI2NjY6Ojo+Pj5CQkJGRkZKSkpOTk5SUlJWVlZaWlpeX'
    b'l5iYmJmZmZqampubm5ycnJ2dnZ6enp+fn6CgoKGhoaKioqOjo6SkpKWlpaampqenp6ioqKmp'
    b'qaqqqqurq6ysrK2tra6urq+vr7GxsbKysrOzs7S0tLW1tba2tre3t7i4uLm5ubq6uru7u8DA'
    b'wMLCwsPDw8TExMXFxcbGxsfHx8jIyMnJyc3Nzc7OztDQ0NHR0dTU1NXV1dbW1tfX19jY2NnZ'
    b'2dra2tvb29zc3N7e3t/f3+Dg4OHh4eXl5ebm5ufn5+jo6Ovr6+zs7O3t7e7u7vDw8PHx8fLy'
    b'8vPz8/T09PX19fb29vf39/j4+Pn5+fr6+vv7+/z8/P39/f7+/v///wAAAAAAAAAAAAAAAAAA'
    b'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA'
    b'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA'
    b'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPsuZpsAAAEAdFJOU///////////////////'
    b'////////////////////////////////////////////////////////////////////////'
    b'////////////////////////////////////////////////////////////////////////'
    b'////////////////////////////////////////////////////////////////////////'
    b'////////////////////////////////////////////////////////////////////////'
    b'/////////////////////////////////wBT9wclAAAACXBIWXMAAA7AAAAOwAFq1okJAAAD'
    b'N0lEQVQ4T13SeVcSURiAcS1LJHFJQwEdFkVRQCQXMEPJpSLDXEBASTOXzK1QTAWCDFNccE1L'
    b'sz0rNa20TU3JRCvtfqbpMkwe6/mDw7zvb2bOmXM90H0Nduh1Bht+gfcP6LcaWk2d+AXeHnj0'
    b'YHSgq7vLajFabfYJfAjbA7Zhe29Pb1/3LaPBYG7FhzAcTPS3mTvh3mY1t+sba6va+t3zPWDq'
    b'aNEbLZabbXpdw9UK7cXKSvccB+Nd15v1zbqGK5e1xRq1Rq0sLMivuY3t3aCp/eadob626qKc'
    b'7MwsWcGl67qKYqUC27vApLX46vjcl3dDdTlioSBeojROz401n5eUGHFgasorGV0CP17aSk8J'
    b'uInylqmNrWet2QkZchzoSs7m6qec4Pv7oWqpOK/99Tpw3KtO48Wl1tsxUH5OmqUyv9kAv+ZH'
    b'aistTzbBxowpLzk6IlFdC4GpMUeSIpYordPbwPn51cuPDuB8YVGIeZEM7ukKCKo00oTj8XGp'
    b'qo5ZBwDOLQAcM2ZFCieKGc5O1UKQeyaZz+fF8hPlhsfrYHcXOJ6a8hI5TCZCYSZpIJBlCDmc'
    b'6Cg2K0Hdtwxgaw+bJEwkDKGRkeNFEBTKhOyICBaLJczv/OQC28tjmVQqlUYJDouHH8ujTpsU'
    b'xUDokdzM+snV387NXbAzWy+JolLIgZS4QghQVMal0+gxkuqna79/vF1wAvBt3pYRHhpEIvMK'
    b'MKBIYoTSReV3v4KtxWH769UdABaunaT7E4P5rlegqCYrIoQph8/fmR/U5jfeX4fPmL4hIHoH'
    b'C9UYsBTHUhnKBfDzw0BZMlda+3xle/uTPeHw4dD0yxhAUSmTemEJfBhWxdNp7LSqwcWV2Q6e'
    b'5wFEeQ0HRclI2uh0b5kwJOjoMZZI0zPeWYJ4BcTWjeCgQcNliKWiWFpQYEAgGYlJOSFACCSB'
    b'zLXDwFiLNIbsRyL5weAvyZdw8BCJXvD3wLiqUQnIJALBh0gk+hC8D3l5+guy3RscjBuV4jBy'
    b'gO8RHxjRxz8kWoHdvwdcZYnYlECSr99RMo0vU+HD/cBUKk/jc6I5ovRspQ4eNnf7gKsarQae'
    b'ov39B6x6nRn/i4WifwDXe0qbdTarkAAAAABJRU5ErkJggg==')
imglib_exit = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAARnQU1B'
    b'AACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAFxSURBVFhHY/z//z8DNcCvHkawQX/F'
    b'PBnYvScyMAmrMoIlCACsDqicMIdkVzX+SQXTvz4CHcHIwnCCw53hKKcXw29GNrD4s6dPGBZ2'
    b'N2A4iglKUxUw///DYP19K0P6hzoG9V/nwZY/e/YUKosK8IbAmdMnwXxiwFbDOWAaFALoIPBe'
    b'CpjevXQ2fUKAFDDqgMHtAAXbF1AW7QBeByjavqS5IwhGAa0dQVQaoKUjiE6EtHIEY+sVU5LK'
    b'/fuHxRkeHJaA8hCAbiUhtUOCZAeAADUdwZixS4bkqhcE3l9SZnh7ThXKQ42CnylXGP7zSgMZ'
    b'nxg4pslTvzJCtxwbYPz8FGw5IUCyA4ixnH2ODhgTA/C2Bz5oN4L5MIDPcprnAmJ8Tg4gygG0'
    b'shwECDqAlpaDAF4H0NpyEMDrAFpbDgJEJ0JagVEHjDqA6r1jeFHMxs3AqhvOwGKSxsAsY45R'
    b'BMMA1R3wh9OAgdUklYHVPAunpQjAwAAA0KemZBxeLQcAAAAASUVORK5CYII=')
imglib_idle = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAAAAXNSR0IArs4c6QAAAARnQU1B'
    b'AACxjwv8YQUAAAMAUExURQAAAAEBAQICAgMDAwQEBAUFBQYGBgcHBwgICAoKCgsLCxAQEBER'
    b'ERMTExUVFSEhISIiIiMjIyYmJigoKCkpKSsrKywsLC8vLzQ0NDY2Njc3N0VFRUZGRkpKSkxM'
    b'TE1NTVNTU1RUVFhYWFlZWVtbW1xcXIqKio2NjY6OjpWVlZaWlpeXl56enp+fn6GhoQAAAAAA'
    b'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA'
    b'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA'
    b'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA'
    b'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA'
    b'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA'
    b'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA'
    b'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA'
    b'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA'
    b'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA'
    b'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA'
    b'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA'
    b'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMp0kaQAAAEAdFJOU///////////////////'
    b'////////////////////////////////////////////////////////////////////////'
    b'////////////////////////////////////////////////////////////////////////'
    b'////////////////////////////////////////////////////////////////////////'
    b'////////////////////////////////////////////////////////////////////////'
    b'/////////////////////////////////wBT9wclAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAA'
    b'm0lEQVQ4T+3OyRKCMBBF0TZBDLNgBBzBEYnC//9dNKEXiS5c6JKzSr+6RQHyizEY/D3oRdvh'
    b'E1nBo17zRVnd8dSs4LCMfS/K9nhqZtCvYpdSNywaHBQzENwHhwBLLzgoZtByDyiBWXLCQTGD'
    b'roymZOIE+RUHxfrJKgsZC+ZbPDUrELsiTfLNDU/NCqRszkfz+y9vwacxGPwaSPkEcU6zA7C4'
    b'6CcAAAAASUVORK5CYII=')
imglib_Layout_DD = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAACwAAAAgCAYAAABpRpp6AAAAAXNSR0IArs4c6QAAAARnQU1B'
    b'AACxjwv8YQUAAAAJcEhZcwAADsEAAA7BAbiRa+0AAAmJSURBVFhHrVgLkFPVGf6S3Hvz2iSb'
    b'bPZBdpd9klVUwFlAliI+2rG0RS0j1tFCHRmtAmrpaKm2Yq0zHUXaSq3SsSjVFi12FKuOLW0F'
    b'RHR4KFiBBVzY7DOPTTaPzWazedxH/5PcRR7rBlK/nT/n5pxzz/n2/M8TDb5S3Ky7fknl5GpX'
    b'jZvj+BZJTLtlRWkRRcUyPBRf/7dNT21RJ56Coijq0/mhKMJzrlvsmDFjptto5N06HdfC8Xq3'
    b'LIktUKRmnY43ZkUJ0GmRiMchinJORtOprG8gWLf7zY1+dZkcvjLCzc0L9K1XTWssc1rdAse1'
    b'8HqjW8cJLbKUcRsMpnJ6VZMV04BWB3t5NRJDUYQG+omBhhaVodXI4Im0wPPo8sWg5QWE/N7F'
    b'27dufEPdIoeiCd+89P55la6KRbze0KJIIpHT1fO8nldoiihliRcHQTAjkYjRLlpoiaiUScDM'
    b'Z5EVMjDpyqEXdOA5Hgr9abValFqtKLOXYtv7++DpDyCTTj35wVsvPaxumUNRhL97672zG5rq'
    b'P+IEgbM7nRjw9UAitUqSBKPBTNqV6aR0RFiAwBEpnoPHNwJ7Joz6ahN0lZNR4ZyUI+dw2HNt'
    b'qc0GHZ0ww4ZNr+KtHfsxFAlt3/fPV7+R61RRFOF7f/qrdTwvPChKMursRphNWaSMWtgM1bQi'
    b'IMukXlKtzVpCYiUyVmx+4z1UV1ixavntZBwTu8K/d36INev+CDGTiR3c/loZdcn5keIIl9y1'
    b'as0HBqPp8pHECG6YNwN2VxXMFhssJWZYLYykhU7akH9DxXMvvobPT3jwzJNnaHhc9Hv9WPj9'
    b'+2g3LeKRSEvXoe0d6tAFE2Y6sw3HI87dH36Cjw9+hrKaGsyf9zW0Tr8U7qYGVFWUn0OWob7W'
    b'hZMeb85sCqGaHYDJhHQ6BR3Hz1K7iwIjnI5GQmGb3YGBUAKfHDyUHymApvoaZEQtOj09as+Z'
    b'iERj2Lv/AP6y5XU8vvb3SKVF8gsZkqLMVKcUBY4kORjwdU6Z0TTjyJFjOHy0Mz9SAE0NtXRa'
    b'Rrz/4QEMhiPo6vGjs7sPnh4vPfuIcBx6A/mB1QSnowwWs4BYTEE2m56QMPOHicyE2TBXXjnp'
    b'0dvufmDNyy9vQXNdLT7etTU/WgArH3oen5/sg0ZOUHSwkto1sFlMOZJ2W0kumigyBUbapd8X'
    b'xObXt9Epp0Z8FVwpdu0S2RrF2LAUGvAfMRoESZZF9PiDiMeH86MFUOW0UHJL4qbWSVg414pZ'
    b'M2txRetUtM2chrZZl+O6a67ErYtvwD3LlmDlnUso46VZSjFX+6Wp6hJFo3XZfaujLbMXKM4p'
    b'c5Vdu/fQP14Yf936vnLRnLuUPR8fVAaCIUWkomEiXHblIqVm2rcU18VfX6bumzvhC5F8ZAcC'
    b'AX9/oGZyAz3qcKj9WL63AC69qA68QEnCWoqKciclCp06Mj5mzWyDYC6n7K0tOlKMEY5HBgKe'
    b'ispK8PpSHDlOme48wpW7qRo2eyXaj/epPRNjarML2XQCkpwtOlKMEU55+7uPljls5CQijnb0'
    b'Ue0w8WkxCAKPKY0udHgG1Z7xEQyF8cFH++Hp7qYokWD10WWoqzs3uJ8HxnIq1SrapaufeHbT'
    b'ppfe1AqcHsf3vpYL9oWw9tkd6KBI8eL62xGlUNbR2UfhLYCTJCc8PnR09WMwEqGZo9DzMmKJ'
    b'UToUGZlE/IpI1979zC4vBGOEWdu2fPUv//Wf3f8tSSazeGPj45jdOj1XdU2Et7YdxjN/Ogy9'
    b'dgix4TQ4XgOjUSJPSFDBlIaRF2EyAgY9n5v/3r5uSiIKMsnIykD7tg0XSniMDXvL6+31hCZT'
    b'HFY0CiWQjnPIUhRQn76Au9EJTmdCVcqDuRX70Nj4KZpdETS4MmiqMVCKb8S189uw+Mbv4P67'
    b'70Bb62VUnUqs+inK8VimG0MsEhroqp3a0tDZNYj2E+c6EsedPj2PpoZyaMkouclOXDJ7NlxV'
    b'FXBNqqS2Eg4qM8+u5KZfUoft+w5AJ3BFOd7pqwlNF099esH3VqzYtvNTuGuc+McrT6pDE2Pl'
    b'z3ajsUbEAyuuUXu+HDs++gTLHl4PMZUSM93H7KHQ0cfVobjajgfmTAKZz6r81zy0dILLH1r7'
    b'B7lu7i1KY9vNyuhoiuYUxm9eOKjc8/Db6reJEQpHlfr5S5W6eUsUva3qQdqXmeN5CeGUDTOw'
    b'THV8dCiSptoYEtWu7cdPqEMTo6HWiGO9YbpKFY7dRoMeFosVGopE9tpp5I5I5UcKIsM+ziBM'
    b'0tfX4wkzG9Txehz5/PwqtykNFgzzKQplXrWHHJTIn+zqw7vb9+DpTVux/NHncO3SRzBj0YNI'
    b'KXpSpwHVNU0sFv84/0ZB/IJ9nOkRgOPqb17/jqNx9tzPTvRg0VXTsO4RuikUQGdvALc8sQNt'
    b'DRxKDAJO0i25yx+FSD6tyUUaGbIkQhYzULJZOKx6TLaa0cybb3zsqdvfJsfcQ5Pm5BYbH0dI'
    b'LieTEM8mbLhkWuuGuQuX3LHzQAfcLhve3fSEOgS6MY/gWGcPTvQG0emNoTMwDM9AEiOyGXqL'
    b'M1dGsrDKEgPLmCa9gkqLDiWaNEq0IokMC11M00OjSMZG/ZHugebn33ksSYQvpeU/ze9yRuRi'
    b'5sK00EZk97KOswnrzGbzqnvX/PbXW3e1k71IuG3BLPQGojjpjSI4LII3U9w12cHRlV9DatXq'
    b'eEoWAlwOEyxcBmbNKMxIw6LJQJNJIqGWqulUSomEQ6loJByNhkO+zq5jv+v1dryS8yQCkV5H'
    b'DXPCs/ECTblLfT6HMPu+4M77Vv/9UNgoxJO0qZbUKhjodsFEj0q641VSsW4RFCIooUSXhkFJ'
    b'IR6LksrpCkQ371g4nIlEBoej0cHgYMjv9fl6e4JBbxfdvntp/QBJiMRDElf5MsIl1Bwmqc91'
    b'5MGKlCk0J5b/ei5hhqmtc+bvvOkHP6w4Hsjksp3NJMBq4GAVSEeJIaSSydyLw8NDUjgUTMai'
    b'4cHIYNA3MODr6+3xdNE1iF30fCSMGNuMHfMISZokS8LCSY7pGGEGIr2QmndIWCfbYimNb6b2'
    b'FMYjXOaqrf/zj37y8293ewNwlNqRoXgcCTF1BmOk1sBg0M+IdceHot00v58kSMIqHBb8GbFR'
    b'EhaGxoh9weosnE6Y4TQHbKcxZttnYDzCrEq5epKrZqmjvKo8OhjyBvx9TJ0sVzN1hkmGSNip'
    b'JUkYMVZksB9HvpTYl+FswoUwHmEGlgonkTCPTZCcrk5G7NQvN/8vLoww8D+et7fmqnVTXwAA'
    b'AABJRU5ErkJggg==')
imglib_Logging = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAARnQU1B'
    b'AACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAYXSURBVFhHvVd7iFVFHP7NnHP33nV3'
    b'r2/K9bGYlmL4SgsfaBkSmFKaBmmElqXihhj9FbkgSSZJ9IeLJrFRGRkZpJZW2gtLExVBS80S'
    b'e5tmWeju5t5zzkzfN+ee291t12Jd+8F3Z+Y3c2a++T1m5iprrRYRC1AUYI01gxe8HG3b8aXu'
    b'H6vbI1ZKfRu9MNfsGz8wvQyKT4DAdRVJgYBSrLJAaaLed62Xdw79EA2dOcpz9AxgCVTI1rWN'
    b'63J1g5rrYx0/ETp3n9Rypl7CNxeqQ7cM8pcrUTswPCHBTx0B7lqaEbBR5czn1PbGnBn+VrWS'
    b'ILKSi0RCLBhGRoLQQocSCwbUo5/6nCuVq1Pqdmfk1YMpKU9F5rUFcmrKEG8N5l+Hrno3ACS4'
    b'e0cgIZIvSwDlKKKbqhjYHeaOsHBkFIDFQSYiISIAiQBkHUHrLGHxfX3g67vX6z5bDoU1MO9y'
    b'TNrZTY3JSSARLpwsXgnE63eAcKJGWGZ2nVe+cb9dbI15HKquQDMCFI6lrgn4k4oOE1iwKdIy'
    b'7yWbqdtj58ISd0Bb6gIQ4M4TMog6CYFG1+pA4UKB9WXRRtWt9mO7BCTGJIu6kgHoWnHbxcTl'
    b'CKIGc3LeIkBvrPaWbpKhtR+EzzDkuZhPPYCYljSq45AFzzbkzLC3q7ULqjgLGGwINIDRHyAi'
    b'GXSRy5JErzGOUyEjjCfnm+KADaMQAczSigcbr91VKt3L0m5xmjwFkByFJKqA3q7VHoEdA2ZD'
    b'kBNtQrHRRSBAtjRBfxG7DSWbcSNdEPK0qwBKAecKCCO0S1xtnyS+TEoK6w7wdKJPLMDTielX'
    b'BtASvwANQPuEMxTCqXVJzE0C5wE6jTrumu7gSfUHcBnSNoFibiSQ5DzrdAOtUA5cegsdJBre'
    b'6IRM6AlUAX2BUThBJ4NmdzKNvQU42gnywqozt/uJS1bjFoQHMcFa0XdFoo78mHvl1wbNs5nm'
    b'ZzpmcOj3r9lqs02hVatm+Egz4859Xj7u4nEl0zIG05BweqYq6hzLO4Pj2RfgduzTOYCvjZRn'
    b'PHlxX1ZKdFrUfXWR3XAgCf4rJxoWXDfrd5wXOalIa0cg5aULaXfFhTdpjywMzEdEkbRKoCxl'
    b'Ze6NoVzXg1cC/IRRPTKhPDQ+lCemhnLv6ABjeF5xZ5FMGBBIzZRIHrstJ8MrQ/i8+SJO8rHR'
    b'UlolkEUuPDlD5KaquLt3uZHtSywWMXLnsEhWz1Ty+oNGKkpCWTA2lI3zRW4eaGT6CC2bF1sZ'
    b'U9UKgX9IHJStu8D1sSumvWhiJFdnlcyp8+SGVb48usnKyH4KlrCyZLKWPV+L3F4rMnVNJE9t'
    b'Fzlxll/+FxJtEWghlV20/Iajae83mNZ68t5RXDjwwJBeCtbS8tm3VnqWKdn5iCfVk7Ssna1B'
    b'oPW0ayltEuDeU9pImWfl2KlIrsqK3DM6kq6ZQBZOtOLjAP/0hJWzF4xMvFZLY6Bk5TYjXeG+'
    b's/XM/Tac3kIuaYEV040cX2FkJ3Z8+Cdxvj9c48nDk6y8e0Rk8+daVsLko/pa2bHUyLJpWuqb'
    b'jNR+xCv134wbE2z1HMj4Rsb1yzcwbu93TCMrtw62OEzgY1xVu07itYz7njII2TJ+AN4NOK3e'
    b'P27kzAUfDmg+J986bzxwQU6dq5eKjF84B/63g6gtAjigyNXgUigC2l5xO68roKCnr00B2hk+'
    b'Bh7t+bGYPz++WJK7QZ07Hx1oCBTvf94DfYHTsPfIDftNFm99df9YvF/wrcG5TvB5hQL/fOKz'
    b'3pUEzns+uRI9x/JeEKfjeCOd0hECugFHMe+CClgggzvO2hFYFJnrXkUkgDeUqZ613k5rzEl6'
    b'a/5NGL8BWfKfUfzviP+EWOdC8Ri+CeN/RvH7MP7u7zr0aLe8C44CpwGEmhx0dSUZGM7jBrAX'
    b'NPm6ja/VAnD1alS01ii1+Gh7CaDzgVS+LPEUFiNYxxOMH3ISzgML8BqmQ4gcAEuYp/Eqnnfs'
    b'51DmT/DcVQzLggpKsHKWJTV+ASVNjDe+K12fG0/XsA1v828dOiJ84+ZB/cOvUtK/m+8I9MI0'
    b'1wC0xvfA9Zh69Zzn1ZAtX+RpXhFBWg+08hcVKoByJWd6hAAAAABJRU5ErkJggg==')
imglib_MessageList = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAARnQU1B'
    b'AACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAFFSURBVFhH7Zc9TsNAEIXXQCROgDgE'
    b'N8gZotyAq9g+ASUnoI5QinQpOAkdFYIiCJrEvLfxyIOzv0XsAn/Sc3Znxruzs6MoKYwxS2gO'
    b'3UM3EG3nZA+9Qi/QioZnqBlBB2jD075Bt01D23AUhS30zwUeLHsydV23ow6fTRTgmmnYo/sq'
    b'wAXKsnQulGOnTdNWwDZcMIFzcZJAVVX8GAzZb/QKsAmTkDt13bnLRnx2TTSB2OLaz7FI0GMX'
    b'Uw8kXYGUMVZOHZtKchNqdEK+TfsxPqYeiF9BG/gHsbl8mpgfpPVAaEPaRDLXuN5R0Dv1QJhI'
    b'CZ1kvJPeAyJBxtruiwnAiP/dA9EEFjakY30Mt9Cn5zlk/yDR9JPiXNv6/hCMtEeYvgfGggl8'
    b'QvyfNgY7Ph6hD4h3MKS+oYdLPN6hGXQHXUFD8AU9GWO2v/nSxc0QeRHAAAAAAElFTkSuQmCC')
imglib_play = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAAAAXNSR0IArs4c6QAAAARnQU1B'
    b'AACxjwv8YQUAAAMAUExURQAAADSqjTSrjjSsjjSsjzmsjzetkDiukjyukja3lza4lza4mDa5'
    b'mTa6mTa7mja8mze8nDywkz2xlDm7m0Oyl0SxlkSzl0azmE+4nVa4oFa5oVa6oVe7okrBpErC'
    b'pUzDpVfDqFfEqVfFqlTGqlfGq1jFqljHq1vHrWfMs2jLsmvNtXbFsXXGsnfIs3/LuInOvYrP'
    b'vpTZyJ7XyZ/YygAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA'
    b'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA'
    b'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA'
    b'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA'
    b'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA'
    b'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA'
    b'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA'
    b'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA'
    b'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA'
    b'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA'
    b'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA'
    b'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAASMgigAAAEAdFJOU///////////////////'
    b'////////////////////////////////////////////////////////////////////////'
    b'////////////////////////////////////////////////////////////////////////'
    b'////////////////////////////////////////////////////////////////////////'
    b'////////////////////////////////////////////////////////////////////////'
    b'/////////////////////////////////wBT9wclAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAA'
    b'/0lEQVQ4T62OyVLDQAxEcWySOIMyENawBQiQsG///22mNWrH47ELDtAHlaT3SqWt6pf8i3Dr'
    b'Ljj0BcK1eH/JsRu94L0Xt+AijQniIN1z1U4QAp+66ZLLOCoInlCOesd1Ewg3DYe6IqijQszR'
    b'tq/YkzFHuybUBCHhaB+ITehy8buPkZByp604UyBcORGZTFBcuYNa6uxKkf0PE06LosgGKHmW'
    b'1+0gQznhhbMNR2n40ZdyE3r48WfAJnT5ASkCYZ7yQ7IQPhnx8RuRxZ5s+OydoE4QNnwvxSaQ'
    b'56P2cYv+YHz4ylU7EObKt5+5SGNPDp84dgPhvHjh0BcIP+evQlV9AzuljTZCD9lUAAAAAElF'
    b'TkSuQmCC')
imglib_python = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAARnQU1B'
    b'AACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAARfSURBVFhHrZcNbBRFFMdnZ28/eu1d'
    b'oUerxdIitny0SNpSSMWQNFoaTEOqRo0f0cQImNZY8SNBiSaaajBqmpiqJBzGRtsQmwgNgRAT'
    b'NAgiEpuCLcVTwdZyUAvVfrl3t3e3s77dPkiPvbu9yv2SuZn3n83Mu5l583Y5MkfKnjniEl35'
    b'a4XMvMJIYGwZx/GEl92DLBK4qE4M95z11lzBR1MiZQcqX/RVUMn1OnVI9Rz8oByLzqJMixzT'
    b'QhOtva3LDqGalJQcqNo+3MRL7lZoxp/YCriitqnjg9v6dlXrqMWFYp2Qqlf9xbyY9aE6PiTB'
    b'8pJfPt9EosFx7E2IsUjNQmbuY2gnxNYBTZ2uNYb7+1w3UUbOkKmh42Ry8Cj2JoeX51VjMyG2'
    b'DsDc5jM5y+tJxoKlJGthJXEvXm/22cFRHluJsXXgGrKnhKxqPEXKNn9DBOcCVG+eVBwYgXLC'
    b'LBwHtVHQnikRKP+bmChYueVoCSzzckIdqNhDebEDKveMZaHt05W17YW3SLcZhhEO/lHVX/ZI'
    b'z2nDNrjuAITaS7zk2gmSiFI6aOusrPMU5EmPo20SCrPdI2PhxhUP/cTMLYBQu5sXXe+neXLj'
    b'MiAO3nrVyCLdOs/l2Ga0TQcoL70N+5vygUwVCGEiCvGHzcrgdxzzljtp+Qv9RRBqqcXVHIEw'
    b'7HPKVEAzBsHBeRbny/dRwem5C/69fcDOEV0LT62W9h+hHKlDyYIkcvcY61M+Y6YRXZ/mKdm0'
    b's6ZrB2xBNqoWoK+Yg9O/GxLNFtQSojNN01nkDHXIfpRMdJ0RwjSotWv1kDN4tr2rvmVrtsvR'
    b'mCzbTSmaj6t8+fe9kDQeRS0uTFO77pS/e62lqnWNJ1twohwDuEcorPekEi2VBPpwhkSLsCsh'
    b'ShAcWPvGP+9CAGxHzQKk1b2flTfsun2h4wuecraDzgVYgR8ohMoltK3Amtdmet8putXxVbon'
    b'N6CUnKcsEvwebQtMC/ufXnFgFYRMLkppBbbtBA1e9fVByPyBWgxw4MYjUTYfzbQCk0chLxyi'
    b'vo77NV2LvIe6BUlM+wVpooRY5+oney+Zo2sRxauFla/NnhsQZ95H0orG9IGhy6FXjPb1MF3S'
    b'8InkKX3gCUgg62ZdjMP71j84ljtf+BhtC0GVdTKmh9C0JaAy/8AF5aONz/ePGXaye8Jk+GB1'
    b'U15OYgcglN6E/VTQvJHe/I0nv8V2XG7aARva5HXHm7Edl7Ru8J7uEbK55Tdy/mIQFXtsHUj6'
    b'VTEL/xWVNH9wgXQcHiVvef9E1R57B3Tdh82kQI4gxQUyZHZC1pS6TA3OR0ziioftGfixvYK7'
    b'oyBjv8vJN6CUkECIkavjYVKYL8Mtqp8+2T91b21TX9LPKNsXkT3df5GSRfK+pUXOCUh2FZDx'
    b'MrHLAlzZBBwNTipae8+5f5/a8FzyyQ1sV2A2A19WyTnZQh2ciw0w0aJpRVvCdF3IcQu/KiFt'
    b'NBDUTg1eDh2sefbnFD/RCfkP9l6MPmcegLQAAAAASUVORK5CYII=')
imglib_red_dot = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAAAAXNSR0IArs4c6QAAAARnQU1B'
    b'AACxjwv8YQUAAAMAUExURQAAAMZATcZBTshATchATslBT8hHU8tJV8xLV9FDUNNDUdRDUdhE'
    b'UtpEU9tFVNlNWtxNW91PXM5UYMxWYs5WY85caN1YZd1eatJqdNRqddVrdtttd+BkcOJteeNu'
    b'etd2gNl5g+N5g+R4gtmEjdyEjd2HkOWGkOeIkeiKk+CcouOfpuSfpumbouidpOqepeyepeye'
    b'pu2nrgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA'
    b'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA'
    b'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA'
    b'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA'
    b'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA'
    b'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA'
    b'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA'
    b'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA'
    b'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA'
    b'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA'
    b'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA'
    b'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAALvuk30AAAEAdFJOU///////////////////'
    b'////////////////////////////////////////////////////////////////////////'
    b'////////////////////////////////////////////////////////////////////////'
    b'////////////////////////////////////////////////////////////////////////'
    b'////////////////////////////////////////////////////////////////////////'
    b'/////////////////////////////////wBT9wclAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAA'
    b'5UlEQVQ4T6WP2XLCMAxFoTFtQ6zSFcJO940C+f+PE44lL0nkYTrchzuOznFs9/BE/isc9jte'
    b'uUTCdgwAWgPcfvCkjheqkUGWm7r54mkQXhi5mvDcCYsW1/qOAAvt/XWNLSGhEjjo5yDE94vK'
    b'C1uZw9IJ7v2dckKKR4LM4ZOEQ4rDioS/PC+KgmrYqDkJ332lVL9VWV0l3yHFs40XZK5+WbhK'
    b'cGWYFV4T/NEJOBC5/QEJ7yJ/CgI+CPzSEhbwusMvCDgB7+X9QcB1g9P5dbyAOPXcvo8TCSZv'
    b's7Lc/PAHpSkIOVdAPAK03uyBI4o8uAAAAABJRU5ErkJggg==')
imglib_red_square = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAAAAXNSR0IArs4c6QAAAARnQU1B'
    b'AACxjwv8YQUAAAMAUExURQAAAMZATchATchATstBT8xBT8dGUslGU81GVMxNWtdEUthEUtpE'
    b'U9lKWNxKWd1QX+FlceWts+eutOywtu6wtwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA'
    b'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA'
    b'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA'
    b'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA'
    b'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA'
    b'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA'
    b'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA'
    b'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA'
    b'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA'
    b'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA'
    b'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA'
    b'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA'
    b'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA'
    b'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABsAamQAAAEAdFJOU///////////////////'
    b'////////////////////////////////////////////////////////////////////////'
    b'////////////////////////////////////////////////////////////////////////'
    b'////////////////////////////////////////////////////////////////////////'
    b'////////////////////////////////////////////////////////////////////////'
    b'/////////////////////////////////wBT9wclAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAA'
    b'wUlEQVQ4T62PWxbCIAwFpREfvLTq/reKpCEptMH+mI+cE2aA3FM+qP8Ij5RijGnX45OETwje'
    b'BSznsXvpiQXinnhjsVA53WxfiSS86f099yzgUEnHWShLKv/jYrJkOdJ4J+DZlq+C+n4pSTHg'
    b'kmLEXZNC5b7u8LIWAGwpgPPSccB+I2EGMKbMXZ/MBHBlYcBFGHG4sICDwo18gYPCW0Hl65ID'
    b'rqdouJqi5VqKjispes5ClqMNh3sV8jwoZIvwqw6EnL/TgEFKkvwZqgAAAABJRU5ErkJggg==')
imglib_reset = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAARnQU1B'
    b'AACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAaISURBVFhH7VZ/bNXVFT/3+/v7vn2P'
    b'99pSWmgLFQZFyWCSlYlVix0QLRSKrGaRYMPwRxaJmsUfcVmmLmNEM7KZJTowkQGiVMEt67SI'
    b'woAYcDCryIaFwarF1xZef7zve+/7+96v51u+IWti6evmsv3hJ+/lvnfPueece+65n3Pha/yv'
    b'QcJx3OjZ+QzpPdZRCv09dY6VmhGJqNM9zzXNoVTSS0z6p1r5jRORiuvOXLfhJyxc8qUYdwBd'
    b'v3qMWMdPNvMD5+9RbFqveDbkiAsCE4ESH6jvA/EzMCTGYEgt7nBEbutZIbr1gT2HvNDECIwr'
    b'gAv3rpnl93a+SHK9tRJDe+iMZxwAxQ+hODAcAUwQcYKBDy54nA+XxPjpgbJrHmra9c7boakr'
    b'yDuAjlULFxWbdluBkYxQXKbaMjiyATnOQqmCO+fQpwss+IIE+APnMTIfwEEvaV6zL0bLftb0'
    b'5omfDxsMwYfjVfHh2lvrJqW62uJ2ThM8BRhxwJQo5AQN0mLspB2fePiC4f/O4NRDfqJ8iHiy'
    b'4PjZQkJ8QlgEA/JAZpag5XKLVsyudHedTx0JTY+dgYN3LiyfndU/iuUyhYy6YPIEXKLBUEH8'
    b'PW7K1KeqX3htf6g6Au8233xDbHDgYXUw9T1btkHwPVzrYMYK/KxatXZF+4mdgR4e4NVRRbOv'
    b'RHWnkGJKKeZL9MDv0WI/lpbcdMtozgPUtx4++u39p5o/ubbqDl2UddnjQXUFiHo6SWT1La3r'
    b'6ysDvasG8NeWlY1aLl1LMOW8jynnbfhHaeHG+W0nNs7Y8Es84LGxevvRvZnSquW9kpI1eFzC'
    b'VODoJZV9du6RQH7VAEoHP308att4UC4WE4OcMunPU2667alQnDcaXz162Js48WkR68FlMvic'
    b'CSUZc/3zjQuKRw3g4x/UT4/kUguCIuKwjHpUlRoVs39U9uAzGM34YYiFmy9o8fOcb+J+FBCp'
    b'pUyw+5tGDYCm3QbNlTjBxYoXMXW88u7cF/Z8EIrHjcbWQ5RokdepELj0kCFciDj6raMGIDrO'
    b'TJs3wSc2Zl8GfULizVD0b8OPKPscgi7Du4fccT336ZZN8v47a9a8t/KbGw6tbZx8WQSgWdZM'
    b'AUnEEggq8iDHis8E83tblpHfN8xtbl967Ya2dQ1X9PMBhcgZitTjM6RrQkAh/EzObP/Towsv'
    b'Du2oudT/3Mze5PHjzQ2zAmXZsIHh3XVAxhpwoevjv3W1NdXyxanuLXPM9O7rs9nnIqlzx4ct'
    b'54nKOTVAhMs9IyBqZhjAMXAbZGYCk31IuKnJU/S+d440109nPIeZwhQg1/fLFNKTC0iZaf1m'
    b'ajq1XvMspFcLSjOZyX/Z9MS80P6Y6OlLIkNjPXEEA8CMiBIGwKv7dEHFbuaB5LkQo93l1QN9'
    b'BwXFr3Zx93gAEPNkmJsxtxbZffdHIIcz3nCTcSDeWfP4xg8vmx8bNNU9FRysqfC/Tdgp7pxD'
    b'nv5MnPCixWlgiQLIVgRkT6+IZ/UKlwuywAD7C5TQ7MK4EzRAGWckyEmlye6KyhWhrbxA9VSd'
    b'FLqnyCuCwJ/lVvzhAPKSdF+XmnjJCfo5RzEAbB+Cg33dRXUe3WHCsM9avDXsXOeLe9IlJd9d'
    b'vv2tzmFreSC5baMi29k1HmeDR33MoAwuX3J4uBvu+KTbrysvaosLiSpJyM5l+KDgfQEEGhQM'
    b'7hq/QZOlhIeUovUNTozW175y5PSw5Txxo9d1nzJ4ce3wHQzeEBB1jKoZ91/hgeaDp2gmEV/X'
    b'6016mUEBGEKQpvDC4sMDGA9pJXFRLytccvOr7//9siA/vLF6/ne0dHaziMVH0LmHR5uKSa/f'
    b'tb39wggimrf7ba8H+JaklNjN8KxpUK3BSwcLLiNFU6lEZHHt9mMnQ/W8sPeOmlXSQO+BqGlI'
    b'Ig1IiIEtqpn4vOlPBvJwiyPResNscUZU2TXNSa6myIZDbulAZ2n54mWtB/Km4re+f+M061L/'
    b'TzU73UKoiU83Bzzshllf9geUsnXrD3RuC/S+NIAA7cvrxKjKHo6bZJo1Ifbb+Tv/+FEoGhMv'
    b'L/lWRXnm8w6Xt4o0RwBdsPCKI/GwKKSnXvP8qj3Hfhiqjh7Af4Jti+a0zDKTLxmCi48QBgbv'
    b'gkHi/mDBlMcW3LJ0c/UTm668JUbUwFcFUlR21uE1Bhz2PLxJg2rZ6ey0ebffva/j2X91HuC/'
    b'koEAO5rmL4s6+koqRY4VVdftqvvFr41Q9DX+nwDwBUg54hEgOUvlAAAAAElFTkSuQmCC')
imglib_ScriptList = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAARnQU1B'
    b'AACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAARBSURBVFhHtVddaFtlGH6SJmmbpknT'
    b'lo1qJm3dxSpEqL2ooKAXCv6CiBeCXu6yV0WQMqFQCl7UbXSMXgjKcIoM53R6JSgy1GIvWtnE'
    b'aJPagS5tfpo0afN3kpwc3/c7J01Od06bxOyBh8CX5LzP937v97zvseTzeQXSDpALA3IROpQz'
    b'UFyPwuJ6RFtoP1QBgQtAYhWQEtqyCqUQR9pyCt3PXUNnZ6e22l6oAm69AURuiR3XQ64AW7Yn'
    b'4X7pa3g8Hm21vVAF/PgaEPuZBGS1ZRUsINwxCc/LN+F0OpHNZlEqlbRvW4OiKCgWi+jr64PL'
    b'5WpcAAePRCKQJEn7tnVQTBF8fHwcVnVJUT+OgNvtRqFQQC6X+9+sPs9isWgZ+O4ZKMnbUGT9'
    b'7oqU7YhjEt5Xbooa4NQx2wG73S4KWwjIfv82UutfQalQzutQhg3S8Fk89Owcent7tdX2Qggo'
    b'lyQkov/S7iSRZrlchksEtMDR04+BgUF0dHSo/2gzRA3Y7J046TsN94APa79v4PKHV+EZPIWH'
    b'h8/gxImTDyw4QytCFbz7tbU1hMNh7O/va6sPFjoBDFmWxV09EpUyVWiKnDNZYyFG6817xH0C'
    b'GsI/N4A/PgB+e0/jOWD5LHLL74gNNANDAVbrMbrufQv8fQW4+6nGzyBv/YDde3eEYTUDw0h8'
    b'PwOBAILB4AHX19exsrIi6gRynkifnPIqlQo5p4IKXWUWkUgkEI/HDck1lsmofUc1Ig3RaBQL'
    b'CwvY3t6G1+sV/l8F1wX/cXp6GhN7c7DEl3XWLWzbNkmd8wvxHBZhVksGVqwH2yUbD1+/Km02'
    b'G0ZGRlRRisk5Uzx2OD5C3qEZOUssgGGYgY2NDSwuLqK/v1/7pgYO0PXL68DOCmVA9XVGiS7G'
    b'ln0SfdS4WDzvkgOZweFwiKM2rTYOxCr5YfXs6uqClE0gmcohQcdY5Q5RsnrFfzkDPT099/23'
    b'ntUB55hyN0bl6c+R8V9A6sz7B8w9fh6OiTld3TQC0yNYWlrC0NCQaJlGMDIs/m2ztt1SBhjV'
    b'wqxns8EZLQtoF1oTEKcbEPoICFyscfVdlIKfHN9HDsFQgNm5H+DuVeCvS8CfFFhjJfQxkrev'
    b'tMeK+QqmUins7e3pyPYqdpiPqC8y9N5QpVLKQCqRHVNx8uTMQozIRpROp1GmoYehuwVswfPz'
    b'8+IHo6OjNAkNHGSDTYV7wtTUFB6LUveL/WRoxc7nr4tZ4igjYqfl6zo2NqYXwApnZ2exubmp'
    b'rejBYmZmZjCRnoVFOOEhATTCu164gVAohFiM5gMTcBZ9Ph/8fr9eAIO7HaffrJhYuWf1LSrE'
    b'X3UCytQetigD/A7R3d2N3d3dI62YnyNG88MCGoH8zRMoJoPUgWtNSaIjTTqfwuCrXzb1GteS'
    b'gEzwOuJ3rtH0XBvBFKsDGH4TPv+LIgONoiUBfDxifD80frEbcrNqHMB/V5LDjt14n1IAAAAA'
    b'SUVORK5CYII=')
imglib_settings = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAARnQU1B'
    b'AACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAYWSURBVFhHpVcNUFRVFH7L74LyIwPy'
    b'swjkKtIQpY6O0+BPEliMozWsqUmlSdmkYaYWTjaIzaRMMaRSIw7Z6IxSNiKpENNUTgrmIDHY'
    b'oCa/A8YCgSAILGywu33nvvueu49dlvKbOXPvOe/c+5177rn37qosFougUqmERwXN838wqQCM'
    b'+rx0NAsgMRByrvfUpL+CdkJMJqhJLf3Gpa2dt+pdg9B1gdCsY7pkn2p15IGn6bsjTCYAmtAG'
    b'I60fXoQUQ45wkwDyXjSSLwXtfqepT9QA+DrNhiPIGcAkj6E5hokTQaiKjTbdjNH674LNWFQ2'
    b'8E1dQ18oc+RIWenThe9voBuNMTqM0SIrt6FnIDPXmZMdKLPCAgD5DDT7MNGr50oHPMgGjILk'
    b'D7QusM2lllk55sz2NyPIkyBeiuAoeBfYhhHEVQSQJHrZh3UQLABDo25j/d3gz0E0jVkfEXve'
    b'NlxB8xFEA1nrPasohezWkIKQVtWHlbShdV41kwAW04JGjza1+Oew5ShiIxZZI361hVwDcNic'
    b'fdT7QFdnZzA3WcM0PSSkCykeQd8NKQ+Dn6v4yRbw60AGVoP4RHn5nVhuJnsP7OeQjS2kSxmw'
    b'DoD2/tmd+x78IFpEYOAQBp5CtxjiDqG7QIPVbcw/3uCPvjwHfCn96eXXr8UXl8au52aCMXe/'
    b'72mQp3Fdhmqkad5MaiHay5V/Z2BgAvsi4l7+6Z/o/I8Dxr3Wdq9jb86ROC1Ulo0lS2KEQN8i'
    b'X8xBWxBANsC8e3vt3lmLOrO5bgPVj4VhpzBgIfqUgfDWljo39gVR5+X+k4mBn3J9HBDEMwj6'
    b'6KEv3Sgrwo5tY0LNDVPt5aueccwBWBZvNOx4KyxOra1p5iYbuGDAKpBGQ6KsyIWZUf3G8MDQ'
    b'77hqF5j0V63WfIGrElJ5y4Bg1MjUFgQr1wz6X2R/EHwb7Vk6Bb6i2RYzNOp2NMOiJoIKR3mR'
    b'IEg17woXSofG1uhUD69IES7pOz22IYgcEGohL+3KbF6HwB5H9p4fdxVL+Es/Mmwx/zmfqw4B'
    b'n0HeJfyuCeijmlJiKoLYeuhYexHIjza3+LH6QPanUMoH9G0dPmSwRShuty4KoEzUUTB2Xs0r'
    b'VQGrMF7YsC6gd43OK+9wgfprspNNAY/CM8JTYtcgNkJAt2t+rs/QgvlTz69InGIOClTPqb0l'
    b'Zn3gwaCnwTgt/OIJU+MneWONzKjAcIN6X16B+YXICPfutNfds7BK7W/XupMwlo7rRLAsWex9'
    b'P3PX0E4VJgmHgcKdqe/1j05Z21PCXESYPjsYdGXpwt4sr9kjdL3KwLj9hwv80rBVd9/b7nUB'
    b'5IFYNT1e1hiFNEBCIHTNsxSCvDMny7gZc5bJOcWEL2PCwsIz9PLaYBQD6lavnFKDiv8F+oKm'
    b'Jhcdjp4fTkoNyEsQ9HLYVzDvh6BxJSA6jW1KRIHOxd5741h2vPtm/1mQf0VOcgA4FhUgj+eq'
    b'PVD5myB0nFSYXAB5GMhPQle+fuRbhey9/9yGdmXmNCDXc9XmiR3jrSNQsFS0RE4rT0DaC6En'
    b'0kcF7oO8UElOsCYnyJcDim0Gim4eitATKpGZQKQ3mQPbUFS0f+J1u9i7BeQZIF+PPU+GSb68'
    b'OAZBfhzkH3PdIZR3CqUnG1tR9WSke/+2VL/vuVmgPuyjuLb7GytDwvH9MsSiEBOkGz7f8mEy'
    b'pAvMnsg1IAFBLEPRRGEFtLcMvEAPouIjyisMAzApb08zpBkrP49xu0WTCCKZCOMCIIx2e3q7'
    b'BxnZbQHyVSmbpm9HuhdDla9dBaQ9f4frDM7IGaRUOAJS34HUGrENrUj/i5As9HutUj+EtFdw'
    b'dxnSvM7EVrGD5PgIRgTi1ciMCuKK/iYihhhBns9dZVjP6UxsHiMyWANk7MekJjxUwCNDP9Vo'
    b'y8zoX0JbCftQQlJPAflIUM7hDA5fQ44e3Fz0LJtRhHvQ6iDJ6NMRW4RvXqiVavQZ/is5g5QK'
    b'SZTg6W6C0DEb5GKmFt9yuRuDcq7JiH2jFbAN/iDKQOHdBKkBYkF/GDabiifYm8uZsH/HSth7'
    b'9xHIE2joz2gthI5jNdJPd4IMe3NNDEH4F8p/iVWknXL0AAAAAElFTkSuQmCC')
imglib_skip = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAAAAXNSR0IArs4c6QAAAARnQU1B'
    b'AACxjwv8YQUAAAMAUExURQAAAAEBAQICAgMDAwQEBAUFBQYGBgcHBwkJCQoKCgsLCwwMDBER'
    b'ERISEhMTExUVFRYWFhcXFxkZGRoaGh0dHR4eHiQkJC8vLzExMTIyMjQ0NEJCQkRERElJSUpK'
    b'SktLS0xMTE5OTlNTU1RUVFhYWFlZWVpaWltbW1xcXF5eXl9fX2JiYmNjY2xsbG1tbW9vb3Fx'
    b'cXx8fH9/fwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA'
    b'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA'
    b'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA'
    b'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA'
    b'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA'
    b'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA'
    b'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA'
    b'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA'
    b'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA'
    b'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA'
    b'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA'
    b'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABHjLGMAAAEAdFJOU///////////////////'
    b'////////////////////////////////////////////////////////////////////////'
    b'////////////////////////////////////////////////////////////////////////'
    b'////////////////////////////////////////////////////////////////////////'
    b'////////////////////////////////////////////////////////////////////////'
    b'/////////////////////////////////wBT9wclAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAA'
    b'5UlEQVQ4T92Q1xKCMBBFLzZEsfeCBcTe///f4m5YMBmZ8VnPQ9hyJhsW6gv/JjzHngM43kRy'
    b'IRWOVWR4ZykyInSpXp/Gx0M8qVHYT6pMIpSB1lNHxKMBuBKLQP1AZ8LcMFjwgVOSpezpRv6G'
    b'WpgBW102iPSdAcCCg4GUDXooKlXCkISQtByA3ZU7UBV0pJbht++qiWaLn0pDPl9Am3BLvLIo'
    b'EaT8ZlPnLu2dYuhBnwxZGFFgdxcrCYjA1T1LKIB/LuPGhyks+dqFJCmmQOsD1pKkWCNcoCph'
    b'hiWoix5rYQs5/ICg1AvyLFxwM7JAMQAAAABJRU5ErkJggg==')
imglib_TestFail = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAAARnQU1B'
    b'AACxjwv8YQUAAAAJcEhZcwAADsIAAA7CARUoSoAAAANlSURBVDhPVVNNbBNHFP521z9rHK+9'
    b'WE1iEjc2VQErVXCqVonSlgZBWxEVxIEWLlxBqFV/btwaJC4cEFKviEMrEAe45FK1EigVUgv9'
    b'UVJBTJoQlCpOHMfYye469q53d2b6Nu2hHelp5s2b980337wn4T/jA0WJjnR3v5LW9bH+ZPKt'
    b'lzQtbxnGi3Kj8euqZT2cNs2nP3c6W3RU/JMBKP/O0qe6nvqwt3d0NJe78Pbw8KkDB4eG+3L5'
    b'bC6VGijEYkN9QEHjPKowVt3yvFYb4EFiACCd17TU4VTq/dFM5ouX9+8/ksxk+tRwOB627WjE'
    b'cWJRzpNJIDvg+4Vtx5E9zsurjFk+gSiHifaEpo2NpdOf9xSL77De3jhfW5Pkx48h5uZAa7R9'
    b'X+pEo6GE5+3WHSdXdV1vk7GlmhBN5SNV3femqp7PJxJHIhcvxtWzZ7G2ugpnehqdxUXUhUBl'
    b'YgJ7rl2DLcuS/OBBkntezwbnlRXGnivvRSLH31DVUzrQ7wkhxY4dgz4yAiMeh1Euwz59GkOT'
    b'k1AiEVi3bsGenZWIkbrMWIue8kg5GQp9lleU16Ou2yUWFmC12+g6dAjJYhEBWPbECdJcoHbp'
    b'Eqw7d9A2TZicK8SgSQJ+HwB8qQuRlRmLeq0Wtmdm0Gy3oI+PI6JpO8mVq1dRu34dDunhkE8A'
    b'clWIugdMySZnlul5zHBdmL6PLUVBg1gIOrgzJAn6mTOwwmFsk9vkfMdszqUATF5n/DeTMdPw'
    b'fWF0dcEhyge/mkRQYbWpKTDHwa5sFsX79+EWCmjSvkno9ANeRXChDFAtJIDBsCz3+/l86F0S'
    b'KpZIoHzjBpauXMHm/Dx6jh6Fmk5j1+Agnty+jRXfd2cgniwJfCc/FaI0z/m9BudV2zRFmJ7w'
    b'182bmLt8GfVSCSt37+Knc+fQoLowl5exwRieCWGsC5ReANsBU3kc2LsX+GRfKPRxOpHIhDxP'
    b'AukAeisjDXgsBp+sTiKXOh3rdyHurQFfO8DDoJQFad1sAWUSR5EcZ4/tuqothGKThIFwhueh'
    b'Ytv+gu9vzgI/rgPfUuwXCrV3mmmD7iK0LdpcqhMtixJJLEFt59TIL1NsgWJ/Aj9UgW/o3CNK'
    b'M8nE/9qZhkRsdncDr9L6NWqWfgZEaDbpgkUC/oP8CsVcMvpn4G/u27raUuVbHwAAAABJRU5E'
    b'rkJggg==')
imglib_TestIdle = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAAARnQU1B'
    b'AACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAC7SURBVDhPxZFLCsIwGIRTwYV4DRcK'
    b'ikcQr+JFQu7hecSVGxe+rqGbUozfYCpGE7G66MDHNJTM/0jhvTf/qBP8Z7UfkN2Bc67AuveT'
    b'qay11/AdKRnA5R42gCEo6ARHQi54pLeAUHkMC5iDxlzBEjavnaR2oLZVWZenMIFZ8Hqkh3JL'
    b'VBfP/3SuiZQKqEAzq+09HGANOyghUm6JfWwEaltVdXnL/Gc80qdnVHeaWQFlo2dsotwSv1bb'
    b'AcbcAKPrOi2xiwpPAAAAAElFTkSuQmCC')
imglib_TestList = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAARnQU1B'
    b'AACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAj0SURBVFhHhVcJbFTXFT3/z2KP7Rkb'
    b'Gxw7BhwWs5iYUlUQGysJCFCFkxZRkCKiBDVILUsbFYqKEC3UhKSFiLQEHLVpFoLSlDaKCmok'
    b'UHAQIBUoLiJBNqGJWQp2FC8weJ8Z2zO/5zz7OU6qqnf09O6//7577vbfe+N0dXXNGhgYWHz8'
    b'+PFtdXV1+YlEApY8z4PjOMNPX9L/ko+mSCSCBQsWtFRUVLwUDAaPUP8O13VlZmZ6wyro7OwM'
    b'OC0tLQe3bt26uLe3934ucEOhEAYHB+Hz+QxIMpk0s+u6hheJT6VSI7z0A4GAcUw6Wnv37l0c'
    b'O3YsuWjRousbN258hap/5bs26iUzMjKSBHfIu87evXsHLl++7NuxY4dDT8FsGKN+v9/wIvEy'
    b'LADxmvVO+jYbcsiCa70yee/ePWzatAnV1dWfzZ07dwP1z1Hf4doEeROBj148t2rVKmfChAkm'
    b'Ei2WERutAGXcgouXXlpa2ogjjY2NaG1tRUdHhwHV++zsbITDYTQ3NysbHktRR0ev6B3BXa5N'
    b'GrxZs2aBGTCGNRSNSA64rniPcvGukUvH7/cZcMnlbElJCaZNm4aZM2caPjc3dyQrS5YsQW1t'
    b'7QDtpQjIeAMmcvIqAYaskuSNBDLc3d1tHBgYGERPTy8NDaVZ0Wp2XZuhL3tDGdGsYUsjm8oa'
    b'qZt8nPbTtKi/v98blsMvg1pkBTU1Nbhw4QI5hz9GzAzMmD4d27ZtG6mvDAtADmutZsksr3cE'
    b'QXp6unGYw6X9IOUZDEJp6JId6agWBtxG2N7WhocI/GNG8WxaEN9mktrb2ocjH4rWrrGgti+s'
    b'QzJsMyKepOhc6qjRC2lLWTABDYVNkkAGXArv8zmYQ+9dfrGdrLPDXhBgPB7H5s2bTYksyTE5'
    b'JNKs5/z8fOzZs+crGWFwDvcA1T9EPkBwjwF5xgGrqMXMOPyey7jZZBw0bwwoQjmxZs0aRKNR'
    b'kw3pK3rx0tEQP2bMGKOvEgzTeK6ton4DwZuHM+5TOYwD1phKQDO4EI+hKck683dHvRaW1tAn'
    b'OWfOHAMqXoByXqkUoE27eNHFixdNPzG7/qNHjz5eXl6uz/0gsf5OrAGuc32VlZXVMjB79mxj'
    b'VF4PhLMQmjIVaZMnIfLAJFRUlJvPS8Y11OVywvICtDLxly5dwgu/eh4ffPAhmhJM6ZhxdKQu'
    b'cOTwH0uamprKS0tneSzHv4gbc7Zs2eJpsVIrB9QLyoiGDIrkoAW0jaZnW19lT3N/fwInak/i'
    b'zbcOIvzIckQWfgduKAupQaUxhf7ma4geOYhxqd7Y/v37fz5u3Lg3zD4gMIFr+xSYhgWxvIZ0'
    b'JLPgmuWwZpXv2vUbOHTobeQ98RPkVD0JJxQmOLdzojj+ANKKSlCwYSeiWfmhnTurf0aba77y'
    b'FQiMuxYaGhqGAPms/i4uLsbKlSsNkE23dVB1F7gcOvynd5D2rUeRMedhrmMLqxcYHLSjMgv9'
    b'rU3wZYYx9on1uLL3pwXnzp//pcmAjNksnD17FjcbPkK0/ARaH/4bmj6tx+lTp0YABW6bz2ZE'
    b's86AK1euIly5FJ5DcO6iBph2naSHxM0raP39DsQ/+QfczDyEvjHf+bC2NsfshIpcDigSGRy7'
    b'/g7alzfKN4wPZuDz1ycbuXQOHz5sjlpFLLJyfZpeMARf/v3AQD+dpNzhgcXIEzc+QfvBPYiU'
    b'L0FGRRWbykH6xBn4d937cGVApIgMMSe9pW1m1l6cyOtjkw1lR5HzHAfvDiZiOaJnzZI5fkbL'
    b'IBDw4c7bv0H0LzWIX6tH26EXkVW+GOHHnzabmpzymcZl9uS9nLCZYC4Q2TMbge31CEbTEf5t'
    b'GXiVMeAaa9euNX4qW7YcWsuLDdauW4dUvBcuP+WcxSvQ/uav0XvxNLIf+S4yH3uKuyw3LAVM'
    b'/Xh7M6YUjR86C2RAjigL9xUW4ubnwBcbSnFr2zQ0dPTB3hVs2tWwo7972eB3zWadiO5LZ1hz'
    b'7oITpyP/h9XI/d5aZBOce84IuJsaRN/H52ILFzz6rtkHdA1bvXq1MWQ/Lw2bdgtuAW3k4pU1'
    b'zQri9Okz+N3rb6Hg2efgK5wEh3IV2BkG1+nKAwAd7x9C/u36d/7w2msbzFdgoxCIsmA7XPNo'
    b'cD2PBpdcwNKVvKzsQSxZUImWV3ci0XARKeoJ3EkSnHcKLxHDvaNveP6Pz9z6xfbtu7i+2+wD'
    b'ikJGZJRbpbleWRDJdbqpDKPBbXZsL2gT0yG0bNkyXsUiOPbuPiTzxiM4eTqbkmdEtBWxqx95'
    b's0umtGyuqflR8cSJjbyyef9Vgl0v7EJj6z+RUdlpDqP+qxkYE5uJ/S8dkK8GXA4rcrsBWZn6'
    b'qKenB7zqo6+vz5wJV69+yv2h3luxYmW0snL+ibKyslNc+2dms4f3xqHj2NZckSSzelH69G1E'
    b'H+oxgNk30tD+auFI5Ldv3zbGxQtQwCqN/ZpEakhdSufPn4+ioiJcu/ZZ7zPPfP9lyg9QN8Yx'
    b'KHDpmo1IZOs8mN2NWBGPZR/3Bo54LveHjEETrXR3795tvn2RnuXY12ns2LHYt2+fKZP2C9IX'
    b'5PW/oFOOK1BmyuGz45cBa8ikMhZC5FYagrmD6M5KIdIaQHdb+kjD8RQzs4bqLrnNgLIhRwUs'
    b'EAUkGSlOnbs5OTnGW4K7fPa4llcfkhS1UAdLsDMHlw4U4vrWYkRfLkT9rvHwdUUMgHTULxp6'
    b'1r2f/3JMyjUk06z3smkdYHDp4i3JYYI7lDv+rKwskyaBS2ndD9YzxU8aXor+b/rNPV+bj6IV'
    b'iCJXlOKVNfEme8ONqHXKqPR1f+T/xAjtZzPyVuJ5rH+KW7f+Ibkur0ndvDaltJUKpKCgwNx+'
    b'pk6ditLSUsyYMQNM3UgJbNotuGSaRXJE4HJevOzxKoaFCxe2Uy+hdyKCu3ynG7Lr0MMX2TDL'
    b'T548ObmqqsrNy8szRhSNjNuaimwaBW556Vl9RS1e+rFYjDvjaZWkg427gVe99+h4UjoCZ0a4'
    b'T3kBh2l5kIKnzp8/v44LsvUN/z+SETk3mr4uE8C8efNuLV269HkCv0cHzV2eDjrkPfaO19XV'
    b'FfgPeybadAWLUx4AAAAASUVORK5CYII=')
imglib_TestOK = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAAARnQU1B'
    b'AACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAANdSURBVDhPZZJdbFRFFMf/M3O/du+u'
    b'2+12y1K6tHS70hZbpB+IxjUGFQOJWH3RNxEf5EGJD5KY+CBE4gMhGBISo8bHxmCjJipqJEYx'
    b'aJrQDwh2F6WSCpZ+uGy33e5u7957Z5x72xCjJ7kfmXN+//mfmUPwn9jS1R7ccfDJfVp3/FCB'
    b'rT4IVwSbgw3zqxOzw1OfjryfHbmcXbEqfL0cdwUCRoCmBx/oCz3dcdJJhQYs4upymfpJWaU5'
    b'1Glc0matc1MnRj76+r2Vctn1Usx76ZqmdBx6/KB5eODM8gbaY3NXJTJ8+fUtHCpoMeJEWO+G'
    b'h+JapJwfm77kuI5gMk/aB3cdCL7Sd6LkVhPMFvDYf4enxIWAcARW4Rh6d6JPvVk5V/h95m+W'
    b'7GzrbHh516nqJi1Ja4KA/h+uCQcNaggmM1CyK1KCaNHGWMGYKl9ge4+/eDjfpT3DOWeUUB9Y'
    b'8+4dAIElbGzUojja8hz2xnYgW51B3lqiasw0UnXNw9RtDWVcxW9FHriLVV7zv0yKWdzGZj2O'
    b'Yy3P49G6+3B/oBUtSgyyG2IRJ01SkQydd0vbIRdcwdGo1eGlxGPYbMRRdCpIBRJ4W8KZSCeK'
    b'1gqOTQ7hh8JVqFQBqyFMFLqThvWABnkhGlXxatM+HEkO4kjzIPZEt+MtaXvnPWkUrGUcz32M'
    b'z5ZHQXQFRFpgkqkXQYNurcR+0i3CbWn38sJ1LFllaXcbTrUdQH84hYVq0d/5y/IEDNMAlecs'
    b'eTBL8Pqi4rDG1qZ8JRXYb6kwrpRuYG45j966dkQ0E7fLd3A0N4Tz1iSCwQA8UnYqH4GGJfUG'
    b'//7maVa9vTjXtjXdW0qqaYUpNFu5hXkpEqUhnPzjc/xYy8E0zDXYuxo5CxporWnSfXdk6Luz'
    b'sh2B7kx/T+LN3R/Ox51+OTFU2C5MW0FJd6Bq6hosaW+YFE7Rfsu4Pnn62z25i+PT/qz/enHs'
    b'6sKZn19PzLDfdJcJqkrY5GC6Ci73lY7hcg7DodiSE7PTH1x449ovE396rO/A/yGEbts98HDP'
    b's5l3ik20vxh2dSpTcl22Ley2uaAd/csd/Wb4i9emxrNXJOKDdwW8kMND7+3p2vTI/ideiHck'
    b'n1osLIbKwpqpN8LXNhaNseGzn3x1aXz0znq5DOAf6b1vaBJvoBAAAAAASUVORK5CYII=')
imglib_TestPause = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAAARnQU1B'
    b'AACxjwv8YQUAAAAJcEhZcwAADsIAAA7CARUoSoAAAAKgSURBVDhPjZJdSBRRFMfPvXdm13F0'
    b'0F01FC0/UrOwNTTY9MkyEoXqJQLzpVAhonzyxScpqjcpIhD6kh6CKLAP8CESI3ooksIFN1zF'
    b'LbfcFNfa1V1Hdz46d0bUQqEf3Jk5/znn3HvPOQT+oefwjDjgju1JWzarpSK1kPiopklCZDFN'
    b'C56dTP1409uxEOgbNtfcYT3Bs33fxb5yf32Y7WrFv3Uo5eEScXFnA9eSwwBfti7euDghvWwa'
    b'y+WaneD5gTB7mBtvnpT1O+idw7XtwIBgnsraO6eV4cbRHIMVXW2GKbWoadqp9GJwQaZCiLcy'
    b'DRKqBvFl+6SMAewtcUDBDhEiUS0jSs2Gz+7Qh6D//jS5Vh+Sn7gTT3UCjdz5zd1iyFQEWE0a'
    b'cPDMpJXgXX8JSE4CjBI41xOCT19Uk5rQf3xePk8HXIlaDK6xPJF0GbdDCNmor+SkIDBqaYos'
    b'cIkYBI69yprz0pRVkxdL5ioHN/lf3NJKahk1c7RUNOxtN2Ha17fQ9U3GBsTI0kW6uCSE0UjY'
    b'2tbwu28BMVNUkVJmfkVj3tbspnM2lQAIXfv4G9MBAhZTp7NoLNgaTow1HvjX2PLY6whi8qcr'
    b'O+KnLa0TUcX1O4SaFcHbx1HX3pxfMQ00rENSMyAW1ywJD3i5yjP+luw8VUOO5l45MhIuvo0Z'
    b'Svkgecpk8E8lYG7BTsIHqarcabXRF1B1YIl7Ofnfugavn4xZN33NArS3Abw/FJOPcgVK2zVT'
    b'z3DNjx4qf99yov34eG166YbjiDJDb10aqgtGKjqXolK1lhTcKDtx4cbGChOSYwWFvseFcnzw'
    b'Qu/pQFkkw0QYwcf61O1vb4Durm750QO9YjaUVyw61GynxESBGZHdlS+GPCQ/3NHWZtUK4zAI'
    b'PH8A9T/3rUKrulYAAAAASUVORK5CYII=')
imglib_TestRunning = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAAARnQU1B'
    b'AACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAK2SURBVDhPdZJtSFNRGMefc+692653'
    b'Ldl0oSVqqUvClzBo6idLTBTsgx8CsSBQQaLsSx+yAgkKChLDCEHQEirKwF6gIhJJIpKicKCg'
    b'Gy1cOU1nmnPObfeezrn3OlHpBw/3nv95Xs7znINgC21HpoUB29/95lVSJGaGM5ALx2IiH1g2'
    b'x7ynPQmfbzubFia7hojuDvEEzw78FLoc42V+Lr2e7pZSKZWaQI05K9SCBgVcybLQcdYtvqwa'
    b'S2GaluD5QT/Xl7JS7ZHkbuptZ9r/oAHe1DDX2DJlGaoctStc5rVq+B7OrJoyWtppcNrokxxU'
    b'UWyGEVcIFoNqkU0YBEhcwqT8m8034h3vmULXy3xSvy30VEZQyRxoAiBEa9HlDsOpyz71fwsE'
    b'E7hXMy814wFrqIQGH9I34iCEID/bBB/vZ4EzL0FX4yAFwbG3Sb+d2BQhbFiSpm+GJZFEDHcv'
    b'7YYrTXbgsL6hYRPXEnIwscdYek7TNPQO1FaYcRhB7dGd8L5nH7D56CAlSRbwcpD300VI0zRY'
    b'PAtkJ2DGYF8zPU2hQ1TXFERMYQFjjvygi3lN06AF44HryAqBR28WoeNB3JUYgKfDlPEsXSxo'
    b'2nbYSWYDUTh/cxpu9M5BJKr1xwvRGWtyYBzX1buXLNZFdld65xvVI1EFLnbOQEWzF4a/rqia'
    b'zh/qcbWwYGIY3+lrW3UYF7qo4KYbapKYTOBW3xwcPumB1x+WmRSHPiTZYAr170r39LfWNkfU'
    b'Uu+4SdxeDs5fFtJN32oum5/qvR050To/Wuz4VHe8sWaiZEf2huMXyzTuPDdY6g3ktgSXxKJY'
    b'lLdR2UiNdqSscXx0LC3D9ThDWnl1pv3EZE4gkY6HcGj9uhj5jeXQeqFVetgr5876UvcKhnCy'
    b'UeQEnlMCWXkvBgvQHn9TQ4PaJo2jQVDwDx2RCGjtTnZ8AAAAAElFTkSuQmCC')
imglib_TestWarning = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAAARnQU1B'
    b'AACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAHiSURBVDhPpVE9aFRBEN7Zu/cwvhBB'
    b'sNDmYplLkyKFNkllKQE7IVYWgmAjKBECJwlopyRY2CiIjSCCjVikMMTEYBoLKxO8O/wjSvBO'
    b'397u3fnejLObvb9cENEPhvd2fr6Z+QaISPwPJACI/axuTE69uVJR69NLRtdCn98H6b89MMaE'
    b'aWVjBtTjQxJXJ3H76aQl3Q99BFwMhMk5Kt84DwGXZWUgPt9e1D+/RT7lz2CCo/HW/Y9qNWfF'
    b'caZeDWP89nrBkbNm3dYzASdIbFYuii8Lx7iz9woBVqnvDy+jKo7sXaWHgDnzWF68IIMfcu/G'
    b'EKZDWLp5V2t9wLsc2gTcPYPxu2tQeXQEnLdzXhaFL8PJZuUE7ixPdU/RJuB98vR+fkqGv/jh'
    b'rY3EvSFIAyrPz2pVHfKBXQLuPpB+fbYA9ZWIqCkENgWxtUDY2PVxDGhrNP1w76qpGzcGOOES'
    b'fQk3Jm5lsp+km7UPdh3vZ+XTRlST42uno8PHX9gJzmDxTkFSSYqUR014dG8HJ6rOKOnyc47M'
    b'VCPcnHtgjM5BbWdT4euTEYS61cPB9hw8Zdy/WhroiVlQgz1jz5chfjlNED+xt/ahvwSvgtlx'
    b'rl07S6DW7a18pEXUOWMHNtbRg7LDXMZM/w4hfgNUsftrptDo2QAAAABJRU5ErkJggg==')
imglib_UserEngineer = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAARnQU1B'
    b'AACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAUuSURBVFhHrZZbTBRXGMe/mdlZmN1l'
    b'F3ARKSsUCxTWBRrEuohipA+2TXmptMY+mAZj0vT61Nj0YmPa+GD0xZI+1NimTUvrAzXZSqu1'
    b'Ikq5JFwMMaBWYLlskcvCXmCXvc1Mz5w9IrPLulD2l0zO+b5z5vv+c75zZoYSRREeQVEU6cWm'
    b'v7OFGx7oq+i+2QyueTvk5Bth70uvQb6poifT8PQSmRaTlfkk1izgWtN3upHB228PDfQd8S95'
    b'inxLHhB4ARSsEji1BtQpurHcQlMzw7Bf1B8/PUVui+J/CWi1NO5v/e2nBtvIPWNkgEh06Rnu'
    b'wtKdH751ouEb4pKxbgGXvj2r6++88efE8ODzxBUXbZreY9pZXXv0ozM3iGuZSAE0aWPy4E7P'
    b'u7aRuzi5QsEATa9+C8sqgGHCY26HXT0+NHip/WpTKnY8gbgr8M4rpRafd7E2JUUF9fUHweFw'
    b'Q1tbD4yOTuKnSU3VQnX1DjBtLwCHcwEaGy+Dy7UArDIJNLo0/ZmLHXMkFGbdJThas82iVLK1'
    b'dXUHwGQqwD6e58Fmm4K5ORcUFeWBSsVhv4TVasMiPB58IPQXWkaeKCBuCSTM5rLl5BIMw0Bu'
    b'bjaUlxtlySXy8gxQVVVOrPjEFSCtSn5+DrHWRnHxM3i/rIW4AnbtKoXsrdng8gRll9sbBEEQ'
    b'cRs5pktLhbKyIiRCQaLEJu4emO76ymLpmqwdHHeDTs0SL8D4rBeOHciD81etkJOhIl7AAow5'
    b'WnihJBUm/53R7zlydmObUBLw94C9Vpq1d7s+7EScvzIC+0oy4OadWTj24jbiBWgbsIMUZU94'
    b'rj7T/N7GN+FTmzh4OL8EviC/fKHVx0jtSr80T5q/VuKuwFTnOUuIF3EJAiGBeNGLR0FDkSEF'
    b'7tkWILjCr0R+Y64WFDSOpd9S+f7GSjDQfNKC5tRSFA00GkcNmof6KAGNWul+6eIFHrXhBIIg'
    b'4FhoXF/88mcbKwGr2oQD8nwIPWkQAoEg+P0BtBoUhKhkAE4PCq0B1JuNkJyeB6FQCM9nlBrQ'
    b'ZptIlNjEXYGZ+y3VM0Md1wU+gM9UbsUh0GYZ8dhK+IAXhtsvgH/RjiwKOE368YKaD06HRx+z'
    b'7hXY/GzNLVHkfyAmOCZugxDyEyuMKApgH+kgydE+4LQznDbja2zEYU2ngNNmNTEsWm6Ee/of'
    b'sHZ+D+6Hg+B12sA1OQDj3b/A7FA7Hpf2B0XTpwwVbyxiRxyiSjD/5anDgf47laLPR7wI9A2m'
    b'C3J2OAsYsz/r0UsHbUg0P3x/OAY77wNtn6OLHpvrRedz+WhQycmgLCvpTP/0458jSyATMPXJ'
    b'iXJ4MNQBPl8ScckQWRq8u7PBW6CT1BIvAoXgxhZAfWsCKD9PnBFwnF8sKtyddfLzPuLByErA'
    b'Li5qKD60anIJKijgJGmXraC67wTlxAKoHjgh7XcraP4ai50cQYWCSUqnS0PMZWQCVIcPWdEX'
    b'ZJ6Yq4OeVjHlwUJ0V0ZB3ToBiklU7oiljYRSq4Mp9W9G/TXLBVSaJ0SgHMRMKOKiZzzpubJu'
    b'Yi4TdQqYnK3TpJtQmMLHPzQriRIgMMwfpJtYvJ4m0pMRJSApM+OabIcniKTKygXSlRElAL3w'
    b'bbQOHbNEgv6MAt29PxJLRpQA1myeQe+YLmImBIUhm1fXvRogpowoAZp9e4O8wXCXmInBH7jO'
    b'VVVOEktGdAkQblH41c6HRGcwABu+0H+CS7/pIgkdRczPce/B16uCTueqAtcDm4r+kBvO3VNk'
    b'bZmVbPm3AOA/ptODKbiwA0cAAAAASUVORK5CYII=')
imglib_UserExpert = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAARnQU1B'
    b'AACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAl6SURBVFhHxVZrjJxVGX7Od5lvZnZn'
    b'77vd3W7vZdtlG9g2RbkJhqBAMRKJmmigUSP8wD+QEBM1RH94ITGGGCOaeEFRfhBSo4lE0Ci2'
    b'IEEuikClLdCW7m5nd2ZnZ+f+3c75fM6Z2S3b0kR/+e7ON9+c8573fc/zPu97jkiSBP9PEZ3v'
    b'dVJthANBqB6NgFv1byGwrFTysiNEwbGcnziO/Xxvl4iNckfKNeXEsfx4DHmTsMTdUAkiaaNQ'
    b'CeG4stWXFru2jORmO+prYnW+zxeplBrrvIPOByzL+mginDtCmRyuB/4TsyuB05nG6eXAaYT+'
    b'XyTEISHsu6kPSWD9SKHuR0iU/aRlId9RXyfvi4CWck3u8WX8uklRouNcVeVvkWhUjgkhmnqE'
    b'wWa5l91I3msuQb4cohnFp13Ln7xycpSAXigXQwB0fqrzep7QiY4pSXbT8T790e/rnQMBE1Tj'
    b'I+XYy5tHhtKd4Qtk3aqlajMVS/vTjOsgPUwpgQnt7EKgEvMnOuPt9/V7KTdjFGoSLtFKlJyT'
    b'cJ4eyqlXejPe45uGvOWO2jnLxeXm7UqI78SJmBSwO6P/uzAtGh2SiB8SQSqp04DAt1AnKt1O'
    b'stiXTd2zc8L7jdHXj+WV6CuRTL4phbCU2YvZtglDJ4612t4htUWizGxCVmk9865n9Tid0wSS'
    b'WBLERBcC57h3ofmaIJAKCyuS847KdauDezZlHxPVhrqrFUYPy8RaY/WqcC/INEpI+cuIHBux'
    b'k4X0ehG7KV0ZdKJD5Dd36dKJ7dfhxg1gZRFOowZ/4xSi3AgDUcaexQ0ERCVfZrHKsLh1OHWv'
    b'KKzIpyIV3aSh00Q6l1kiIGP0L/4LdljhmI5PQJuSrgelA7E9g46jfFjBCizF2YTF2PShigsI'
    b'B7ahPH0lkXIRMuBaKyQ5HTQDjauN/lTwuJVY8e2ZtDOZ9ZyvWoRtzTslIYEsBiHIxkTYUDar'
    b'zU7BiX2k60V0V+bQVZ2HVy9xjAlWREZkaMI1ZkQS0I2NMI6wUI5QrgrIKD7Z48ovjvfaVyUy'
    b'c9Da0OM1RSTeUkoWTcnrx3tEZ1m63agObEdxfA8Wxwlr15gGnrqdD99rg9uR3zSNldE9qAxO'
    b'0LvX0RHwUi6GeyzYdoIwkTK27cM7x7wXLrskHZr9VhrR51qBeKRNLw2yInWAQ4/8FK38AvZf'
    b'fy0uveYG48zSJItCHPrZw6hXqib/l1y+F9ccuI0rdPp0RBJP/fyHWFgoYvvV1+PaG2406WmR'
    b'hPPLCVxLVodzzq4dY9kFq1yL+5iS7ynjuC3djTyGZl9H8d1TOFUsISICCR2vVQdJ2AhjzOYL'
    b'mKUTQU6s5k5pDggXDW8ApwsriN4+juH8UbhhFZ7rYKTfJhFFz3JTfVvrW1LgU6GMBzSQiZDI'
    b'1AvIFc8gJev4yP49uO3KaYy5AY0SE3JCkidJUMe+rRtxy1UzOHD1PkxkWQ10rPQc9yHiAJOp'
    b'Jj42sw0zu0fh+mUM5o+T1D5yjkKPxyACdceJhdYHRX4leIx5/yxjMTXeU8kjWz5tdiN1z+9w'
    b'ws+NIs5sIOINZKpFuFGdPgPOEHY7jSDbD79rEDwJkcq/jfTsW0CmGxgeYNraja08vg+h66IV'
    b'25grSfSkox/o1AyazkeyKMLc9HJIbIdQavYzAF28LMFsNY9c4Q30lt6BFzH3TNnS8VNoFJeo'
    b'o5BpFtBXPI6ehaPIRDU2Kq6ziFqHqSF7SJPOdbtJESke7eyQ1iTVmNn2JrlbgTDdi6WRKdR7'
    b'NqHRv41u7DaxuItzXYJdUQfnuVg6M0fYtQEiaIy05wXJGae6UR/YiurgRpRGdyEg53ULiNlF'
    b'BYPT5UlLbe9CJEWOVzTRYq8HzZGdaPWOc8alyjmCasjDegNRq4m+iQ3YeNkUgnoNcSswlkzL'
    b'5psOVTE1TW6ikduKWuxinh1wruRX8qWwSA4TBfaLxZVwiF3Q46cmEnm/H6oHLKZAd0bblq3+'
    b'uaNpx6+YzZkewSjnX3sDfnlJ3wOMHi8r6Nu6EwObN2qeIqmssLZLkGOTbxcvuSqwLDV9thyg'
    b'7CcYzqp7ujLe71t+eGMcyHljeFVqjfDeZpA8xBMRjm29ls3gQNfyO3eKhbNfo/duHYDuFW1S'
    b'8b0TgDmANJasc6gYVoHBRY2/Wxtnbl3avXe00Ywfny9F01RrTAylL9sylDrZ9miSeU6E6/7S'
    b'cuxjtqXClCM/n/OceWts14Oqb+S+MJ07Jh3vhGV5SzxJWCJ0xNToXLO/gs2ezYZGaj4ikf6D'
    b'2Dp5v3XFB0ojOfdooaK+HPOwyqadR9/rXMs6BLQUVuKMYycDAzl3vjO0TtTKmd7g2SOnUkr2'
    b'd4aMRI73W2dq6j6RTsHqHZoXXcNrV7AXT9Ud6j/Q3S0e3Lmhp9UZNnJBABeTL737Uma2Xru5'
    b'kXU+cagYfKZXSXN86yrR8pwXnb0zp767PXCf/ev0Ta+Ywf9CLhpA5uivxZjKXi4T9zpl2bdH'
    b'ibiCW8pGzPHrBWBCReaIPdnyjf6TXR6+NZYxHaXLtptZ23p5UFhHdqezR671Mq9+YXTvklE8'
    b'T943gFvyz2//R6n0R18lO0yfoJYm4Gof+PeTxzHK63aRV62vz82ZNaenx/Hcgf1wdEsm20y/'
    b'0GtYFttc981/7r75UqN4nqwj4ap8v++KhU2pDCu1c/zwYQzqJtMu9tXHmmgC2rw3GE2ts9rd'
    b'GH2Xk/pd+8eFsmblqaA0+ULh5IcW4hZ8ltmSkAefqdSu82gn5kF08AwPlJZAfxzirhMlZAh/'
    b'MYrWEGj09eDk1CiUa6G0oReLW8bM2aLvUHdu2PL8clCfq9KWJ60/p5H+xa92zIR6nQhY338q'
    b'vTv2jF84vCjDMd1iYxqxYoXDjTr7Ne8GToKXnj6BLRUSmM3bJjK8W6wLQFMxJp76UvXW3s14'
    b'6cOXmzvgpnQaM+ku3i8SHAsCnA4D7Pe6Xv1k7+ar7xrZ0rLYAuuvyuqPzspgzPR8m6cZS5u9'
    b'EONOO/8We7Zg7es0+AysSiLq265BvCOR9sYBxQUJu5L+JhUw4TiI2Sv0qbqL71ly5EW/NvOa'
    b'qn1DrzMcqMpoUt/dNMV0DNqpjrhbpPlOQ2zNuvspaj+Un8WP5/MIeZhYWrEjlj6czGLdLQ1Q'
    b'5jru6a3oY51rHdro4qUkZmr+VprnHaQTQEOG2vU5oZ0a2+qbQYMBaKP6n4Z5lNYiGyXe+6us'
    b'ySWicVHhOp/BHOVVnVlsc5JONI91jTT0BQfAfwC7mrge5EO7GAAAAABJRU5ErkJggg==')
imglib_UserOperator = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAAB4AAAAgCAYAAAAFQMh/AAAAAXNSR0IArs4c6QAAAARnQU1B'
    b'AACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAAYdEVYdFNvZnR3YXJlAHBhaW50Lm5l'
    b'dCA0LjAuOWwzfk4AAAXpSURBVFhHnVYLUFRVGN4sGitryslm7DEkLAqIIiIPWUAei6YCMixs'
    b'u6yCsEAoiRgiKUhQBiISIQukqIgiYAgOMKE4Gj6QfICMZuJYjZrvJwSC8tq//5zuvVyXy7r6'
    b'zXxz7957/u87//+fc+6K+ACAV3TJvHoG+HwUcx1dlBHvmRrhU7hK6bItQeW6MzXKt2HdUv+m'
    b'TWvUFXVlP80eSeOl0Xnr1rjUSJ+GCKnZgNrDBIQY6TXxSVyg0wo2CaQRE85laaTVat8gV/Kb'
    b'ecW+e5X5yaGjo+O93KTIw+GepoKGfIZLzbrTov0TUWe0rv5zgYNHIV+n983NRhnL5RWGmHL0'
    b'NNVuXLmwoBljqaAuyGx0SZ5jNcay97lJUd4o1E8El/taQVFyABgyCSz7wKHqksVEw2Cg6Wvs'
    b'NT1GfooILZ1rDpfr0+DG8WxYKZsmaKbLtGhZI5uAIMhLoQGY+fh4heRJ1JyJcKhwGdw9mUv5'
    b'67blED3PQtCMz/jPJX2o8Qkjpx/MJOgCw6AP1B6mHZq4+Zwpyz3rF0GEVH/JSUtQw4kKvwgw'
    b'aFKYu8lgXV7UMOPbTTlwrPgrSI90w+zNBY0JUWMmI6cf/JJj0EcY3HOgYOkwY5Z3fsuFWyd+'
    b'xP6nQ8veJFx8gfDl/KE2IKZRMaaUIzecB1LqMI8JXfqMhdhW9x1djGEeJoOoMZmR0w+cFD0e'
    b'CTBoPJa6+0WNCckaIG1CDTEjNwQ2e34FdIzNSPDLGJOyY8Y9qPEhI2cYyGQw6GPS4/35SwTF'
    b'9bFlbyIxfog6YzhBkhVz5e7pSx2gsSnpU8WGYEFxfSQrHtdHP2qMZeQMBwaJifHGaK9hwvdO'
    b'5cP95q3w4OwOeHhuNzz6oxIeXazi3penLyQZd6HG21SMl6lg5nxikKPa3WQgQiqG89UpVPDR'
    b'hQoY6O2Ewb4e0A70gnawH3Cz0vuH50vpmJuN2RDjM5muatR5nxqnpKQoAwICqhQKeW1ISHCT'
    b'XC6vDQpS1pN7pVJ5MDAwoFImk5Xjff3q1QkP2P2YHTMH9+wmKvzvXwdB2/8UNf/HYP8TaG+r'
    b'5rLdvU7JP0DGUePQ0NAVzs4SMIS2ttM5AXL8kf3JipPydl4/DZ1XG7HcRdzz32tS4YvZZjQG'
    b'e0zO6neo8dq1ax1cXV16hYz4tLe3A2tra5A5T+TMVwVOp/vzn6NZnBFLUl5ytCYvmsmNx1J3'
    b'cxm3tra+6+7ufl3IjKVE4kRNCaUOVhAitYRQ5JK5FhC7YApsjJZyPSdHJvlckg9JnL81HRPm'
    b'ZUljgj0tn16+9sCrgXxmsSWjFArFPiFDljNm2HLGVo6fgamqDKTLSuDvo5phmery6nENhCTt'
    b'xJhySvNFpV2KNRVZdFUnJMSHCxkSOjnN5EwJp9rYgVi+FcwWlsP3Odvg9P58Kk4y5RvePJEL'
    b'fx7RQPGOLWC1uIwzNg0qBQtZzg1iPPrSpUvmLi7OfULGdnYznjEmnDQviRMiE5BE7QbZql2g'
    b'Ti6GiG+KQbl6J8yJKYGpoTxDhiaKEnAJ23yBGI8hDVepVHd0Tfm95XOyq2KYoKE0ke8At/At'
    b'laLex/emd10/WXuuPle7PXMZhAb5csa2tkO95XOKrQSC12wH2/BSQXF9/NR/s1aVWKEUdV1r'
    b'+oXfm7b6DSD1nAWOjg6CpiwP7UqElgP5YBkyvJz6aOyb2/V11gGxqL2tppFvTP7CeM/1BBsb'
    b'G0FDltnJYXR8OPZUyGAkiv1yrsRl1r8l6rxyLPHuqYJ+1vj4zyng4vzsShaiWuUDt3El87eK'
    b'IRT7/tCAoPv4zZ77bar2i1UlmclR7e5uLs/NllDi5ACZOXkgFhAfkUFlYO6XlUxPLhY4AaPY'
    b'2Nijz+stnxO8N/QZ++U9NV6g6UX2GftqBujVT9NtvCDvMbIHf+OzvEFk1wTvrMfq1EovxnII'
    b'Go0mw5BsGfaW7jsYW1h1xr5gT5N9UfUZya6aFs8tlScd1xcesfg2//CkzK0NVsU1Z2cV1ba6'
    b'JebUmWZsP2JGKiwSiUT/AZVMNF5LdvKVAAAAAElFTkSuQmCC')
imglib_UserTechnician = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAAAAXNSR0IArs4c6QAAAARnQU1B'
    b'AACxjwv8YQUAAAMAUExURQAAAAYNDwUJEgUJFAcPFAkOEQoMFQwOFwgOHAcRDwIRFgYWHw0Q'
    b'EwgSGxAHCRALCBEPChYODRMUDxgUDxIRExMUFBcYER0VExoYFR0ZEh8eHwcRIAYWIAUYIgsW'
    b'IggZIgkbJgkdJgsbLAofKAkdLQ4fLAweMBAXIREaJBEdJhwhHgkiLAUtOAwhMAsmOgwpNQko'
    b'OgopPAktPQwsOQ4uPhQhLxgjKhkjLBAjMBAhNxAkNRAnOREqPRQoPCMfGCUeGSQcHT0qHz4s'
    b'HCQiIiQjJS4rLS0xMS4xNSw0NzY2NjE3OjQ3OT45NwkuQgcyRgU1SwsyQws2Qwo1RQkzSg04'
    b'RQk7SwY7UQk/Vws9WBEsQhE0Tx4yRBwySxA0UBQ2URI4UhQ4VhM9WRM9XRc9Xxk+XDo8QAdB'
    b'VAhDWgpGWwhEXAtHYg1GYg9OcQtQbA1WbQ9YdwxZeA1deg5efhdCYBVGYBZHbhFJYhRKahhJ'
    b'bRtNchlOdRxOchhPeBJVcRVUchFcfRtQdhlReRlRfR1Seh1RfAxgfhBhfyBLb0Q/PUw/MlA7'
    b'KlI+Kk5ANWpSNmpRO25TPHFQNVBQUVJTVFVWVFZYV1ZYWlhVU1lSWV1hYH5fQmBeYnpkR39g'
    b'RGJgY2VpaWlpaG5qaHJzc3V6fHh1dn93eXt8ewpegQ1egQ5dhRBdgBBehRRfgBxXihlcgR5Z'
    b'hRxbiR1djx5fkApggAphhA1ggB9hkR5hlB9nniBdjCBikiRmmiJpnSFroiNupiRzqyV3tCZ5'
    b'tiZ5uCd+vSp3sip4s3d6gimDyimFyyuIzSuK0SyN1SyP2C2R2S6T3S6U3y+V4IJgQoViQoNk'
    b'SYNtTYxsTpF1TZVzTJtyTZxyTYR8f6yCWK2FWraJXbiPXrqNYM2aaNGeauCqceOsdOStdOiw'
    b'duqyeOyzePO5fYKChYmMjZCLiZCSkpKVlpSUlZqWl6GeoaCgnq6trbCxsLq1trm5uPm+gMLA'
    b'vvzAgsjHxsvLyc3Ozc/Q0NXV1dza293d3AAAAH4vHUAAAAEAdFJOU///////////////////'
    b'////////////////////////////////////////////////////////////////////////'
    b'////////////////////////////////////////////////////////////////////////'
    b'////////////////////////////////////////////////////////////////////////'
    b'////////////////////////////////////////////////////////////////////////'
    b'/////////////////////////////////wBT9wclAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAA'
    b'GHRFWHRTb2Z0d2FyZQBwYWludC5uZXQgNC4wLjlsM35OAAAClklEQVQ4T03SB1DTYBwF8KjU'
    b'gRP3QBC3VqAtuFHcioqDguLeExd1oCJEwCjugYBbcZDGiRUHViNuyvrjwoHiQMCtKCWgaP2S'
    b'fmnzrr303vsluWtCmKz5cyyyaft2HSOP/8YFHwmI6n7+fhpkpt671GsXrlCsYOhpsCRhMC4l'
    b'YN8aPAo5F4NrC/jXNgNvQjLa/MWDCL5FANxKCJ46ecrStddTAcI/4UEEh1evbOnYacy8gIA5'
    b'I53tPc5G7MGDCKIq+S5KZGjmzCkmXhO40KfiTjyIoFaNEHrxXHcnW9sW7vOXnAytUhsPImj0'
    b'qLJN483Zrwvy32RvalhNtr8JHkRQ/7FdnpHDMb61e9IADyL4GVvPsnNcYd3YIjyIwGTyNHKE'
    b'eSa4wj64lIIBeeaZz7v+uJSCQ0/xivLsIC6loLx3Pro6Csfle1ofuBWYvvTDN8nr+xFXKBJg'
    b'OmG3PedVbs7WOndxwUcKPmzLfZi1N+vljue44GMBP6K7zvQq4O/wfsiMLtHfcY1B8W6ZDD3v'
    b'21vQn2XceAfgSgWbmGJh4kHpLAenULUevSdXD3Dcg4voh14V0spxeKkZlHVOZuW0Ool/kza8'
    b'yAnmj3oV7comdygTwLCbwMq1vgLInDhBePX03rQLCze8eFAyCYB11o7mrwyQniIc0BWULMD4'
    b'EgTiLiPQTetjBjgIuCFw7QgCgwwA63ow6iBWklXe8a7hAIaBCDgABLcOIpeplEqliwJ9XBUK'
    b'Rc8VzAL5cgAHE1HuAelVA8f6+ZM6HU1SOlpDoQT6+80mm6XBuHLi13RIqbl+hJuaZDTmkCT6'
    b'jkJFcwNMKyK+hiFA0YyWNgO0olxIpLUaewOEfSaOJvGA0lGUsKDTdRRSFEnS1Q2gj/sPmWb/'
    b'Vjaz0JwAAAAASUVORK5CYII=')
imglib_user_female_32 = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAAB4AAAAgCAYAAAAFQMh/AAAAAXNSR0IArs4c6QAAAARnQU1B'
    b'AACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAAYdEVYdFNvZnR3YXJlAHBhaW50Lm5l'
    b'dCA0LjAuOWwzfk4AAAXpSURBVFhHnVYLUFRVGN4sGitryslm7DEkLAqIIiIPWUAei6YCMixs'
    b'u6yCsEAoiRgiKUhQBiISIQukqIgiYAgOMKE4Gj6QfICMZuJYjZrvJwSC8tq//5zuvVyXy7r6'
    b'zXxz7957/u87//+fc+6K+ACAV3TJvHoG+HwUcx1dlBHvmRrhU7hK6bItQeW6MzXKt2HdUv+m'
    b'TWvUFXVlP80eSeOl0Xnr1rjUSJ+GCKnZgNrDBIQY6TXxSVyg0wo2CaQRE85laaTVat8gV/Kb'
    b'ecW+e5X5yaGjo+O93KTIw+GepoKGfIZLzbrTov0TUWe0rv5zgYNHIV+n983NRhnL5RWGmHL0'
    b'NNVuXLmwoBljqaAuyGx0SZ5jNcay97lJUd4o1E8El/taQVFyABgyCSz7wKHqksVEw2Cg6Wvs'
    b'NT1GfooILZ1rDpfr0+DG8WxYKZsmaKbLtGhZI5uAIMhLoQGY+fh4heRJ1JyJcKhwGdw9mUv5'
    b'67blED3PQtCMz/jPJX2o8Qkjpx/MJOgCw6AP1B6mHZq4+Zwpyz3rF0GEVH/JSUtQw4kKvwgw'
    b'aFKYu8lgXV7UMOPbTTlwrPgrSI90w+zNBY0JUWMmI6cf/JJj0EcY3HOgYOkwY5Z3fsuFWyd+'
    b'xP6nQ8veJFx8gfDl/KE2IKZRMaaUIzecB1LqMI8JXfqMhdhW9x1djGEeJoOoMZmR0w+cFD0e'
    b'CTBoPJa6+0WNCckaIG1CDTEjNwQ2e34FdIzNSPDLGJOyY8Y9qPEhI2cYyGQw6GPS4/35SwTF'
    b'9bFlbyIxfog6YzhBkhVz5e7pSx2gsSnpU8WGYEFxfSQrHtdHP2qMZeQMBwaJifHGaK9hwvdO'
    b'5cP95q3w4OwOeHhuNzz6oxIeXazi3penLyQZd6HG21SMl6lg5nxikKPa3WQgQiqG89UpVPDR'
    b'hQoY6O2Ewb4e0A70gnawH3Cz0vuH50vpmJuN2RDjM5muatR5nxqnpKQoAwICqhQKeW1ISHCT'
    b'XC6vDQpS1pN7pVJ5MDAwoFImk5Xjff3q1QkP2P2YHTMH9+wmKvzvXwdB2/8UNf/HYP8TaG+r'
    b'5rLdvU7JP0DGUePQ0NAVzs4SMIS2ttM5AXL8kf3JipPydl4/DZ1XG7HcRdzz32tS4YvZZjQG'
    b'e0zO6neo8dq1ax1cXV16hYz4tLe3A2tra5A5T+TMVwVOp/vzn6NZnBFLUl5ytCYvmsmNx1J3'
    b'cxm3tra+6+7ufl3IjKVE4kRNCaUOVhAitYRQ5JK5FhC7YApsjJZyPSdHJvlckg9JnL81HRPm'
    b'ZUljgj0tn16+9sCrgXxmsSWjFArFPiFDljNm2HLGVo6fgamqDKTLSuDvo5phmery6nENhCTt'
    b'xJhySvNFpV2KNRVZdFUnJMSHCxkSOjnN5EwJp9rYgVi+FcwWlsP3Odvg9P58Kk4y5RvePJEL'
    b'fx7RQPGOLWC1uIwzNg0qBQtZzg1iPPrSpUvmLi7OfULGdnYznjEmnDQviRMiE5BE7QbZql2g'
    b'Ti6GiG+KQbl6J8yJKYGpoTxDhiaKEnAJ23yBGI8hDVepVHd0Tfm95XOyq2KYoKE0ke8At/At'
    b'laLex/emd10/WXuuPle7PXMZhAb5csa2tkO95XOKrQSC12wH2/BSQXF9/NR/s1aVWKEUdV1r'
    b'+oXfm7b6DSD1nAWOjg6CpiwP7UqElgP5YBkyvJz6aOyb2/V11gGxqL2tppFvTP7CeM/1BBsb'
    b'G0FDltnJYXR8OPZUyGAkiv1yrsRl1r8l6rxyLPHuqYJ+1vj4zyng4vzsShaiWuUDt3El87eK'
    b'IRT7/tCAoPv4zZ77bar2i1UlmclR7e5uLs/NllDi5ACZOXkgFhAfkUFlYO6XlUxPLhY4AaPY'
    b'2Nijz+stnxO8N/QZ++U9NV6g6UX2GftqBujVT9NtvCDvMbIHf+OzvEFk1wTvrMfq1EovxnII'
    b'Go0mw5BsGfaW7jsYW1h1xr5gT5N9UfUZya6aFs8tlScd1xcesfg2//CkzK0NVsU1Z2cV1ba6'
    b'JebUmWZsP2JGKiwSiUT/AZVMNF5LdvKVAAAAAElFTkSuQmCC')
all_images = {
    'breakpoint_grey.png': imglib_breakpoint_grey,
    'breakpoint_red.png': imglib_breakpoint_red,
    'charts.png': imglib_charts,
    'controls.png': imglib_controls,
    'controls2.png': imglib_controls2,
    'cross_grey.png': imglib_cross_grey,
    'cross_red.png': imglib_cross_red,
    'Dash.png': imglib_Dash,
    'disable.png': imglib_disable,
    'exit.png': imglib_exit,
    'idle.png': imglib_idle,
    'Layout_DD.png': imglib_Layout_DD,
    'Logging.png': imglib_Logging,
    'MessageList.png': imglib_MessageList,
    'play.png': imglib_play,
    'python.png': imglib_python,
    'red_dot.png': imglib_red_dot,
    'red_square.png': imglib_red_square,
    'reset.png': imglib_reset,
    'ScriptList.png': imglib_ScriptList,
    'settings.png': imglib_settings,
    'skip.png': imglib_skip,
    'TestFail.png': imglib_TestFail,
    'TestIdle.png': imglib_TestIdle,
    'TestList.png': imglib_TestList,
    'TestOK.png': imglib_TestOK,
    'TestPause.png': imglib_TestPause,
    'TestRunning.png': imglib_TestRunning,
    'TestWarning.png': imglib_TestWarning,
    'UserEngineer.png': imglib_UserEngineer,
    'UserExpert.png': imglib_UserExpert,
    'UserOperator.png': imglib_UserOperator,
    'UserTechnician.png': imglib_UserTechnician,
    'user_female_32.png': imglib_user_female_32,
    }
class ScriptArtwork(wx.ArtProvider):
    baseDir = None
    overrides = { "wxART_QUIT":"exit.png",
                  "settings":"settings.png",
                  "user":"user_female_32.png",
                  "python":"python.png",
                  "scriptlist":"ScriptList.png",
                  "messages":"MessageList.png",
                  "logging":"Logging.png",
                  "tests":"TestList.png",
                  "charts":"charts.png",
                  "test_fail":"TestFail.png",
                  "test_pass":"TestOK.png",
                  "test_todo":"Dash.png",
                  "test_warning":"TestWarning.png",
                  "test_idle":"TestIdle.png",
                  "test_running":"TestRunning.png",
                  "test_pause":"TestPause.png",
                  "script_list":"ScriptList.png",
                  "layout_DD":"Layout_DD.png",
                  "user_operator":"UserOperator.png",
                  "user_expert":"UserExpert.png",
                  "user_engineer":"UserEngineer.png",
                  "user_technician":"UserTechnician.png",
                  "reset":"reset.png",
                  "control_panel":"controls.png",
                  "red_dot":"red_dot.png",
                  "red_square":"red_square.png",
                  "play":"play.png",
                  "skip":"skip.png",
                  "idle":"idle.png",
                  "disable":"disable.png",
                                    }
    @staticmethod
    def register():
        if ScriptArtwork.baseDir is None:
            ScriptArtwork.baseDir = os.path.join(os.path.dirname(__file__), "artwork")
            wx.ArtProvider.Push(ScriptArtwork())
    def CreateBitmap(self, _id, client, size):
        if _id in self.overrides:
            _id = self.overrides[_id]
        if _id in all_images:
            return all_images[_id].getImage().ConvertToBitmap()
        return wx.NullBitmap
ID_BTN_TESTLIST = 1000
ID_BTN_MESSAGES = 1001
ID_BTN_LOGGING = 1002
ID_BTN_SCRIPTS = 1003
ID_BTN_PYTHON = 1004
ID_BTN_CONTROLS = 1005
ID_BTN_CHARTS = 1006
class FormMain_Base ( wx.Frame ):
    def __init__( self, parent ):
        wx.Frame.__init__ ( self, parent, id = wx.ID_ANY, title = u"HappyScript - build 31.01.2024 00:42", pos = wx.DefaultPosition, size = wx.Size( 800,600 ), style = wx.DEFAULT_FRAME_STYLE|wx.TAB_TRAVERSAL )
        self.SetSizeHints( wx.DefaultSize, wx.DefaultSize )
        self.m_mgr = wx.aui.AuiManager()
        self.m_mgr.SetManagedWindow( self )
        self.m_mgr.SetFlags(wx.aui.AUI_MGR_ALLOW_FLOATING|wx.aui.AUI_MGR_RECTANGLE_HINT|wx.aui.AUI_MGR_TRANSPARENT_HINT)
        self.m_guiTimer = wx.Timer()
        self.m_guiTimer.SetOwner( self, wx.ID_ANY )
        self.m_mnuToolbar = wx.aui.AuiToolBar( self, wx.ID_ANY, wx.DefaultPosition, wx.DefaultSize, wx.aui.AUI_TB_TEXT )
        self.m_mnuToolbar.SetForegroundColour( wx.SystemSettings.GetColour( wx.SYS_COLOUR_WINDOW ) )
        self.m_mnuToolbar.SetBackgroundColour( wx.SystemSettings.GetColour( wx.SYS_COLOUR_WINDOW ) )
        self.m_btnLayout = self.m_mnuToolbar.AddTool( wx.ID_ANY, u"User", wx.ArtProvider.GetBitmap( "layout_DD",  ), wx.NullBitmap, wx.ITEM_NORMAL, wx.EmptyString, wx.EmptyString, None )
        self.m_mnuToolbar.AddSeparator()
        self.m_btnTestList = self.m_mnuToolbar.AddTool( ID_BTN_TESTLIST, u"Tests", wx.ArtProvider.GetBitmap( "tests",  ), wx.NullBitmap, wx.ITEM_NORMAL, wx.EmptyString, wx.EmptyString, None )
        self.m_btnMessages = self.m_mnuToolbar.AddTool( ID_BTN_MESSAGES, u"Messages", wx.ArtProvider.GetBitmap( "messages",  ), wx.NullBitmap, wx.ITEM_NORMAL, wx.EmptyString, wx.EmptyString, None )
        self.m_btnLogging = self.m_mnuToolbar.AddTool( ID_BTN_LOGGING, u"Logging", wx.ArtProvider.GetBitmap( "logging",  ), wx.NullBitmap, wx.ITEM_NORMAL, wx.EmptyString, wx.EmptyString, None )
        self.m_btnScripts = self.m_mnuToolbar.AddTool( ID_BTN_SCRIPTS, u"Scripts", wx.ArtProvider.GetBitmap( "script_list",  ), wx.NullBitmap, wx.ITEM_NORMAL, wx.EmptyString, wx.EmptyString, None )
        self.m_btnPython = self.m_mnuToolbar.AddTool( ID_BTN_PYTHON, u"Python", wx.ArtProvider.GetBitmap( "python",  ), wx.NullBitmap, wx.ITEM_NORMAL, wx.EmptyString, wx.EmptyString, None )
        self.m_btnControls = self.m_mnuToolbar.AddTool( ID_BTN_CONTROLS, u"Controls", wx.ArtProvider.GetBitmap( "control_panel",  ), wx.NullBitmap, wx.ITEM_NORMAL, wx.EmptyString, wx.EmptyString, None )
        self.m_btnCharts = self.m_mnuToolbar.AddTool( ID_BTN_CHARTS, u"Charts", wx.ArtProvider.GetBitmap( "charts",  ), wx.NullBitmap, wx.ITEM_NORMAL, wx.EmptyString, wx.EmptyString, None )
        self.m_mnuToolbar.AddSeparator()
        self.m_btnExit = self.m_mnuToolbar.AddTool( wx.ID_ANY, u"Exit", wx.ArtProvider.GetBitmap( wx.ART_QUIT,  ), wx.NullBitmap, wx.ITEM_NORMAL, wx.EmptyString, wx.EmptyString, None )
        self.m_mnuToolbar.Realize()
        self.m_mgr.AddPane( self.m_mnuToolbar, wx.aui.AuiPaneInfo().Name( u"dfasdf" ).Top().Caption( u"ZXcZXcZXcZXC" ).CaptionVisible( False ).CloseButton( False ).PaneBorder( False ).Movable( False ).Dock().Resizable().FloatingSize( wx.DefaultSize ).BottomDockable( False ).TopDockable( False ).LeftDockable( False ).RightDockable( False ).Floatable( False ).Layer( 3 ) )
        self.m_statusBar1 = self.CreateStatusBar( 1, wx.STB_SIZEGRIP, wx.ID_ANY )
        self.m_mnuLayout = wx.Menu()
        self.m_mniLayoutOperator = wx.MenuItem( self.m_mnuLayout, wx.ID_ANY, u"Operator", wx.EmptyString, wx.ITEM_NORMAL )
        self.m_mniLayoutOperator.SetBitmap( wx.ArtProvider.GetBitmap( "user_operator",  ) )
        self.m_mnuLayout.Append( self.m_mniLayoutOperator )
        self.m_mniLayoutTechnician = wx.MenuItem( self.m_mnuLayout, wx.ID_ANY, u"Technician", wx.EmptyString, wx.ITEM_NORMAL )
        self.m_mniLayoutTechnician.SetBitmap( wx.ArtProvider.GetBitmap( "user_technician",  ) )
        self.m_mnuLayout.Append( self.m_mniLayoutTechnician )
        self.m_mniLayoutEngineer = wx.MenuItem( self.m_mnuLayout, wx.ID_ANY, u"Engineer", wx.EmptyString, wx.ITEM_NORMAL )
        self.m_mniLayoutEngineer.SetBitmap( wx.ArtProvider.GetBitmap( "user_engineer",  ) )
        self.m_mnuLayout.Append( self.m_mniLayoutEngineer )
        self.m_mniLayoutExpert = wx.MenuItem( self.m_mnuLayout, wx.ID_ANY, u"Expert", wx.EmptyString, wx.ITEM_NORMAL )
        self.m_mniLayoutExpert.SetBitmap( wx.ArtProvider.GetBitmap( "user_expert",  ) )
        self.m_mnuLayout.Append( self.m_mniLayoutExpert )
        self.m_mnuLayout.AppendSeparator()
        self.m_mniLayoutReset = wx.MenuItem( self.m_mnuLayout, wx.ID_ANY, u"Reset to default", wx.EmptyString, wx.ITEM_NORMAL )
        self.m_mniLayoutReset.SetBitmap( wx.ArtProvider.GetBitmap( "reset",  ) )
        self.m_mnuLayout.Append( self.m_mniLayoutReset )
        self.m_mniLayoutReset.Enable( False )
        self.m_mgr.Update()
        self.Centre( wx.BOTH )
        self.Bind( wx.EVT_CLOSE, self.OnFormClose )
        self.Bind( wx.EVT_TIMER, self.OnGuiTimer, id=wx.ID_ANY )
        self.Bind( wx.EVT_TOOL, self.OnMnuLayoutClicked, id = self.m_btnLayout.GetId() )
        self.Bind( wx.EVT_TOOL, self.OnBtnTestList, id = self.m_btnTestList.GetId() )
        self.Bind( wx.EVT_TOOL, self.OnBtnMessages, id = self.m_btnMessages.GetId() )
        self.Bind( wx.EVT_TOOL, self.OnBtnLogging, id = self.m_btnLogging.GetId() )
        self.Bind( wx.EVT_TOOL, self.OnBtnScripts, id = self.m_btnScripts.GetId() )
        self.Bind( wx.EVT_TOOL, self.OnBtnPython, id = self.m_btnPython.GetId() )
        self.Bind( wx.EVT_TOOL, self.OnBtnControls, id = self.m_btnControls.GetId() )
        self.Bind( wx.EVT_TOOL, self.OnBtnCharts, id = self.m_btnCharts.GetId() )
        self.Bind( wx.EVT_TOOL, self.OnBtnExit, id = self.m_btnExit.GetId() )
        self.Bind( wx.EVT_MENU, self.OnLayoutOperator, id = self.m_mniLayoutOperator.GetId() )
        self.Bind( wx.EVT_MENU, self.OnLayoutTechnician, id = self.m_mniLayoutTechnician.GetId() )
        self.Bind( wx.EVT_MENU, self.OnLayoutEngineer, id = self.m_mniLayoutEngineer.GetId() )
        self.Bind( wx.EVT_MENU, self.OnLayoutExpert, id = self.m_mniLayoutExpert.GetId() )
        self.Bind( wx.EVT_MENU, self.OnResetLayout, id = self.m_mniLayoutReset.GetId() )
    def __del__( self ):
        self.m_mgr.UnInit()
    def OnFormClose( self, event ):
        event.Skip()
    def OnGuiTimer( self, event ):
        event.Skip()
    def OnMnuLayoutClicked( self, event ):
        event.Skip()
    def OnBtnTestList( self, event ):
        event.Skip()
    def OnBtnMessages( self, event ):
        event.Skip()
    def OnBtnLogging( self, event ):
        event.Skip()
    def OnBtnScripts( self, event ):
        event.Skip()
    def OnBtnPython( self, event ):
        event.Skip()
    def OnBtnControls( self, event ):
        event.Skip()
    def OnBtnCharts( self, event ):
        event.Skip()
    def OnBtnExit( self, event ):
        event.Skip()
    def OnLayoutOperator( self, event ):
        event.Skip()
    def OnLayoutTechnician( self, event ):
        event.Skip()
    def OnLayoutEngineer( self, event ):
        event.Skip()
    def OnLayoutExpert( self, event ):
        event.Skip()
    def OnResetLayout( self, event ):
        event.Skip()
class FormSerials_Base ( wx.Dialog ):
    def __init__( self, parent ):
        wx.Dialog.__init__ ( self, parent, id = wx.ID_ANY, title = u"Scan serial numbers", pos = wx.DefaultPosition, size = wx.Size( 400,287 ), style = wx.STAY_ON_TOP )
        self.SetSizeHints( wx.DefaultSize, wx.Size( 400,290 ) )
        bSizer10 = wx.BoxSizer( wx.VERTICAL )
        self.m_staticText8 = wx.StaticText( self, wx.ID_ANY, u"Scan serial numbers :", wx.DefaultPosition, wx.DefaultSize, 0 )
        self.m_staticText8.Wrap( -1 )
        bSizer10.Add( self.m_staticText8, 0, wx.ALL, 5 )
        gSizer1 = wx.GridSizer( 0, 2, 0, 0 )
        self.m_lblSerial1 = wx.StaticText( self, wx.ID_ANY, u"Board 1", wx.DefaultPosition, wx.DefaultSize, 0 )
        self.m_lblSerial1.Wrap( -1 )
        gSizer1.Add( self.m_lblSerial1, 2, wx.ALL|wx.EXPAND, 5 )
        self.m_txtSerial1 = wx.TextCtrl( self, wx.ID_ANY, wx.EmptyString, wx.DefaultPosition, wx.DefaultSize, wx.TE_PROCESS_ENTER )
        self.m_txtSerial1.SetForegroundColour( wx.Colour( 0, 0, 0 ) )
        gSizer1.Add( self.m_txtSerial1, 1, wx.ALL|wx.EXPAND, 5 )
        self.m_lblSerial2 = wx.StaticText( self, wx.ID_ANY, u"Board 2", wx.DefaultPosition, wx.DefaultSize, 0 )
        self.m_lblSerial2.Wrap( -1 )
        gSizer1.Add( self.m_lblSerial2, 2, wx.ALL|wx.EXPAND, 5 )
        self.m_txtSerial2 = wx.TextCtrl( self, wx.ID_ANY, wx.EmptyString, wx.DefaultPosition, wx.DefaultSize, wx.TE_PROCESS_ENTER )
        self.m_txtSerial2.SetForegroundColour( wx.Colour( 0, 0, 0 ) )
        gSizer1.Add( self.m_txtSerial2, 1, wx.ALL|wx.EXPAND, 5 )
        self.m_lblSerial3 = wx.StaticText( self, wx.ID_ANY, u"Board 3", wx.DefaultPosition, wx.DefaultSize, 0 )
        self.m_lblSerial3.Wrap( -1 )
        gSizer1.Add( self.m_lblSerial3, 2, wx.ALL|wx.EXPAND, 5 )
        self.m_txtSerial3 = wx.TextCtrl( self, wx.ID_ANY, wx.EmptyString, wx.DefaultPosition, wx.DefaultSize, wx.TE_PROCESS_ENTER )
        self.m_txtSerial3.SetForegroundColour( wx.Colour( 0, 0, 0 ) )
        gSizer1.Add( self.m_txtSerial3, 1, wx.ALL|wx.EXPAND, 5 )
        self.m_lblSerial4 = wx.StaticText( self, wx.ID_ANY, u"Board 4", wx.DefaultPosition, wx.DefaultSize, 0 )
        self.m_lblSerial4.Wrap( -1 )
        gSizer1.Add( self.m_lblSerial4, 2, wx.ALL|wx.EXPAND, 5 )
        self.m_txtSerial4 = wx.TextCtrl( self, wx.ID_ANY, wx.EmptyString, wx.DefaultPosition, wx.DefaultSize, wx.TE_PROCESS_ENTER )
        self.m_txtSerial4.SetForegroundColour( wx.Colour( 0, 0, 0 ) )
        gSizer1.Add( self.m_txtSerial4, 1, wx.ALL|wx.EXPAND, 5 )
        self.m_lblSerial5 = wx.StaticText( self, wx.ID_ANY, u"Board 5", wx.DefaultPosition, wx.DefaultSize, 0 )
        self.m_lblSerial5.Wrap( -1 )
        gSizer1.Add( self.m_lblSerial5, 2, wx.ALL|wx.EXPAND, 5 )
        self.m_txtSerial5 = wx.TextCtrl( self, wx.ID_ANY, wx.EmptyString, wx.DefaultPosition, wx.DefaultSize, wx.TE_PROCESS_ENTER )
        self.m_txtSerial5.SetForegroundColour( wx.Colour( 0, 0, 0 ) )
        gSizer1.Add( self.m_txtSerial5, 1, wx.ALL|wx.EXPAND, 5 )
        bSizer10.Add( gSizer1, 1, wx.EXPAND, 5 )
        bSizer10.Add( ( 0, 0), 1, wx.EXPAND, 5 )
        bSizer12 = wx.BoxSizer( wx.HORIZONTAL )
        self.m_btnOK = wx.Button( self, wx.ID_ANY, u"OK", wx.DefaultPosition, wx.Size( -1,40 ), 0 )
        bSizer12.Add( self.m_btnOK, 3, wx.ALL, 5 )
        bSizer12.Add( ( 0, 0), 1, wx.EXPAND, 5 )
        self.m_btnCancel = wx.Button( self, wx.ID_ANY, u"Cancel", wx.DefaultPosition, wx.Size( -1,40 ), 0 )
        bSizer12.Add( self.m_btnCancel, 2, wx.ALL, 5 )
        bSizer10.Add( bSizer12, 2, wx.EXPAND, 10 )
        self.SetSizer( bSizer10 )
        self.Layout()
        self.Centre( wx.BOTH )
        self.m_txtSerial1.Bind( wx.EVT_TEXT, self.OnText1 )
        self.m_txtSerial1.Bind( wx.EVT_TEXT_ENTER, self.OnEnter1 )
        self.m_txtSerial2.Bind( wx.EVT_TEXT, self.OnText2 )
        self.m_txtSerial2.Bind( wx.EVT_TEXT_ENTER, self.OnEnter2 )
        self.m_txtSerial3.Bind( wx.EVT_TEXT, self.OnText3 )
        self.m_txtSerial3.Bind( wx.EVT_TEXT_ENTER, self.OnEnter3 )
        self.m_txtSerial4.Bind( wx.EVT_TEXT, self.OnText4 )
        self.m_txtSerial4.Bind( wx.EVT_TEXT_ENTER, self.OnEnter4 )
        self.m_txtSerial5.Bind( wx.EVT_TEXT, self.OnText5 )
        self.m_txtSerial5.Bind( wx.EVT_TEXT_ENTER, self.OnEnter5 )
        self.m_btnOK.Bind( wx.EVT_BUTTON, self.OnBtnOK )
        self.m_btnCancel.Bind( wx.EVT_BUTTON, self.OnBtnCancel )
    def __del__( self ):
        pass
    def OnText1( self, event ):
        event.Skip()
    def OnEnter1( self, event ):
        event.Skip()
    def OnText2( self, event ):
        event.Skip()
    def OnEnter2( self, event ):
        event.Skip()
    def OnText3( self, event ):
        event.Skip()
    def OnEnter3( self, event ):
        event.Skip()
    def OnText4( self, event ):
        event.Skip()
    def OnEnter4( self, event ):
        event.Skip()
    def OnText5( self, event ):
        event.Skip()
    def OnEnter5( self, event ):
        event.Skip()
    def OnBtnOK( self, event ):
        event.Skip()
    def OnBtnCancel( self, event ):
        event.Skip()
class FormAskImage_Base ( wx.Dialog ):
    def __init__( self, parent ):
        wx.Dialog.__init__ ( self, parent, id = wx.ID_ANY, title = u"HappyScript", pos = wx.DefaultPosition, size = wx.Size( 318,338 ), style = wx.CAPTION|wx.STAY_ON_TOP )
        self.SetSizeHints( wx.DefaultSize, wx.DefaultSize )
        bSizer12 = wx.BoxSizer( wx.HORIZONTAL )
        self.m_bitmap = wx.StaticBitmap( self, wx.ID_ANY, wx.NullBitmap, wx.DefaultPosition, wx.DefaultSize, 0 )
        bSizer12.Add( self.m_bitmap, 9, wx.ALL|wx.EXPAND, 5 )
        m_sizeButtons = wx.BoxSizer( wx.VERTICAL )
        m_sizeButtons.Add( ( 0, 0), 1, wx.EXPAND, 5 )
        self.m_txtMessage = wx.StaticText( self, wx.ID_ANY, u"Message provided by script\nCould be several lines long.", wx.DefaultPosition, wx.DefaultSize, 0 )
        self.m_txtMessage.Wrap( -1 )
        m_sizeButtons.Add( self.m_txtMessage, 0, wx.ALL|wx.EXPAND, 5 )
        self.m_txtValue = wx.TextCtrl( self, wx.ID_ANY, wx.EmptyString, wx.DefaultPosition, wx.DefaultSize, 0 )
        m_sizeButtons.Add( self.m_txtValue, 0, wx.ALL|wx.EXPAND, 5 )
        self.m_btnOK = wx.Button( self, wx.ID_ANY, u"OK", wx.DefaultPosition, wx.DefaultSize, 0 )
        self.m_btnOK.SetDefault()
        self.m_btnOK.SetMinSize( wx.Size( -1,40 ) )
        m_sizeButtons.Add( self.m_btnOK, 0, wx.ALL|wx.EXPAND, 5 )
        self.m_btnNo = wx.Button( self, wx.ID_ANY, u"No", wx.DefaultPosition, wx.DefaultSize, 0 )
        self.m_btnNo.SetMinSize( wx.Size( -1,40 ) )
        m_sizeButtons.Add( self.m_btnNo, 0, wx.ALL|wx.EXPAND, 5 )
        m_sizeButtons.Add( ( 0, 0), 10, wx.EXPAND, 5 )
        self.m_btnCancel = wx.Button( self, wx.ID_ANY, u"Cancel", wx.DefaultPosition, wx.DefaultSize, 0 )
        self.m_btnCancel.SetMinSize( wx.Size( -1,40 ) )
        m_sizeButtons.Add( self.m_btnCancel, 0, wx.ALL|wx.EXPAND, 5 )
        bSizer12.Add( m_sizeButtons, 1, wx.EXPAND, 5 )
        self.SetSizer( bSizer12 )
        self.Layout()
        self.Centre( wx.BOTH )
        self.m_btnOK.Bind( wx.EVT_BUTTON, self.OnButtonOK )
        self.m_btnNo.Bind( wx.EVT_BUTTON, self.OnButtonNo )
        self.m_btnCancel.Bind( wx.EVT_BUTTON, self.OnButtonCancel )
    def __del__( self ):
        pass
    def OnButtonOK( self, event ):
        event.Skip()
    def OnButtonNo( self, event ):
        event.Skip()
    def OnButtonCancel( self, event ):
        event.Skip()
class FormAskChoice_Base ( wx.Dialog ):
    def __init__( self, parent ):
        wx.Dialog.__init__ ( self, parent, id = wx.ID_ANY, title = u"HappyScript", pos = wx.DefaultPosition, size = wx.Size( 318,227 ), style = wx.CAPTION|wx.STAY_ON_TOP )
        self.SetSizeHints( wx.DefaultSize, wx.DefaultSize )
        bSizer12 = wx.BoxSizer( wx.VERTICAL )
        self.m_txtMessage = wx.StaticText( self, wx.ID_ANY, u"Message provided by script\nCould be several lines long.", wx.DefaultPosition, wx.DefaultSize, 0 )
        self.m_txtMessage.Wrap( -1 )
        self.m_txtMessage.SetFont( wx.Font( 11, wx.FONTFAMILY_SWISS, wx.FONTSTYLE_NORMAL, wx.FONTWEIGHT_NORMAL, False, "Arial" ) )
        bSizer12.Add( self.m_txtMessage, 0, wx.ALL|wx.EXPAND, 10 )
        self.m_pnlChoices = wx.Panel( self, wx.ID_ANY, wx.DefaultPosition, wx.DefaultSize, wx.BORDER_THEME|wx.TAB_TRAVERSAL )
        bSizer12.Add( self.m_pnlChoices, 1, wx.EXPAND |wx.ALL, 15 )
        bSizer21 = wx.BoxSizer( wx.HORIZONTAL )
        self.m_btnOK = wx.Button( self, wx.ID_ANY, u"OK", wx.DefaultPosition, wx.DefaultSize, 0 )
        self.m_btnOK.SetDefault()
        self.m_btnOK.SetFont( wx.Font( 11, wx.FONTFAMILY_SWISS, wx.FONTSTYLE_NORMAL, wx.FONTWEIGHT_NORMAL, False, "Arial" ) )
        self.m_btnOK.Enable( False )
        self.m_btnOK.SetMinSize( wx.Size( -1,40 ) )
        bSizer21.Add( self.m_btnOK, 5, wx.ALL|wx.EXPAND, 10 )
        bSizer21.Add( ( 0, 0), 1, wx.EXPAND, 5 )
        self.m_btnCancel = wx.Button( self, wx.ID_ANY, u"Cancel", wx.DefaultPosition, wx.DefaultSize, 0 )
        self.m_btnCancel.SetFont( wx.Font( 11, wx.FONTFAMILY_SWISS, wx.FONTSTYLE_NORMAL, wx.FONTWEIGHT_NORMAL, False, "Arial" ) )
        self.m_btnCancel.SetMinSize( wx.Size( -1,40 ) )
        bSizer21.Add( self.m_btnCancel, 2, wx.ALL|wx.EXPAND, 10 )
        bSizer12.Add( bSizer21, 0, wx.EXPAND, 5 )
        self.SetSizer( bSizer12 )
        self.Layout()
        self.Centre( wx.BOTH )
        self.m_btnOK.Bind( wx.EVT_BUTTON, self.OnButtonOK )
        self.m_btnCancel.Bind( wx.EVT_BUTTON, self.OnButtonCancel )
    def __del__( self ):
        pass
    def OnButtonOK( self, event ):
        event.Skip()
    def OnButtonCancel( self, event ):
        event.Skip()
class FormOnTestFailure_Base ( wx.Dialog ):
    def __init__( self, parent ):
        wx.Dialog.__init__ ( self, parent, id = wx.ID_ANY, title = u"Error", pos = wx.DefaultPosition, size = wx.Size( 356,229 ), style = wx.CAPTION|wx.STAY_ON_TOP )
        self.SetSizeHints( wx.DefaultSize, wx.DefaultSize )
        self.SetForegroundColour( wx.SystemSettings.GetColour( wx.SYS_COLOUR_WINDOW ) )
        self.SetBackgroundColour( wx.Colour( 255, 206, 206 ) )
        bSizer14 = wx.BoxSizer( wx.VERTICAL )
        self.m_txtMessage = wx.StaticText( self, wx.ID_ANY, u"Test xxxx is gefaald.\nWat wil je doen ?", wx.DefaultPosition, wx.DefaultSize, 0 )
        self.m_txtMessage.Wrap( -1 )
        self.m_txtMessage.SetFont( wx.Font( 12, wx.FONTFAMILY_DEFAULT, wx.FONTSTYLE_NORMAL, wx.FONTWEIGHT_NORMAL, False, wx.EmptyString ) )
        self.m_txtMessage.SetForegroundColour( wx.Colour( 0, 0, 0 ) )
        bSizer14.Add( self.m_txtMessage, 0, wx.ALL|wx.EXPAND, 5 )
        self.m_btnRetry = wx.Button( self, wx.ID_ANY, u"Test herhalen", wx.DefaultPosition, wx.DefaultSize, 0 )
        self.m_btnRetry.SetFont( wx.Font( 12, wx.FONTFAMILY_DEFAULT, wx.FONTSTYLE_NORMAL, wx.FONTWEIGHT_NORMAL, False, wx.EmptyString ) )
        bSizer14.Add( self.m_btnRetry, 1, wx.ALL|wx.EXPAND, 5 )
        self.m_btnSkipTest = wx.Button( self, wx.ID_ANY, u"Test overslaan", wx.DefaultPosition, wx.DefaultSize, 0 )
        self.m_btnSkipTest.SetFont( wx.Font( 12, wx.FONTFAMILY_DEFAULT, wx.FONTSTYLE_NORMAL, wx.FONTWEIGHT_NORMAL, False, wx.EmptyString ) )
        bSizer14.Add( self.m_btnSkipTest, 1, wx.ALL|wx.EXPAND, 5 )
        self.m_btnStopTests = wx.Button( self, wx.ID_ANY, u"Alle testen stoppen", wx.DefaultPosition, wx.DefaultSize, 0 )
        self.m_btnStopTests.SetFont( wx.Font( 12, wx.FONTFAMILY_DEFAULT, wx.FONTSTYLE_NORMAL, wx.FONTWEIGHT_NORMAL, False, wx.EmptyString ) )
        bSizer14.Add( self.m_btnStopTests, 1, wx.ALL|wx.EXPAND, 5 )
        self.SetSizer( bSizer14 )
        self.Layout()
        self.Centre( wx.BOTH )
        self.m_btnRetry.Bind( wx.EVT_BUTTON, self.OnBtnRetry )
        self.m_btnSkipTest.Bind( wx.EVT_BUTTON, self.OnBtnSkip )
        self.m_btnStopTests.Bind( wx.EVT_BUTTON, self.OnBtnStop )
    def __del__( self ):
        pass
    def OnBtnRetry( self, event ):
        event.Skip()
    def OnBtnSkip( self, event ):
        event.Skip()
    def OnBtnStop( self, event ):
        event.Skip()
class Test_Panel ( wx.Panel ):
    def __init__( self, parent, id = wx.ID_ANY, pos = wx.DefaultPosition, size = wx.Size( 579,501 ), style = wx.TAB_TRAVERSAL, name = wx.EmptyString ):
        wx.Panel.__init__ ( self, parent, id = id, pos = pos, size = size, style = style, name = name )
        bSizer22 = wx.BoxSizer( wx.VERTICAL )
        sbSizer2 = wx.StaticBoxSizer( wx.StaticBox( self, wx.ID_ANY, u"GPIO" ), wx.VERTICAL )
        bSizer24 = wx.BoxSizer( wx.VERTICAL )
        bSizer25 = wx.BoxSizer( wx.HORIZONTAL )
        self.m_staticText14 = wx.StaticText( sbSizer2.GetStaticBox(), wx.ID_ANY, u"Red LED", wx.DefaultPosition, wx.DefaultSize, 0 )
        self.m_staticText14.Wrap( -1 )
        bSizer25.Add( self.m_staticText14, 20, wx.ALIGN_CENTER|wx.ALL, 5 )
        self.m_button24 = wx.Button( sbSizer2.GetStaticBox(), wx.ID_ANY, u"Off", wx.DefaultPosition, wx.DefaultSize, 0 )
        self.m_button24.SetMaxSize( wx.Size( 75,-1 ) )
        bSizer25.Add( self.m_button24, 1, wx.ALL, 5 )
        self.m_button25 = wx.Button( sbSizer2.GetStaticBox(), wx.ID_ANY, u"On", wx.DefaultPosition, wx.DefaultSize, 0 )
        self.m_button25.SetMaxSize( wx.Size( 75,-1 ) )
        bSizer25.Add( self.m_button25, 1, wx.ALL, 5 )
        bSizer24.Add( bSizer25, 0, wx.EXPAND, 5 )
        sbSizer2.Add( bSizer24, 0, wx.EXPAND, 5 )
        sbSizer2.Add( ( 0, 0), 1, wx.EXPAND, 5 )
        bSizer22.Add( sbSizer2, 0, wx.EXPAND, 5 )
        sbSizer3 = wx.StaticBoxSizer( wx.StaticBox( self, wx.ID_ANY, u"Basic Actions" ), wx.VERTICAL )
        bSizer26 = wx.BoxSizer( wx.VERTICAL )
        self.m_button26 = wx.Button( sbSizer3.GetStaticBox(), wx.ID_ANY, u"Enable Ethernet", wx.DefaultPosition, wx.DefaultSize, 0 )
        bSizer26.Add( self.m_button26, 0, wx.ALL, 5 )
        self.m_button27 = wx.Button( sbSizer3.GetStaticBox(), wx.ID_ANY, u"Enable video", wx.DefaultPosition, wx.DefaultSize, 0 )
        bSizer26.Add( self.m_button27, 0, wx.ALL, 5 )
        bSizer27 = wx.BoxSizer( wx.HORIZONTAL )
        self.m_staticText15 = wx.StaticText( sbSizer3.GetStaticBox(), wx.ID_ANY, u"MyLabel", wx.DefaultPosition, wx.DefaultSize, 0 )
        self.m_staticText15.Wrap( -1 )
        bSizer27.Add( self.m_staticText15, 0, wx.ALIGN_CENTER|wx.ALL, 5 )
        self.m_button28 = wx.Button( sbSizer3.GetStaticBox(), wx.ID_ANY, u"VGA", wx.DefaultPosition, wx.DefaultSize, 0 )
        bSizer27.Add( self.m_button28, 1, wx.ALL, 5 )
        self.m_button29 = wx.Button( sbSizer3.GetStaticBox(), wx.ID_ANY, u"NTSC", wx.DefaultPosition, wx.DefaultSize, 0 )
        bSizer27.Add( self.m_button29, 1, wx.ALL, 5 )
        self.m_button30 = wx.Button( sbSizer3.GetStaticBox(), wx.ID_ANY, u"HDMI", wx.DefaultPosition, wx.DefaultSize, 0 )
        bSizer27.Add( self.m_button30, 1, wx.ALL, 5 )
        bSizer26.Add( bSizer27, 1, wx.EXPAND, 5 )
        bSizer28 = wx.BoxSizer( wx.HORIZONTAL )
        self.m_staticText16 = wx.StaticText( sbSizer3.GetStaticBox(), wx.ID_ANY, u"Speed", wx.DefaultPosition, wx.DefaultSize, 0 )
        self.m_staticText16.Wrap( -1 )
        bSizer28.Add( self.m_staticText16, 0, wx.ALL, 5 )
        self.m_slider1 = wx.Slider( sbSizer3.GetStaticBox(), wx.ID_ANY, 50, 0, 100, wx.DefaultPosition, wx.DefaultSize, wx.SL_HORIZONTAL )
        bSizer28.Add( self.m_slider1, 2, wx.ALL, 5 )
        self.m_spinCtrl1 = wx.SpinCtrl( sbSizer3.GetStaticBox(), wx.ID_ANY, wx.EmptyString, wx.DefaultPosition, wx.DefaultSize, wx.SP_ARROW_KEYS, 0, 100, 0 )
        self.m_spinCtrl1.Enable( False )
        self.m_spinCtrl1.SetMaxSize( wx.Size( 75,-1 ) )
        bSizer28.Add( self.m_spinCtrl1, 0, wx.ALL, 5 )
        bSizer26.Add( bSizer28, 1, wx.EXPAND, 5 )
        sbSizer3.Add( bSizer26, 1, wx.EXPAND, 5 )
        bSizer22.Add( sbSizer3, 0, wx.EXPAND, 5 )
        bSizer22.Add( ( 0, 0), 1, wx.EXPAND, 5 )
        self.SetSizer( bSizer22 )
        self.Layout()
        self.m_button24.Bind( wx.EVT_BUTTON, self.OnBinaryOff )
        self.m_button25.Bind( wx.EVT_BUTTON, self.OnBinaryOn )
        self.m_button26.Bind( wx.EVT_BUTTON, self.OnSingleButton )
        self.m_button27.Bind( wx.EVT_BUTTON, self.OnSingleButton )
        self.m_button28.Bind( wx.EVT_BUTTON, self.OnMultiButton )
        self.m_button29.Bind( wx.EVT_BUTTON, self.OnMultiButton )
        self.m_button30.Bind( wx.EVT_BUTTON, self.OnMultiButton )
        self.m_slider1.Bind( wx.EVT_SCROLL, self.OnSingleSliderScroll )
    def __del__( self ):
        pass
    def OnBinaryOff( self, event ):
        event.Skip()
    def OnBinaryOn( self, event ):
        event.Skip()
    def OnSingleButton( self, event ):
        event.Skip()
    def OnMultiButton( self, event ):
        event.Skip()
    def OnSingleSliderScroll( self, event ):
        event.Skip()
class FormStop_base ( wx.Dialog ):
    def __init__( self, parent ):
        wx.Dialog.__init__ ( self, parent, id = wx.ID_ANY, title = u"Happyscript", pos = wx.DefaultPosition, size = wx.Size( 480,198 ), style = wx.CAPTION|wx.STAY_ON_TOP )
        self.SetSizeHints( wx.DefaultSize, wx.DefaultSize )
        bSizer14 = wx.BoxSizer( wx.VERTICAL )
        self.m_lblMessage = wx.StaticText( self, wx.ID_ANY, u"MyLabel", wx.DefaultPosition, wx.DefaultSize, 0 )
        self.m_lblMessage.Wrap( -1 )
        bSizer14.Add( self.m_lblMessage, 1, wx.ALL, 20 )
        self.m_btnCancel = wx.Button( self, wx.ID_ANY, u"Stop", wx.DefaultPosition, wx.DefaultSize, 0 )
        bSizer14.Add( self.m_btnCancel, 0, wx.ALL|wx.EXPAND, 20 )
        self.SetSizer( bSizer14 )
        self.Layout()
        self.Centre( wx.BOTH )
        self.m_btnCancel.Bind( wx.EVT_BUTTON, self.OnBtnStop )
    def __del__( self ):
        pass
    def OnBtnStop( self, event ):
        event.Skip()
class FormOnTestFailure( FormOnTestFailure_Base):
    static_item = None
    @classmethod
    def show(cls, testname):
        if cls.static_item is None:
            cls.static_item = FormOnTestFailure()
        cls.static_item.m_txtMessage.Label = "Test '%s' is gefaald.\nWat wil je doen ?" % testname
        cls.static_item.ShowModal()
        return cls.static_item.result
    @classmethod
    def cleanup(cls):
        if cls.static_item is not None:
            cls.static_item.Destroy()
            cls.static_item = None
    def __init__( self ):
        super().__init__(None)
        self.result = wx.ID_STOP
    def OnBtnRetry( self, event ):
        self.result = wx.ID_RETRY
        self.Close()
    def OnBtnSkip( self, event ):
        self.result = wx.ID_FORWARD
        self.Close()
    def OnBtnStop( self, event ):
        self.result = wx.ID_STOP
        self.Close()
class FormSerials( FormSerials_Base):
    static_item = None
    @classmethod
    def show(cls, count, labels = None, filters=None):
        if count<1 or count>5:
            return None
        if cls.static_item is None:
            cls.static_item = FormSerials()
        return cls.static_item.ask_serials(count, labels, filters)
    @classmethod
    def cleanup(cls):
        if cls.static_item is not None:
            cls.static_item.Destroy()
            cls.static_item = None
    def __init__( self ):
        super().__init__(None)
        self.labels = [ self.m_lblSerial1, self.m_lblSerial2, self.m_lblSerial3, self.m_lblSerial4, self.m_lblSerial5 ]
        self.texts = [ self.m_txtSerial1, self.m_txtSerial2, self.m_txtSerial3, self.m_txtSerial4, self.m_txtSerial5 ]
        self.result = False
    def ask_serials(self, count, labels, filters ):
        if count<1 or count>5:
            return None
        self.initializing = True
        if labels is None:
            labels = [ "Board 1", "Board 2", "Board 3", "Board 4", "Board 5" ]
        if filters is None:
            self.filters = [ None, None, None, None, None ]
        else:
            self.filters = filters
        self.valid = list()
        for i in range(count):
            self.texts[i].Value = ''
            self.labels[i].Label = labels[i]
            self.texts[i].Show()
            self.labels[i].Show()
            self.texts[i].SetBackgroundColour(wx.Colour(255,204,204))
            if self.filters[i] is not None:
                self.filters[i] = re.compile(self.filters[i])
            self.valid.append(False)
        for i in range(count,5):
            self.texts[i].Hide()
            self.labels[i].Hide()
        self.m_btnOK.Disable()
        self.initializing = False
        if self.ShowModal() != wx.ID_OK:
            return None
        if False in self.valid:
            return None
        serials = list()
        for i in range(count):
            serials.append( self.texts[i].Value.strip() )
        return serials
    def handle_ontext(self, num):
        if self.initializing or num<0 or num>4:
            return
        txt = self.texts[num].Value.strip()
        valid = False
        if len(txt)==0:
            valid = False
        elif self.filters[num] is not None:
            valid = True if self.filters[num].search(txt) else False
        else:
            valid = True
        self.texts[num].SetBackgroundColour( wx.Colour(204,255,204) if valid else wx.Colour(255,204,204) )
        self.valid[num] = valid
        if not self.m_btnOK.IsEnabled() and not (False in self.valid):
            self.m_btnOK.Enable()
        elif self.m_btnOK.IsEnabled() and (False in self.valid):
            self.m_btnOK.Disable()
        self.Update()
        self.Refresh()
    def OnText1( self, event ):
        self.handle_ontext(0)
    def OnText2( self, event ):
        self.handle_ontext(1)
    def OnText3( self, event ):
        self.handle_ontext(2)
    def OnText4( self, event ):
        self.handle_ontext(3)
    def OnText5( self, event ):
        self.handle_ontext(4)
    def handle_enter(self, num):
        if self.initializing or num<0 or num>4:
            return
        if num==4 or not self.texts[num+1].IsShown():
            self.m_btnOK.SetFocus()
        else:
            self.texts[num+1].SetFocus()
    def OnEnter1( self, event ):
        self.handle_enter(0)
    def OnEnter2( self, event ):
        self.handle_enter(1)
    def OnEnter3( self, event ):
        self.handle_enter(2)
    def OnEnter4( self, event ):
        self.handle_enter(3)
    def OnEnter5( self, event ):
        self.handle_enter(4)
    def OnBtnCancel( self, event ):
        self.EndModal(wx.ID_CANCEL)
    def OnBtnOK( self, event ):
        self.EndModal(wx.ID_OK)
class PanelScripts_Base ( wx.Panel ):
    def __init__( self, parent, id = wx.ID_ANY, pos = wx.DefaultPosition, size = wx.Size( 500,477 ), style = 0, name = wx.EmptyString ):
        wx.Panel.__init__ ( self, parent, id = id, pos = pos, size = size, style = style, name = name )
        bSizer54 = wx.BoxSizer( wx.VERTICAL )
        bSizer64 = wx.BoxSizer( wx.HORIZONTAL )
        self.btn_stop = wx.Button( self, wx.ID_ANY, u"Stop script", wx.DefaultPosition, wx.DefaultSize, 0 )
        self.btn_stop.SetToolTip( u"Stop script by setting a software flag.  Scripts must stop on their own in a controlled manner." )
        bSizer64.Add( self.btn_stop, 3, wx.ALL, 5 )
        bSizer64.Add( ( 0, 0), 1, wx.EXPAND, 5 )
        self.m_btnReload = wx.Button( self, wx.ID_ANY, u"Reload", wx.DefaultPosition, wx.Size( -1,-1 ), wx.BU_EXACTFIT )
        bSizer64.Add( self.m_btnReload, 2, wx.ALL, 5 )
        bSizer54.Add( bSizer64, 0, wx.EXPAND, 5 )
        self.m_splitter2 = wx.SplitterWindow( self, wx.ID_ANY, wx.DefaultPosition, wx.DefaultSize, wx.SP_3D )
        self.m_splitter2.SetSashGravity( 0.9 )
        self.m_splitter2.Bind( wx.EVT_IDLE, self.m_splitter2OnIdle )
        self.m_panel1 = wx.Panel( self.m_splitter2, wx.ID_ANY, wx.DefaultPosition, wx.DefaultSize, wx.TAB_TRAVERSAL )
        bSizer58 = wx.BoxSizer( wx.VERTICAL )
        self.treeScripts = wx.TreeCtrl( self.m_panel1, wx.ID_ANY, wx.DefaultPosition, wx.DefaultSize, wx.TR_DEFAULT_STYLE|wx.TR_HIDE_ROOT )
        bSizer58.Add( self.treeScripts, 1, wx.ALL|wx.EXPAND, 5 )
        self.m_panel1.SetSizer( bSizer58 )
        self.m_panel1.Layout()
        bSizer58.Fit( self.m_panel1 )
        self.m_panel2 = wx.Panel( self.m_splitter2, wx.ID_ANY, wx.DefaultPosition, wx.DefaultSize, wx.TAB_TRAVERSAL )
        self.m_panel2.SetMaxSize( wx.Size( -1,200 ) )
        bSizer59 = wx.BoxSizer( wx.VERTICAL )
        self.txtHelp = wx.TextCtrl( self.m_panel2, wx.ID_ANY, u"This command initializes the coprocessor test setup. Also this will do a lot of other things that won't be described here.", wx.DefaultPosition, wx.DefaultSize, wx.TE_MULTILINE|wx.TE_READONLY|wx.TE_WORDWRAP )
        bSizer59.Add( self.txtHelp, 1, wx.ALL|wx.EXPAND, 5 )
        self.m_panel2.SetSizer( bSizer59 )
        self.m_panel2.Layout()
        bSizer59.Fit( self.m_panel2 )
        self.m_splitter2.SplitHorizontally( self.m_panel1, self.m_panel2, 0 )
        bSizer54.Add( self.m_splitter2, 1, wx.EXPAND, 5 )
        self.SetSizer( bSizer54 )
        self.Layout()
        self.btn_stop.Bind( wx.EVT_BUTTON, self.btn_stopOnButtonClick )
        self.m_btnReload.Bind( wx.EVT_BUTTON, self.OnBtnReload )
        self.treeScripts.Bind( wx.EVT_LEFT_DCLICK, self.OnTreeLeftDoubleClick )
        self.treeScripts.Bind( wx.EVT_TREE_KEY_DOWN, self.OnTreeKeyDown )
        self.treeScripts.Bind( wx.EVT_TREE_SEL_CHANGED, self.OnTreeSelChanged )
    def __del__( self ):
        pass
    def btn_stopOnButtonClick( self, event ):
        event.Skip()
    def OnBtnReload( self, event ):
        event.Skip()
    def OnTreeLeftDoubleClick( self, event ):
        event.Skip()
    def OnTreeKeyDown( self, event ):
        event.Skip()
    def OnTreeSelChanged( self, event ):
        event.Skip()
    def m_splitter2OnIdle( self, event ):
        self.m_splitter2.SetSashPosition( 0 )
        self.m_splitter2.Unbind( wx.EVT_IDLE )
class PanelMessages_Base ( wx.Panel ):
    def __init__( self, parent, id = wx.ID_ANY, pos = wx.DefaultPosition, size = wx.Size( 500,562 ), style = 0, name = wx.EmptyString ):
        wx.Panel.__init__ ( self, parent, id = id, pos = pos, size = size, style = style, name = name )
        bSizer5 = wx.BoxSizer( wx.VERTICAL )
        bSizer6 = wx.BoxSizer( wx.HORIZONTAL )
        self.btnClearList = wx.Button( self, wx.ID_ANY, u"Clear list", wx.DefaultPosition, wx.DefaultSize, 0 )
        bSizer6.Add( self.btnClearList, 0, wx.ALL, 5 )
        bSizer6.Add( ( 0, 0), 1, wx.EXPAND, 5 )
        self.m_staticText12 = wx.StaticText( self, wx.ID_ANY, u"Log Level", wx.DefaultPosition, wx.DefaultSize, 0 )
        self.m_staticText12.Wrap( -1 )
        bSizer6.Add( self.m_staticText12, 0, wx.ALIGN_CENTER_VERTICAL|wx.ALL, 5 )
        m_cboLogLevelChoices = [ u"Debug", u"Info", u"Warning" ]
        self.m_cboLogLevel = wx.Choice( self, wx.ID_ANY, wx.DefaultPosition, wx.DefaultSize, m_cboLogLevelChoices, 0 )
        self.m_cboLogLevel.SetSelection( 2 )
        bSizer6.Add( self.m_cboLogLevel, 0, wx.ALL, 5 )
        bSizer5.Add( bSizer6, 0, wx.EXPAND, 5 )
        self.lstMessages = wx.ListCtrl( self, wx.ID_ANY, wx.DefaultPosition, wx.DefaultSize, wx.LC_REPORT )
        bSizer5.Add( self.lstMessages, 1, wx.ALL|wx.EXPAND, 5 )
        self.SetSizer( bSizer5 )
        self.Layout()
        self.btnClearList.Bind( wx.EVT_BUTTON, self.OnBtnClearList )
        self.m_cboLogLevel.Bind( wx.EVT_CHOICE, self.OnSelectLogLevel )
        self.lstMessages.Bind( wx.EVT_SIZE, self.OnListSize )
    def __del__( self ):
        pass
    def OnBtnClearList( self, event ):
        event.Skip()
    def OnSelectLogLevel( self, event ):
        event.Skip()
    def OnListSize( self, event ):
        event.Skip()
class PanelLog_Base ( wx.Panel ):
    def __init__( self, parent, id = wx.ID_ANY, pos = wx.DefaultPosition, size = wx.Size( 783,466 ), style = wx.TAB_TRAVERSAL, name = wx.EmptyString ):
        wx.Panel.__init__ ( self, parent, id = id, pos = pos, size = size, style = style, name = name )
        bSizer7 = wx.BoxSizer( wx.VERTICAL )
        bSizer17 = wx.BoxSizer( wx.HORIZONTAL )
        self.m_btnClearLog = wx.Button( self, wx.ID_ANY, u"Clear Log", wx.DefaultPosition, wx.DefaultSize, 0 )
        bSizer17.Add( self.m_btnClearLog, 0, wx.ALL, 5 )
        bSizer17.Add( ( 0, 0), 1, wx.EXPAND, 5 )
        self.m_btnStop = wx.Button( self, wx.ID_ANY, u"Stop", wx.DefaultPosition, wx.DefaultSize, 0 )
        self.m_btnStop.SetFont( wx.Font( wx.NORMAL_FONT.GetPointSize(), wx.FONTFAMILY_DEFAULT, wx.FONTSTYLE_NORMAL, wx.FONTWEIGHT_NORMAL, False, wx.EmptyString ) )
        self.m_btnStop.SetToolTip( u"Stop logging.  Handy if you want to copy-paste something." )
        bSizer17.Add( self.m_btnStop, 0, wx.ALL, 5 )
        self.m_btnResume = wx.Button( self, wx.ID_ANY, u"Resume", wx.DefaultPosition, wx.DefaultSize, 0 )
        self.m_btnResume.Enable( False )
        self.m_btnResume.SetToolTip( u"Resume logging, after being stopped." )
        bSizer17.Add( self.m_btnResume, 0, wx.ALL, 5 )
        bSizer17.Add( ( 0, 0), 6, wx.EXPAND, 5 )
        self.m_staticText11 = wx.StaticText( self, wx.ID_ANY, u"Log  level", wx.DefaultPosition, wx.DefaultSize, 0 )
        self.m_staticText11.Wrap( -1 )
        bSizer17.Add( self.m_staticText11, 0, wx.ALIGN_CENTER_VERTICAL|wx.ALL, 5 )
        m_cboLogLevelChoices = [ u"Debug", u"Info", u"Warning" ]
        self.m_cboLogLevel = wx.Choice( self, wx.ID_ANY, wx.DefaultPosition, wx.DefaultSize, m_cboLogLevelChoices, 0 )
        self.m_cboLogLevel.SetSelection( 1 )
        bSizer17.Add( self.m_cboLogLevel, 0, wx.ALL, 5 )
        bSizer7.Add( bSizer17, 1, wx.EXPAND, 5 )
        self.wx_txtLog = wx.TextCtrl( self, wx.ID_ANY, wx.EmptyString, wx.DefaultPosition, wx.DefaultSize, wx.TE_MULTILINE )
        self.wx_txtLog.SetFont( wx.Font( 10, wx.FONTFAMILY_MODERN, wx.FONTSTYLE_NORMAL, wx.FONTWEIGHT_NORMAL, False, "Consolas" ) )
        bSizer7.Add( self.wx_txtLog, 100, wx.ALL|wx.EXPAND, 5 )
        self.wx_txtCommand = wx.TextCtrl( self, wx.ID_ANY, u"Type command here", wx.DefaultPosition, wx.DefaultSize, wx.TE_PROCESS_ENTER )
        self.wx_txtCommand.SetFont( wx.Font( 10, wx.FONTFAMILY_MODERN, wx.FONTSTYLE_NORMAL, wx.FONTWEIGHT_NORMAL, False, "Consolas" ) )
        bSizer7.Add( self.wx_txtCommand, 0, wx.ALL|wx.EXPAND, 5 )
        self.SetSizer( bSizer7 )
        self.Layout()
        self.m_btnClearLog.Bind( wx.EVT_BUTTON, self.OnBtnClearLog )
        self.m_btnStop.Bind( wx.EVT_BUTTON, self.OnBtnStop )
        self.m_btnResume.Bind( wx.EVT_BUTTON, self.OnBtnResume )
        self.m_cboLogLevel.Bind( wx.EVT_CHOICE, self.OnSelectLogLevel )
        self.wx_txtCommand.Bind( wx.EVT_KEY_UP, self.OnCmdKeyUp )
        self.wx_txtCommand.Bind( wx.EVT_SET_FOCUS, self.OnSetFocus )
        self.wx_txtCommand.Bind( wx.EVT_TEXT_ENTER, self.OnCmdEnter )
    def __del__( self ):
        pass
    def OnBtnClearLog( self, event ):
        event.Skip()
    def OnBtnStop( self, event ):
        event.Skip()
    def OnBtnResume( self, event ):
        event.Skip()
    def OnSelectLogLevel( self, event ):
        event.Skip()
    def OnCmdKeyUp( self, event ):
        event.Skip()
    def OnSetFocus( self, event ):
        event.Skip()
    def OnCmdEnter( self, event ):
        event.Skip()
class PanelTests_Base ( wx.Panel ):
    def __init__( self, parent, id = wx.ID_ANY, pos = wx.DefaultPosition, size = wx.Size( 500,300 ), style = 0, name = wx.EmptyString ):
        wx.Panel.__init__ ( self, parent, id = id, pos = pos, size = size, style = style, name = name )
        bSizer8 = wx.BoxSizer( wx.VERTICAL )
        bSizer9 = wx.BoxSizer( wx.HORIZONTAL )
        self.m_btnStart = wx.Button( self, wx.ID_ANY, u"Start", wx.DefaultPosition, wx.DefaultSize, 0 )
        self.m_btnStart.SetFont( wx.Font( 14, wx.FONTFAMILY_SWISS, wx.FONTSTYLE_NORMAL, wx.FONTWEIGHT_NORMAL, False, "Arial" ) )
        bSizer9.Add( self.m_btnStart, 1, wx.ALL|wx.EXPAND, 5 )
        self.m_btnPause = wx.Button( self, wx.ID_ANY, u"Pause", wx.DefaultPosition, wx.DefaultSize, 0 )
        self.m_btnPause.SetFont( wx.Font( 14, wx.FONTFAMILY_SWISS, wx.FONTSTYLE_NORMAL, wx.FONTWEIGHT_NORMAL, False, "Arial" ) )
        self.m_btnPause.Enable( False )
        bSizer9.Add( self.m_btnPause, 1, wx.ALL|wx.EXPAND, 5 )
        self.m_btnStop = wx.Button( self, wx.ID_ANY, u"Stop", wx.DefaultPosition, wx.DefaultSize, 0 )
        self.m_btnStop.SetFont( wx.Font( 14, wx.FONTFAMILY_SWISS, wx.FONTSTYLE_NORMAL, wx.FONTWEIGHT_NORMAL, False, "Arial" ) )
        self.m_btnStop.Enable( False )
        bSizer9.Add( self.m_btnStop, 1, wx.ALL|wx.EXPAND, 5 )
        bSizer8.Add( bSizer9, 0, wx.EXPAND, 5 )
        self.m_txtStatus = wx.StaticText( self, wx.ID_ANY, u"-", wx.DefaultPosition, wx.DefaultSize, 0 )
        self.m_txtStatus.Wrap( -1 )
        self.m_txtStatus.SetFont( wx.Font( 16, wx.FONTFAMILY_SWISS, wx.FONTSTYLE_NORMAL, wx.FONTWEIGHT_NORMAL, False, "Arial" ) )
        bSizer8.Add( self.m_txtStatus, 0, wx.ALIGN_CENTER_HORIZONTAL|wx.ALL, 5 )
        self.m_lstTests = wx.ListCtrl( self, wx.ID_ANY, wx.DefaultPosition, wx.DefaultSize, wx.LC_HRULES|wx.LC_REPORT )
        self.m_lstTests.SetFont( wx.Font( 12, wx.FONTFAMILY_SWISS, wx.FONTSTYLE_NORMAL, wx.FONTWEIGHT_NORMAL, False, "Arial" ) )
        bSizer8.Add( self.m_lstTests, 1, wx.ALL|wx.EXPAND, 5 )
        self.SetSizer( bSizer8 )
        self.Layout()
        self.m_tmrStateMachine = wx.Timer()
        self.m_tmrStateMachine.SetOwner( self, wx.ID_ANY )
        self.m_mnuTestList = wx.Menu()
        self.m_mniRun = wx.MenuItem( self.m_mnuTestList, wx.ID_ANY, u"Run now", wx.EmptyString, wx.ITEM_NORMAL )
        self.m_mniRun.SetBitmap( wx.ArtProvider.GetBitmap( "play",  ) )
        self.m_mnuTestList.Append( self.m_mniRun )
        self.m_mnuTestList.AppendSeparator()
        self.m_mniEnable = wx.MenuItem( self.m_mnuTestList, wx.ID_ANY, u"Enable", wx.EmptyString, wx.ITEM_NORMAL )
        self.m_mniEnable.SetBitmap( wx.ArtProvider.GetBitmap( "idle",  ) )
        self.m_mnuTestList.Append( self.m_mniEnable )
        self.m_mniDisable = wx.MenuItem( self.m_mnuTestList, wx.ID_ANY, u"Disable", u"Test will not run, and it will count as a failed test.", wx.ITEM_NORMAL )
        self.m_mniDisable.SetBitmap( wx.ArtProvider.GetBitmap( "disable",  ) )
        self.m_mnuTestList.Append( self.m_mniDisable )
        self.m_mniSkip = wx.MenuItem( self.m_mnuTestList, wx.ID_ANY, u"Skip", u"Test is not run, and is considered successful", wx.ITEM_NORMAL )
        self.m_mniSkip.SetBitmap( wx.ArtProvider.GetBitmap( "skip",  ) )
        self.m_mnuTestList.Append( self.m_mniSkip )
        self.m_mnuTestList.AppendSeparator()
        self.m_mniBreakpoint = wx.MenuItem( self.m_mnuTestList, wx.ID_ANY, u"Toggle breakpoint", wx.EmptyString, wx.ITEM_NORMAL )
        self.m_mniBreakpoint.SetBitmap( wx.ArtProvider.GetBitmap( "red_dot",  ) )
        self.m_mnuTestList.Append( self.m_mniBreakpoint )
        self.m_btnStart.Bind( wx.EVT_BUTTON, self.OnBtnStartClick )
        self.m_btnPause.Bind( wx.EVT_BUTTON, self.OnBtnPauseClick )
        self.m_btnStop.Bind( wx.EVT_BUTTON, self.OnBtnStopClick )
        self.m_lstTests.Bind( wx.EVT_LIST_ITEM_RIGHT_CLICK, self.OnListRightClick )
        self.m_lstTests.Bind( wx.EVT_SIZE, self.OnListSize )
        self.Bind( wx.EVT_TIMER, self.OnTmrStateMachine, id=wx.ID_ANY )
        self.Bind( wx.EVT_MENU, self.OnMenuRun, id = self.m_mniRun.GetId() )
        self.Bind( wx.EVT_MENU, self.OnMenuEnable, id = self.m_mniEnable.GetId() )
        self.Bind( wx.EVT_MENU, self.OnMenudisable, id = self.m_mniDisable.GetId() )
        self.Bind( wx.EVT_MENU, self.OnMenuSkip, id = self.m_mniSkip.GetId() )
        self.Bind( wx.EVT_MENU, self.OnMenuBreakpoint, id = self.m_mniBreakpoint.GetId() )
    def __del__( self ):
        pass
    def OnBtnStartClick( self, event ):
        event.Skip()
    def OnBtnPauseClick( self, event ):
        event.Skip()
    def OnBtnStopClick( self, event ):
        event.Skip()
    def OnListRightClick( self, event ):
        event.Skip()
    def OnListSize( self, event ):
        event.Skip()
    def OnTmrStateMachine( self, event ):
        event.Skip()
    def OnMenuRun( self, event ):
        event.Skip()
    def OnMenuEnable( self, event ):
        event.Skip()
    def OnMenudisable( self, event ):
        event.Skip()
    def OnMenuSkip( self, event ):
        event.Skip()
    def OnMenuBreakpoint( self, event ):
        event.Skip()
class PanelCharts_Base ( wx.Panel ):
    def __init__( self, parent, id = wx.ID_ANY, pos = wx.DefaultPosition, size = wx.Size( 500,300 ), style = wx.TAB_TRAVERSAL, name = wx.EmptyString ):
        wx.Panel.__init__ ( self, parent, id = id, pos = pos, size = size, style = style, name = name )
        m_sizerTop = wx.BoxSizer( wx.HORIZONTAL )
        self.m_nbkPlots = wx.Notebook( self, wx.ID_ANY, wx.DefaultPosition, wx.DefaultSize, 0 )
        m_sizerTop.Add( self.m_nbkPlots, 1, wx.EXPAND |wx.ALL, 5 )
        bSizer19 = wx.BoxSizer( wx.VERTICAL )
        self.m_btnCopyData = wx.Button( self, wx.ID_ANY, u"Copy data", wx.DefaultPosition, wx.DefaultSize, 0 )
        bSizer19.Add( self.m_btnCopyData, 0, wx.ALL|wx.EXPAND, 5 )
        bSizer19.Add( ( 0, 10), 0, wx.EXPAND, 5 )
        self.m_btnAntiAlias = wx.Button( self, wx.ID_ANY, u"Make pretty", wx.DefaultPosition, wx.DefaultSize, 0 )
        bSizer19.Add( self.m_btnAntiAlias, 0, wx.ALL|wx.EXPAND, 5 )
        self.m_btnSaveToFile = wx.Button( self, wx.ID_ANY, u"Save bitmap...", wx.DefaultPosition, wx.DefaultSize, 0 )
        bSizer19.Add( self.m_btnSaveToFile, 0, wx.ALL|wx.EXPAND, 5 )
        bSizer19.Add( ( 0, 0), 1, wx.EXPAND, 5 )
        m_rbxMouseModeChoices = [ u"Fixed", u"Zoom", u"Move" ]
        self.m_rbxMouseMode = wx.RadioBox( self, wx.ID_ANY, u"Mouse mode", wx.DefaultPosition, wx.DefaultSize, m_rbxMouseModeChoices, 1, wx.RA_SPECIFY_COLS )
        self.m_rbxMouseMode.SetSelection( 0 )
        bSizer19.Add( self.m_rbxMouseMode, 0, wx.ALL, 5 )
        m_sizerTop.Add( bSizer19, 0, wx.EXPAND, 5 )
        self.SetSizer( m_sizerTop )
        self.Layout()
        self.m_tmrAnimate = wx.Timer()
        self.m_tmrAnimate.SetOwner( self, wx.ID_ANY )
        self.m_tmrRedraw = wx.Timer()
        self.m_tmrRedraw.SetOwner( self, wx.ID_ANY )
        self.m_tmrRedraw.Start( 50 )
        self.m_btnCopyData.Bind( wx.EVT_BUTTON, self.BtnCopyDataClick )
        self.m_btnAntiAlias.Bind( wx.EVT_BUTTON, self.OnMakePretty )
        self.m_btnSaveToFile.Bind( wx.EVT_BUTTON, self.OnBtnSaveBitmap )
        self.m_rbxMouseMode.Bind( wx.EVT_RADIOBOX, self.OnRadioBoxMouseMode )
        self.Bind( wx.EVT_TIMER, self.OnTimerAnimate, id=wx.ID_ANY )
        self.Bind( wx.EVT_TIMER, self.OnRedrawTimer, id=wx.ID_ANY )
    def __del__( self ):
        pass
    def BtnCopyDataClick( self, event ):
        event.Skip()
    def OnMakePretty( self, event ):
        event.Skip()
    def OnBtnSaveBitmap( self, event ):
        event.Skip()
    def OnRadioBoxMouseMode( self, event ):
        event.Skip()
    def OnTimerAnimate( self, event ):
        event.Skip()
    def OnRedrawTimer( self, event ):
        event.Skip()
class PlotDialog ( wx.Dialog ):
    def __init__( self, parent ):
        wx.Dialog.__init__ ( self, parent, id = wx.ID_ANY, title = wx.EmptyString, pos = wx.DefaultPosition, size = wx.Size( 800,600 ), style = wx.DEFAULT_DIALOG_STYLE|wx.RESIZE_BORDER )
        self.SetSizeHints( wx.DefaultSize, wx.DefaultSize )
        bSizer21 = wx.BoxSizer( wx.VERTICAL )
        self.m_thePanel = wx.Panel( self, wx.ID_ANY, wx.DefaultPosition, wx.DefaultSize, wx.TAB_TRAVERSAL )
        bSizer21.Add( self.m_thePanel, 1, wx.EXPAND |wx.ALL, 5 )
        self.SetSizer( bSizer21 )
        self.Layout()
        self.Centre( wx.BOTH )
        self.Bind( wx.EVT_CLOSE, self.OnClose )
    def __del__( self ):
        pass
    def OnClose( self, event ):
        event.Skip()
class PanelMessages( PanelMessages_Base ):
    def __init__( self, parent ):
        PanelMessages_Base.__init__(self, parent)
        self.lstMessages.InsertColumn(0, "Time", wx.LIST_FORMAT_RIGHT)
        self.lstMessages.InsertColumn(1, "Status")
        self.lstMessages.InsertColumn(2, "Message")
        self.lstMessages.SetColumnWidth(0, 75)
        self.lstMessages.SetColumnWidth(1, 70)
        self.lstMessages.SetColumnWidth(2, 100)
        self.loglevel = logging.WARN+1
    def OnListSize( self, event ):
        width = self.GetClientSize().width
        if width<160:
            width = 160;
        self.lstMessages.SetColumnWidth(2, width-150)
        event.Skip()
    def HandleLogData(self, logdata):
        if logdata.levelno < self.loglevel:
            return
        if logdata.levelno>=logging.ERROR:
            color = wx.RED
        elif logdata.levelno==logging.WARN+1:
            color = wx.BLUE
        elif logdata.levelno>=logging.WARN:
            color = wx.Colour(255, 128, 0)
        else:
            color = None
        self.AddListEntry(logdata.levelname, logdata.msg, color)
    def AddListEntry(self, result, msg, color=None):
        tstamp = datetime.datetime.now().strftime("%m/%d %H:%M")
        self.lstMessages.Append( (tstamp, result, msg) )
        cnt = self.lstMessages.GetItemCount()
        if color is not None:
            item = self.lstMessages.GetItem(cnt-1)
            item.SetTextColour(color)
            self.lstMessages.SetItem(item)
        self.lstMessages.EnsureVisible(cnt - 1)
        self.lstMessages.Update()
    def OnBtnClearList( self, event ):
        self.lstMessages.DeleteAllItems()
    def OnSelectLogLevel( self, event ):
        sel = self.m_cboLogLevel.GetStringSelection().lower()
        if sel=="warning":
            self.loglevel = logging.WARN
        elif sel=="info":
            self.loglevel = logging.INFO
        else:
            self.loglevel = logging.DEBUG
            logger = logging.getLogger('')
            if logger.getEffectiveLevel() > logging.DEBUG:
                logger.setLevel(logging.DEBUG)
class RunState(Enum):
    IDLE = 1
    RUN_SINGLE = 2
    RUNNING = 3
    PAUSED = 4
    FINISHED = 5
    DO_SETUP_FUNC = 6
    DO_CLEANUP_FUNC = 7
    WAIT_TEST_END = 8
    ERROR = 9
    START_FIRST = 10
class RunAction(Enum):
    NONE = 1
    STOP_ALL = 2
    PAUSE = 6
class TestIcon(IntEnum):
    FAIL = 0
    PASS = 1
    TODO = 2
    WARN = 3
    IDLE = 4
    RUNNING = 5
    PAUSED = 6
    @classmethod
    def GetImageList(cls):
        il = wx.ImageList(16, 16)
        il.Add( wx.ArtProvider.GetBitmap("test_fail") )
        il.Add( wx.ArtProvider.GetBitmap("test_pass") )
        il.Add( wx.ArtProvider.GetBitmap("test_todo") )
        il.Add( wx.ArtProvider.GetBitmap("test_warning" ))
        il.Add( wx.ArtProvider.GetBitmap("test_idle" ))
        il.Add( wx.ArtProvider.GetBitmap("test_running"))
        il.Add( wx.ArtProvider.GetBitmap("test_pause"))
        return il
class TestInfo:
    def __init__(self, description, scriptname, **args):
        self.description = description
        self.scriptname = scriptname
        self.extra_args = args
        self.passed = False
class PanelTests( PanelTests_Base):
    logger = logging.getLogger("happyscript")
    def __init__( self, parent, mngr ):
        PanelTests_Base.__init__(self, parent)
        self.on_sequence_start_callback = None
        self.on_sequence_end_callback = None
        self.mngr = mngr
        self.__run_state = RunState.IDLE
        self.__run_action = RunAction.NONE
        self.__testnum = -1
        self.tests = list()
        self.init_list()
    def init_list(self):
        ScriptArtwork.register()
        self.il = TestIcon.GetImageList()
        self.m_lstTests.SetImageList(self.il, wx.IMAGE_LIST_SMALL)
        self.m_lstTests.SetFont(wx.Font(12, wx.SWISS, wx.NORMAL, wx.NORMAL))
        info = wx.ListItem()
        info.Mask = wx.LIST_MASK_IMAGE
        info.Image = -1
        info.Align = wx.LIST_FORMAT_LEFT
        info.Text = ""
        self.m_lstTests.InsertColumn(0, info)
        info.Align = wx.LIST_FORMAT_LEFT
        info.Text = "Name"
        self.m_lstTests.InsertColumn(1, info)
        info.Mask = wx.LIST_MASK_IMAGE
        info.Image = -1
        info.Align = wx.LIST_FORMAT_LEFT
        info.Text = "?"
        self.m_lstTests.InsertColumn(2, info)
        self.m_lstTests.SetColumnWidth(0, 50)
        self.m_lstTests.SetColumnWidth(1, 100)
        self.m_lstTests.SetColumnWidth(2, 50)
    def OnListSize( self, event ):
        width = self.GetClientSize().width
        if width<160:
            width = 160;
        self.m_lstTests.SetColumnWidth(1, width-110)
        event.Skip()
    def OnListRightClick( self, event ):
        self.selected_row = event.Index
        print( self.selected_row )
        pos = wx.GetMousePosition()
        pos = self.ScreenToClient( pos )
        self.PopupMenu( self.m_mnuTestList, pos  )
    def add_test(self, description, scriptname, **args):
        test = TestInfo(description, scriptname, **args)
        self.tests.append(test)
        self.m_lstTests.Append( ('', description, '') )
        cnt = self.m_lstTests.GetItemCount()
        self.m_lstTests.SetItem(cnt-1, 0, "", imageId=TestIcon.IDLE )
        self.m_lstTests.SetItem(cnt-1, 2, "", imageId=TestIcon.TODO )
    def get_tests(self, is_passed, include = None, exclude = None):
        result = list()
        for i in range(len(self.tests)):
            if (i==self.__testnum) or (self.tests[i].passed!=is_passed):
                continue
            if (exclude is not None) and (self.tests[i].description in exclude):
                continue
            if (include is None) or (self.tests[i].description in include):
                result.append(self.tests[i].description)
        return result
    def OnBtnStartClick( self, event ):
        self.state = RunState.START_FIRST
    def OnBtnPauseClick( self, event ):
        if self.state==RunState.PAUSED:
            self.state = RunState.RUNNING
        else:
            self.__run_action = RunAction.PAUSE
    def OnBtnStopClick( self, event ):
        self.__run_action = RunAction.STOP_ALL
    def reset_icons(self):
        for index in range(len(self.tests)):
            self.m_lstTests.SetItem(index, 0, "", imageId=TestIcon.IDLE )
            self.m_lstTests.SetItem(index, 2, "", imageId=TestIcon.TODO )
            self.tests[index].passed = False
    @property
    def state(self):
        return self.__run_state
    @state.setter
    def state(self, value):
        if value==RunState.START_FIRST:
            self.__run_action = RunAction.NONE
            if self.state != RunState.IDLE:
                raise Exception("Test state is not idle, cannot start test sequence.")
        self.__run_state = value
        if value==RunState.IDLE:
            self.m_tmrStateMachine.Stop()
        else:
            self.m_tmrStateMachine.StartOnce(10)
    def OnTmrStateMachine( self, event ):
        if self.state == RunState.IDLE:
            self.m_tmrStateMachine.Stop()
        elif self.state == RunState.START_FIRST:
            self.__testnum = -1
            self.logger.debug("Starting new test sequence")
            self.m_txtStatus.Label = "Starting"
            self.m_txtStatus.SetForegroundColour(wx.SystemSettings.GetColour(wx.SYS_COLOUR_WINDOWTEXT))
            self.reset_icons()
            self.m_btnStart.Enabled = False
            self.m_btnStop.Enabled = True
            self.state = RunState.DO_SETUP_FUNC
        elif self.state == RunState.DO_SETUP_FUNC:
                if self.on_sequence_start_callback is None:
                    self.state = RunState.RUNNING
                else:
                    try:
                        result = self.on_sequence_start_callback()
                        if isinstance(result, str):
                            self.m_txtStatus.Label = result
                            self.state = RunState.ERROR
                        elif isinstance(result, bool) and result==False:
                            self.m_txtStatus.Label = "Test run aborted"
                            self.state = RunState.ERROR
                        else:
                            self.state = RunState.RUNNING
                    except Exception as e:
                        self.logger.critical("Error in callback at beginning of test", exc_info=e)
                        self.m_txtStatus.Label = "Internal error #1"
                        self.state = RunState.ERROR
                        return
        elif self.state == RunState.RUNNING:
            self.__testnum += 1
            if self.__testnum >= len(self.tests):
                self.logger.debug("No more test to execute")
                self.state = RunState.DO_CLEANUP_FUNC
            elif self.__run_action==RunAction.STOP_ALL:
                self.__run_action = RunAction.NONE
                self.logger.debug("Stopping all tests")
                self.state = RunState.DO_CLEANUP_FUNC
            else:
                self.m_lstTests.EnsureVisible(self.__testnum)
                self.m_lstTests.SetItem(self.__testnum, 0, "", imageId=TestIcon.RUNNING )
                self.m_lstTests.SetItem(self.__testnum, 2, "", imageId=TestIcon.TODO )
                self.m_lstTests.Update()
                self.m_txtStatus.Label = "Running test %d" % (self.__testnum+1)
                sname = self.tests[self.__testnum].scriptname
                sargs = self.tests[self.__testnum].extra_args
                if sargs is None:
                    self.mngr._script_runner.run_script(sname)
                else:
                    self.mngr._script_runner.run_script(sname, **sargs)
                self.state = RunState.WAIT_TEST_END
        elif self.state == RunState.WAIT_TEST_END:
            if self.mngr._script_runner.busy:
                self.state = RunState.WAIT_TEST_END
            else:
                test_pass = self.mngr._script_runner.test_passed
                index = self.__testnum
                if test_pass:
                    self.m_lstTests.SetItem(index, 0, "", imageId=TestIcon.IDLE )
                self.m_lstTests.SetItem(index, 2, "", imageId=TestIcon.PASS if test_pass else TestIcon.FAIL )
                self.m_lstTests.Update()
                self.tests[index].passed = test_pass
                if test_pass:
                    self.state = RunState.RUNNING
                else:
                    self.m_lstTests.SetItem(index, 0, "", imageId=TestIcon.WARN )
                    result = FormOnTestFailure.show(self.tests[index].description)
                    self.m_lstTests.SetItem(index, 0, "", imageId=TestIcon.IDLE )
                    if result==wx.ID_RETRY:
                        self.__testnum -= 1
                        self.logger.warn("Test failed, doing retry")
                        self.state = RunState.RUNNING
                    elif result==wx.ID_FORWARD:
                        self.logger.warn("Test skipped by user")
                        self.state = RunState.RUNNING
                    else:
                        self.logger.warn("Test sequence aborted by user")
                        self.state = RunState.DO_CLEANUP_FUNC
        elif self.state == RunState.RUN_SINGLE:
            self.logger.error("Run single not yet implemented")
            self.state = RunState.ERROR
        elif self.state == RunState.PAUSED:
            self.logger.error("Pause not yet implemented")
            self.state = RunState.ERROR
        elif self.state == RunState.DO_CLEANUP_FUNC:
            if self.on_sequence_end_callback is None:
                self.state = RunState.FINISHED
            else:
                try:
                    self.on_sequence_end_callback()
                    self.state = RunState.FINISHED
                except Exception as e:
                    self.logger.critical("Error in callback at end of test", exc_info=e)
                    self.m_txtStatus.Label = "Internal error #2"
                    self.state = RunState.ERROR
        elif self.state == RunState.FINISHED:
            self.logger.debug("Tests finished")
            num_fails = sum( 1 for x in self.tests if not x.passed)
            if num_fails==0:
                self.m_txtStatus.Label = "All test OK"
            elif num_fails==1:
                self.m_txtStatus.Label = "1 test failed !"
                self.m_txtStatus.SetForegroundColour(wx.RED)
            else:
                self.m_txtStatus.Label = "%d tests failed !" % num_fails
            self.m_txtStatus.SetForegroundColour(wx.RED)
            self.state = RunState.IDLE
            self.m_btnStart.Enabled = True
            self.m_btnStop.Enabled = False
        elif self.state == RunState.ERROR:
            self.state = RunState.IDLE
            self.m_btnStart.Enabled = True
            self.m_btnStop.Enabled = False
        else:
            self.logger.critical("run_state invalid in testlist state machine")
            self.m_txtStatus = "Internal error #3"
            self.state = RunState.IDLE
            self.m_btnStart.Enabled = True
            self.m_btnStop.Enabled = False
class PanelLog( PanelLog_Base ):
    def __init__( self, parent ):
        super().__init__(parent)
        self.lstCommandHistory = list()
        self.posInCommandHistory = 0
        self.callback = None
        self.first_time_in_commandline = True
        self.loglevel = logging.INFO
        self._stop_log = False
    def OnBtnClearLog( self, event ):
        self.wx_txtLog.Clear()
    def HandleLog(self, logdata):
        if logdata.levelno < self.loglevel:
            return
        if self._stop_log:
            return
        if logdata.levelno >= logging.WARN:
            self.wx_txtLog.AppendText(f"{logdata.levelname}: {logdata.msg}\r\n")
        else:
            self.wx_txtLog.AppendText(logdata.msg+"\r\n")
        if logdata.exc_info is not None:
            self.wx_txtLog.AppendText(logdata.exc_info)
    def OnSelectLogLevel( self, event ):
        sel = self.m_cboLogLevel.GetStringSelection().lower()
        if sel=="warning":
            self.loglevel = logging.WARN
        elif sel=="info":
            self.loglevel = logging.INFO
        else:
            self.loglevel = logging.DEBUG
            logger = logging.getLogger('')
            if logger.getEffectiveLevel() > logging.DEBUG:
                logger.setLevel(logging.DEBUG)
    def OnBtnStop( self, event ):
        self._stop_log = True
        self.m_btnStop.Enable(False)
        self.m_btnResume.Enable(True)
        self.m_btnResume.SetFont( wx.Font( wx.NORMAL_FONT.GetPointSize(), wx.FONTFAMILY_DEFAULT, wx.FONTSTYLE_NORMAL, wx.FONTWEIGHT_BOLD, False, wx.EmptyString ) )
    def OnBtnResume( self, event ):
        self._stop_log = False
        self.m_btnStop.Enable(True)
        self.m_btnResume.Enable(False)
        self.m_btnResume.SetFont( wx.Font( wx.NORMAL_FONT.GetPointSize(), wx.FONTFAMILY_DEFAULT, wx.FONTSTYLE_NORMAL, wx.FONTWEIGHT_NORMAL, False, wx.EmptyString ) )
    def OnSetFocus( self, event ):
        if self.first_time_in_commandline:
            self.first_time_in_commandline = False
            self.wx_txtCommand.Clear()
        event.Skip()
    def OnCmdKeyUp( self, event ):
        if len(self.lstCommandHistory)==0:
            return;
        key = event.GetKeyCode()
        if key == wx.WXK_UP:
            self.posInCommandHistory -= 1
        elif key== wx.WXK_DOWN:
            self.posInCommandHistory += 1
        else:
            return
        if self.posInCommandHistory<0:
            self.posInCommandHistory = 0
        elif self.posInCommandHistory>=len(self.lstCommandHistory):
            self.posInCommandHistory = len(self.lstCommandHistory)-1
        self.wx_txtCommand.Value = self.lstCommandHistory[self.posInCommandHistory]
    def OnCmdEnter( self, event ):
        if self.callback is None:
            print("[ERROR] no callback defined for when you type a command")
            return
        cmd = self.wx_txtCommand.GetValue().strip()
        if cmd not in self.lstCommandHistory:
            self.lstCommandHistory.append(cmd)
            self.posInCommandHistory = len(self.lstCommandHistory)
        self.wx_txtCommand.Clear()
        self.callback(cmd)
class Chart(wxplot.PlotCanvas):
    COLORS = ( wx.Colour(68,114,196), wx.Colour(237,125,49), wx.Colour(165,165,165), wx.Colour(255,193,4),
               wx.Colour(91,155,213), wx.Colour(112,173,71), wx.Colour(38,68,120), wx.Colour(158,72,14),
               wx.Colour(99,99,99),  wx.Colour(153,115,0), wx.Colour(37,94,145), wx.Colour(67,104,43),
               wx.Colour(105,142,208),  wx.Colour(241,151,90), wx.Colour(183,183,183), wx.Colour(255,205,51),
               wx.Colour(124,175,221),
               )
    def __init__(self, parent_control, name):
        super().__init__(parent_control, -1)
        self.__name = name
        self.enableLegend = True
        self.enableGrid = True
        self.antiAlias = False
        self._series = dict()
        self.__dirty = False
        self.__on_update_func = None
        self.__num_series_added = 0
        self._xrange = None
        self._yrange = None
        self.configure(title=name, x_label="", y_label="", x_log=False, y_log=False)
    def get_series_color(self):
        idx = self.__num_series_added % len(self.COLORS)
        self.__num_series_added += 1
        return self.COLORS[idx]
    @property
    def name(self):
        return self.__name
    def configure(self, /, x_label=None, y_label=None, title=None,
                  y_log=None, x_log=None, x_range=None, y_range=None):
        if title is not None:
            self._title = title if isinstance(title, str) else str(title)
            self.enablePlotTitle = True if len(self._title)>0 else False
        if x_label is not None:
            self._xlabel = x_label if isinstance(x_label, str) else str(x_label)
            self.enableXAxisLabel = True if len(self._xlabel)>0 else False
        if y_label is not None:
            self._ylabel = y_label if isinstance(y_label, str) else str(y_label)
            self.enableYAxisLabel = True if len(self._ylabel)>0 else False
        if x_log is not None:
            self._xlog = True if x_log else False
        if y_log is not None:
            self._ylog = True if y_log else False
        if x_range is not None:
            ok = False
            if type(x_range) is tuple and len(x_range)==2:
                try:
                    if x_range[0]+1 < x_range[1]+1:
                        self._xrange = x_range
                    ok = True
                except:
                    pass
            if not ok:
                print(f"x_range {x_range} is invalid")
        if y_range is not None:
            ok = False
            if type(y_range) is tuple and len(y_range)==2:
                try:
                    if y_range[0]+1 < y_range[1]+1:
                        self._yrange = y_range
                    ok = True
                except:
                    pass
            if not ok:
                print(f"y_range {y_range} is invalid")
        self.logScale = (self._xlog, self._ylog)
        if len(self._series)>0:
            self.update()
    @property
    def on_update(self):
        return self.__on_update_func
    @on_update.setter
    def on_update(self, value):
        if value is None or callable(value):
            self.__on_update_func = value
    @property
    def dirty(self):
        return self.__dirty
    def update(self, / , antialiasing=False):
        self.antiAlias = antialiasing
        self.__dirty = True
        if self.__on_update_func is not None:
            self.__on_update_func()
    def redraw(self):
        self.enableAntiAliasing = self.antiAlias
        self.antiAlias = False
        self.do_redraw()
        self.__dirty = False
    def do_redraw(self):
        plot_objects = list()
        try:
            for series in self._series.values():
                if len(series.get_points())>0:
                    plot_objects.append( series.get_plot_object() )
        except RuntimeError:
            return
        if len(plot_objects)>0:
            pg = wxplot.PlotGraphics(plot_objects, self._title, self._xlabel, self._ylabel)
            try:
                self.Draw(pg, xAxis=self._xrange, yAxis=self._yrange)
            except:
                pass
    def delete_series(self, name):
        if name in self._series:
            del self._series[name]
            if hasattr(self, name):
                delattr(self, name)
    def add_series(self, name):
        if ( not name.isidentifier() or
             name in ['update', 'redraw', 'add_series', 'delete_series'] or
             ( hasattr(self, name) and name not in self._series) ):
            raise ValueError("Series name '%s' is invalid" % name)
        self.delete_series(name)
        series = self.do_add_series(name)
        if series is not None:
            self._series[name] = series
            setattr(self, name, series)
        self.update()
        return series
    def do_add_series(self, name):
        return None
    def get_series(self, name):
        if name in self._series:
            return self._series[name]
        else:
            return None
    def get_data_as_text(self):
        return ""
class ScatterSeries(object):
    def __init__(self, chart, name, color):
        self.__chart = chart
        self.__name = name
        self.__points = list()
        self.__color = color
    @property
    def name(self):
        return self.__name
    def get_plot_object(self):
        line = wxplot.PolyLine(self.__points, colour=self.__color, width=2, style=wx.PENSTYLE_SOLID, legend=self.name)
        return line
    def add_point(self, x, y):
        self.__points.append( (x, y) )
        self.__chart.update()
    def clear(self):
        self.__points = list()
        self.__chart.update()
    def get_points(self):
        return self.__points
class ScatterChart(Chart):
    def do_add_series(self, name):
        return ScatterSeries(self, name, color=self.get_series_color() )
    def get_data_as_text(self):
        lines = ""
        all_data = list()
        data_lengths = list()
        line = ""
        for (k,v) in self._series.items():
            line += k + "_x\t" + k + "_y\t"
            data = v.get_points()
            all_data.append(data)
            data_lengths.append(len(data))
        lines += line.strip() + "\r\n"
        num_series = len(data_lengths)
        num_lines = max(data_lengths)
        for i in range(num_lines):
            line = ""
            for j in range(num_series):
                if data_lengths[j]>i:
                    line += "\t".join(map(str,all_data[j][i]))+"\t"
                else:
                    line += "\t\t"
            lines += line.strip() + "\r\n"
        return lines
class TimeSeries(object):
    def __init__(self, chart, name, color, start_time=None):
        self.__chart = chart
        self.__name = name
        self.__points = list()
        self.__color = color
        self.__start_time = time.time() if start_time is None else start_time
    @property
    def name(self):
        return self.__name
    def get_plot_object(self):
        line = wxplot.PolyLine(self.__points, colour=self.__color, width=2, style=wx.PENSTYLE_SOLID, legend=self.name)
        return line
    def add_value(self, value, t=None):
        if t is None:
            t = time.time()
        self.__points.append( (t-self.__start_time, value) )
        self.__chart.update()
    def clear(self):
        self.__points = list()
        self.__chart.update()
    def get_points(self):
        return self.__points
class TimeChart(Chart):
    start_time = None
    def do_add_series(self, name):
        if self.start_time is None:
            self.start_time = time.time()
        return TimeSeries(self, name, self.get_series_color(), self.start_time)
    def get_data_as_text(self):
        lines = ""
        all_data = list()
        data_lengths = list()
        next_t = list()
        data_pos = list()
        line = "time\t"
        for (k,v) in self._series.items():
            line += k + "\t"
            data = v.get_points()
            all_data.append(data)
            data_lengths.append(len(data))
            data_pos.append(0)
            next_t.append(None)
        lines += line.strip() + "\r\n"
        num_series = len(data_lengths)
        max_lines = sum(data_lengths)
        for j in range(num_series):
            if data_lengths[j]>0:
                next_t[j] = all_data[j][0][0]
        for _ in range(max_lines):
            try:
                t = min(x for x in next_t if x is not None)
            except:
                break
            line = "%f" % t
            for j in range(num_series):
                if next_t[j] is None:
                    line += "\t"
                    continue
                if next_t[j] <= t+0.0001:
                    pos = data_pos[j]
                    line += "\t" + str(all_data[j][pos][1])
                    pos += 1
                    if pos<data_lengths[j]:
                        data_pos[j] = pos
                        next_t[j] = all_data[j][pos][0]
                    else:
                        next_t[j] = None
                else:
                    line += "\t"
            lines += line.strip() + "\r\n"
        return lines
    def add_values(self, t=None, **values):
        if t is None:
            t = time.time()
        for name, value in values.items():
            series = self.get_series(name)
            if series is not None:
                series.add_value(value, t)
class HistogramSeries(object):
    def __init__(self, chart, name, binsize, color):
        self.__chart = chart
        self.__name = name
        self.__points = dict()
        self.__binsize = binsize
        self.__color = color
    @property
    def name(self):
        return self.__name
    def get_plot_object(self):
        bs = self.__binsize
        data = list()
        prev = None
        prev_val = None
        for k in sorted(self.__points.keys()):
            if prev is None:
                data.append( (k*bs,0) )
                data.append( (k*bs, self.__points[k]) )
            elif k != prev+1:
                data.append( ((prev+1)*bs,0) )
                data.append( (k*bs,0) )
                data.append( (k*bs, self.__points[k]) )
            else:
                if prev_val != self.__points[k]:
                    data.append( (k*bs, self.__points[k]) )
            data.append( ((k+1) * bs, self.__points[k]) )
            prev_val = self.__points[k]
            prev = k
        data.append( ((prev+1)*bs,0) )
        line = wxplot.PolyLine(data, colour=self.__color, width=2, style=wx.PENSTYLE_SOLID, legend=self.name)
        return line
    def add_value(self, x):
        binnum = int( x / self.__binsize )
        if binnum in self.__points:
            self.__points[binnum] = self.__points[binnum] + 1
        else:
            self.__points[binnum] = 1
        self.__chart.update()
    def add_values(self, data):
        for x in data:
            binnum = int( x / self.__binsize )
            if binnum in self.__points:
                self.__points[binnum] = self.__points[binnum] + 1
            else:
                self.__points[binnum] = 1
        self.__chart.update()
    def clear(self):
        self.__points = [0 for _ in range(100)]
        self.__chart.update()
    def get_points(self):
        return self.__points
class HistogramChart(Chart):
    def __init__(self, parent_control, name, binsize):
        super().__init__(parent_control, name)
        self.__binsize = binsize
        self._xlabel = "Value"
        self._ylabel = "Count"
    def do_add_series(self, name):
        return HistogramSeries(self, name, self.__binsize, color=self.get_series_color() )
    def get_data_as_text(self):
        lines = ""
        data = list()
        min_x = None
        max_x = None
        line = "Value"
        for ser in self._series:
            line += "\t" + ser
        lines += line.strip() + "\r\n"
        for ser in self._series.values():
            points = ser.get_points()
            if min_x is None:
                min_x = min(points.keys())
            else:
                min_x = min( min_x, min(points.keys()))
            if max_x is None:
                max_x = max(points.keys())
            else:
                max_x = max( max_x, max(points.keys()))
            data.append( points )
        for x in range(min_x,max_x+1):
            line = str( x * self.__binsize )
            for pts in data:
                if x in pts:
                    line += "\t%d" % pts[x]
                else:
                    line += "\t0"
            lines += line.strip() + "\r\n"
        return lines
class PanelCharts( PanelCharts_Base):
    def __init__( self, parent):
        super().__init__(parent)
        self.__dirty = False
        self.charts = dict()
        self.default_savedir = os.getcwd()
    def update(self):
        self.__dirty = True
    def OnRedrawTimer( self, event ):
        if self.__dirty:
            self.__dirty = False
            for x in self.charts.values():
                x.redraw()
    def OnRadioBoxMouseMode( self, event ):
        for chart in self.charts.values():
            if self.m_rbxMouseMode.Selection==0:
                chart.enableZoom = False
                chart.enableDrag = False
            elif self.m_rbxMouseMode.Selection==1:
                chart.enableZoom = True
                chart.enableDrag = False
            else:
                chart.enableDrag = True
                chart.enableZoom = False
    def BtnCopyDataClick( self, event ):
        index = self.m_nbkPlots.GetSelection()
        if index == wx.NOT_FOUND or self.m_nbkPlots.GetPageText(index) not in self.charts:
            wx.MessageBox( "Cannot find chart on current page", "HappyScript", wx.OK | wx.ICON_ERROR )
        chart = self.charts[self.m_nbkPlots.GetPageText(index)]
        try:
            clipdata = wx.TextDataObject()
            lines = chart.get_data_as_text()
            clipdata.SetText(lines)
            wx.TheClipboard.Open()
            wx.TheClipboard.SetData(clipdata)
            wx.TheClipboard.Close()
            wx.MessageBox( "Data written to clipboard", "HappyScript", wx.OK | wx.ICON_INFORMATION )
        except:
            wx.MessageBox( "Could not write text to clipboard", "HappyScript", wx.OK | wx.ICON_ERROR )
    def OnMakePretty( self, event ):
        index = self.m_nbkPlots.GetSelection()
        if index == wx.NOT_FOUND or self.m_nbkPlots.GetPageText(index) not in self.charts:
            wx.MessageBox( "Cannot find chart on current page", "HappyScript", wx.OK | wx.ICON_ERROR )
        chart = self.charts[self.m_nbkPlots.GetPageText(index)]
        chart.update(antialiasing = True)
    def OnBtnSaveBitmap( self, event ):
        index = self.m_nbkPlots.GetSelection()
        if index == wx.NOT_FOUND or self.m_nbkPlots.GetPageText(index) not in self.charts:
            wx.MessageBox( "Cannot find chart on current page", "HappyScript", wx.OK | wx.ICON_ERROR )
        chart = self.charts[self.m_nbkPlots.GetPageText(index)]
        try:
            with wx.FileDialog(self, "Output file name", wildcard="PNG files(*.png)|*.png",
                    defaultDir = self.default_savedir,
                    style=wx.FD_SAVE | wx.FD_OVERWRITE_PROMPT) as fdlg:
                if fdlg.ShowModal() == wx.ID_OK:
                    filename = fdlg.GetPath()
                    chart.SaveFile(filename)
                    self.default_savedir = os.path.dirname(filename)
        except:
            wx.MessageBox( "Could not write bitmap", "HappyScript", wx.OK | wx.ICON_ERROR )
    def get_chart(self, name):
        if name in self.charts:
            return self.charts[name]
        else:
            return None
    def delete_chart(self, name):
        if not name in self.charts:
            return
        ch = self.charts[name]
        page_num = self.m_nbkPlots.FindPage(ch)
        if page_num != wx.NOT_FOUND:
            self.m_nbkPlots.DeletePage(page_num)
        del self.charts[name]
    def add_scatter_chart(self, name ):
        self.delete_chart(name)
        chart = ScatterChart(self.m_nbkPlots, name)
        chart.on_update = self.update
        self.charts[name] = chart
        self.m_nbkPlots.AddPage( chart, name, True)
        return chart
    def add_time_chart(self, name ):
        self.delete_chart(name)
        chart = TimeChart(self.m_nbkPlots, name)
        chart.on_update = self.update
        self.charts[name] = chart
        self.m_nbkPlots.AddPage( chart, name, True)
        return chart
    def add_histogram(self, name, binsize ):
        self.delete_chart(name)
        chart = HistogramChart(self.m_nbkPlots, name, binsize)
        chart.on_update = self.update
        self.charts[name] = chart
        self.m_nbkPlots.AddPage( chart, name, True)
        return chart
try:
    from agw import aui
except ImportError:
    import wx.lib.agw.aui as aui
class FormMain(FormMain_Base):
    VALID_OPERATORS = ("OPERATOR", "TECHNICIAN", "ENGINEER", "EXPERT")
    def __init__(self, script_manager ):
        ScriptArtwork.register()
        super().__init__(None)
        self.logFile = None
        self._script_manager = script_manager
        self.on_gui_timer = None
        self.on_log_timer = None
        self.current_user = None
        scriptLocals = { "_mngr_": self._script_manager }
        self._shell_window = py.shell.Shell( self, -1, introText = None, locals=scriptLocals )
        info = wx.aui.AuiPaneInfo().Caption("Python shell").Name("PY_Shell")
        info.Bottom().Layer(1).Dock().CloseButton(False)
        self.m_mgr.AddPane(self._shell_window, info)
        info = wx.aui.AuiPaneInfo().Caption("Control Panels").Name("ControlPanels")
        info.Left().Layer(1).Position(0).CloseButton(False).MinSize( (100,200) )
        self._nbk_control_panels = wx.Notebook( self, wx.ID_ANY, wx.DefaultPosition, wx.DefaultSize, 0 )
        self.m_mgr.AddPane(self._nbk_control_panels, info)
        info = wx.aui.AuiPaneInfo().Caption("Messages").Name("Messages")
        info.Center().Layer(1).Dock().CloseButton(False).MinSize( (100,200) )
        self.msgArea = PanelMessages(self)
        self.m_mgr.AddPane(self.msgArea, info)
        info = wx.aui.AuiPaneInfo().Caption("Tests").Name("Tests")
        info.Left().Layer(1).Dock().CloseButton(False).MinSize( (100,200) )
        self.pnlTests = PanelTests(self, self._script_manager)
        self.m_mgr.AddPane(self.pnlTests, info)
        info = wx.aui.AuiPaneInfo().Caption("Log").Name("Log")
        info.Bottom().Layer(1).Dock().CloseButton(False).MinSize( (100,200) )
        self.logPane = PanelLog(self)
        self.m_mgr.AddPane(self.logPane, info)
        info = wx.aui.AuiPaneInfo().Caption("Charts").Name("Charts")
        info.Bottom().Layer(1).Dock().CloseButton(False).MinSize( (100,200) )
        self.chartsPane = PanelCharts(self)
        self.m_mgr.AddPane(self.chartsPane, info)
        info = wx.aui.AuiPaneInfo().Caption("Scripts").Name("Scripts")
        info.Right().Layer(1).CloseButton(False).MinSize( (150,150) )
        self._nbk_scripts = wx.Notebook( self, wx.ID_ANY, wx.DefaultPosition, wx.DefaultSize, 0 )
        self.m_mgr.AddPane(self._nbk_scripts, info)
        self.ALL_BUTTONS = [self.m_btnTestList, self.m_btnMessages, self.m_btnLogging, self.m_btnPython, self.m_btnScripts, self.m_btnControls, self.m_btnCharts ]
        self.ALL_PANELS  = [self._nbk_scripts, self._nbk_control_panels, self.logPane, self.pnlTests, self.msgArea, self._shell_window, self.chartsPane ]
    def BeforeShow(self):
        self.SwitchUser(None)
        self.m_guiTimer.Start(20)
    def OnMnuLayoutClicked( self, event ):
        tb = event.GetEventObject()
        tb.SetToolSticky(event.GetId(), True)
        rect = tb.GetToolRect(event.GetId())
        pt = tb.ClientToScreen(rect.GetBottomLeft())
        pt = self.ScreenToClient(pt)
        self.PopupMenu(self.m_mnuLayout, pt)
        tb.SetToolSticky(event.GetId(), False)
    def AddCustomPanel(self, title, panelType, **args):
        args["parent"] = self._nbk_control_panels
        newPanel = panelType(**args)
        self._nbk_control_panels.AddPage( newPanel, title, False)
    def HideCustomPanels(self):
        if self._nbk_control_panels.GetPageCount()==0:
            info = self.m_mgr.GetPaneByName("ControlPanels")
            info.Hide()
            self.m_mgr.Update()
    def SwitchUser(self, user):
        if user is None:
            ini = configparser.ConfigParser()
            ini.read( ["happyscript.ini"] )
            user = ini.get("varia", "CurrentUser", fallback="ENGINEER" )
            if user not in self.VALID_OPERATORS:
                user = "OPERATOR"
        if self.current_user == user:
            return
        if self.current_user is not None:
            self.SavePosition()
        self.current_user = user
        self.RestorePosition()
        if self.current_user=="OPERATOR":
            hide_panels = [self.logPane, self._nbk_scripts, self._nbk_control_panels, self._shell_window, self.chartsPane]
            bitmap = ScriptArtwork.GetBitmap("user_operator")
            center = self.msgArea
            enable_buttons = list()
        elif self.current_user=="TECHNICIAN":
            hide_panels = [self.logPane, self._nbk_scripts, self._shell_window, self.chartsPane]
            bitmap = ScriptArtwork.GetBitmap("user_technician")
            center = self.msgArea
            enable_buttons = [ self.m_btnControls ]
        elif self.current_user=="ENGINEER":
            hide_panels = list()
            bitmap = ScriptArtwork.GetBitmap("user_engineer")
            center = self.logPane
            enable_buttons = self.ALL_BUTTONS
        else:
            hide_panels = list()
            bitmap = ScriptArtwork.GetBitmap("user_expert")
            center = self._shell_window
            enable_buttons = self.ALL_BUTTONS
        self.m_btnLayout.SetBitmap(bitmap)
        for btn in self.ALL_BUTTONS:
            enable = True if btn in enable_buttons else False
            self.m_mnuToolbar.EnableTool(btn.GetId(), enable )
        if center==self.logPane:
            self.m_mnuToolbar.EnableTool(self.m_btnLogging.GetId(), False)
        elif center==self._shell_window:
            self.m_mnuToolbar.EnableTool(self.m_btnPython.GetId(), False)
        pane = self.m_mgr.GetPane(center)
        pane.Dock().Center()
        if not pane.IsShown():
            pane.Show(True)
        for panel in [self.msgArea, self.logPane, self._shell_window]:
            if panel == center:
                continue
            pane = self.m_mgr.GetPane(panel)
            if pane.dock_direction == aui.AUI_DOCK_CENTER:
                pane.Dock().Bottom()
        if self._nbk_control_panels.PageCount==0:
            self.m_mnuToolbar.EnableTool(self.m_btnControls.GetId(), False)
            hide_panels.append(self._nbk_control_panels)
        for panel in hide_panels:
            pane = self.m_mgr.GetPane(panel)
            if pane.IsShown():
                if pane.IsDocked():
                    pane.Float()
                pane.Show(False)
        self.m_mnuToolbar.Show()
        self.m_mgr.Update()
    def RestorePosition( self ):
        if self.current_user not in self.VALID_OPERATORS:
            return
        section = "LAYOUT_" + self.current_user
        ini = configparser.ConfigParser()
        ini.read( ["happyscript.ini"] )
        if ini.has_section(section):
            x = ini.getint(section, "WindowX")
            y = ini.getint(section, "WindowY")
            width = ini.getint(section, "WindowWidht" )
            height = ini.getint(section, "WindowHeight" )
            self.SetPosition((x,y))
            self.SetSize((width, height))
            if ini.has_option(section, "pane_layout"):
                panes = ini.get(section, "pane_layout")
                try:
                    self.m_mgr.LoadPerspective(panes, False)
                except:
                    pass
    def SavePosition( self, also_save_user = False ):
        if self.current_user not in self.VALID_OPERATORS:
            return
        section = "LAYOUT_" + self.current_user
        x, y = self.GetPosition()
        width, height = self.GetSize()
        ini = configparser.ConfigParser()
        ini.read( ["happyscript.ini"] )
        if not ini.has_section(section):
            ini.add_section(section)
        ini.set(section, "WindowX", str(x) )
        ini.set(section, "WindowY", str(y) )
        ini.set(section, "WindowWidht", str(width) )
        ini.set(section, "WindowHeight", str(height) )
        ini.set(section, "pane_layout", self.m_mgr.SavePerspective() )
        if also_save_user:
            if not ini.has_section("varia"):
                ini.add_section("varia")
            ini.set("varia", "CurrentUser", self.current_user )
        with open("happyscript.ini", "w") as inifile:
            ini.write(inifile)
    def OnFormClose(self, event):
        self.m_guiTimer.Stop()
        FormOnTestFailure.cleanup()
        FormSerials.cleanup()
        self.SavePosition(True)
        self.m_mgr.UnInit()
        self.Destroy()
        wx.GetApp().ExitMainLoop()
    def TogglePanel(self, panel):
        pane = self.m_mgr.GetPane(panel)
        if pane.IsShown():
            if pane.IsDocked():
                pane.Float()
            pane.Show(False)
        else:
            pane.Dock()
            pane.Show(True)
        self.m_mgr.Update()
    def OnBtnScripts( self, event ):
        self.TogglePanel(self._nbk_scripts)
    def OnBtnPython( self, event ):
        self.TogglePanel(self._shell_window)
    def OnBtnLogging( self, event ):
        self.TogglePanel(self.logPane)
    def OnBtnMessages( self, event ):
        self.TogglePanel(self.msgArea)
    def OnBtnTestList( self, event ):
        self.TogglePanel(self.pnlTests)
    def OnBtnCharts( self, event ):
        self.TogglePanel(self.chartsPane)
    def OnBtnControls( self, event ):
        self.TogglePanel(self._nbk_control_panels)
    def OnLayoutOperator( self, event ):
        self.SwitchUser("OPERATOR")
    def OnLayoutTechnician( self, event ):
        self.SwitchUser("TECHNICIAN")
    def OnLayoutEngineer( self, event ):
        self.SwitchUser("ENGINEER")
    def OnLayoutExpert( self, event ):
        self.SwitchUser("EXPERT")
    def OnResetLayout( self, event ):
        event.Skip()
    def OnBtnExit( self, event ):
        self.Close()
    def PushShellCommand(self, cmd):
        self._shell_window.push(cmd, True)
    def OnGuiTimer( self, event ):
        if self.on_gui_timer is not None:
            self.on_gui_timer()
        if self.on_log_timer is not None:
            self.on_log_timer()
class PanelScripts2( PanelScripts_Base):
    def __init__( self, parent, script_reader, script_control ):
        PanelScripts_Base.__init__(self, parent)
        self._reader = script_reader
        self._script_ctrl = script_control
        self.tree_root = self.treeScripts.AddRoot("DUMMY")
        self.load_treeview()
    def load_treeview(self):
        self.treeScripts.DeleteChildren(self.tree_root)
        for modname in self._reader.get_file_list():
            child = self.treeScripts.AppendItem(self.tree_root, modname)
            for funcname in self._reader.get_func_names(modname):
                self.treeScripts.AppendItem(child, funcname)
    def OnBtnReload( self, event ):
        if self._script_ctrl.is_busy():
            msg = "A script is still running.  Press 'abort' first."
            wx.MessageBox( msg, "HappyScript", wx.OK | wx.ICON_WARNING )
            return
        self._reader.reload()
        self.load_treeview()
    def OnTreeLeftDoubleClick( self, event ):
        pt = event.GetPosition();
        item, _ = self.treeScripts.HitTest(pt)
        self.ExecuteScriptForItem(item)
    def OnTreeKeyDown( self, event ):
        keycode = event.GetKeyCode()
        if keycode==wx.WXK_RETURN:
            item = self.treeScripts.GetSelection()
            self.ExecuteScriptForItem(item)
    def ExecuteScriptForItem(self, item):
        if item:
            parent = self.treeScripts.GetItemParent(item)
            if parent.IsOk() and parent!=self.tree_root:
                if self._script_ctrl.is_busy():
                    print("Another script is already running")
                else:
                    filename = self.treeScripts.GetItemText(parent)
                    funcname = self.treeScripts.GetItemText(item)
                    scriptname = "%s.%s.%s" % (self._reader.group_name, filename, funcname)
                    self._script_ctrl.run(scriptname)
    def OnTreeSelChanged( self, event ):
        txt = "no help"
        try:
            item = event.GetItem()
            if item:
                parent = self.treeScripts.GetItemParent(item)
                if parent.IsOk() and parent!=self.tree_root:
                    filename = self.treeScripts.GetItemText(parent)
                    funcname = self.treeScripts.GetItemText(item)
                    txt = self._reader.get_help(filename, funcname)
        except:
            pass
        self.txtHelp.SetValue(txt)
        event.Skip()
    def btn_stopOnButtonClick( self, event ):
        self._script_ctrl.stop()
class ScriptUserAbortException(Exception):
    def __init__(self, value):
        self.value = value
    def __str__(self):
        return repr(self.value)
class ScriptRecursiveAbortException(Exception):
    def __init__(self, value):
        self.value = value
    def __str__(self):
        return repr(self.value)
class ScriptControl:
    def __init__(self):
        self.m_stop_script = False
        self._is_busy = False
        self.on_run_script = None
    def set_busy(self, is_busy):
        self._is_busy = is_busy
        self.m_stop_script = False
    def is_busy(self):
        return self._is_busy
    def stop(self):
        if self._is_busy:
            print("'stop' flag is set.  Scripts may stop soon.")
        else:
            print("Normally no script is active, but I'll set the 'stop' flag anyway.")
        self.m_stop_script = True
    def ok(self):
        wx.Yield()
        return not self.m_stop_script
    def check(self):
        wx.Yield()
        if self.m_stop_script:
            raise ScriptUserAbortException( "Script stopping on user request" )
    def sleep(self, time_in_seconds):
        t = time_in_seconds
        wx.Yield()
        while t>0:
            if t > 0.5:
                time.sleep(0.5)
            else:
                time.sleep(t)
            t = t-0.5;
            wx.Yield()
            if self.m_stop_script:
                raise ScriptUserAbortException( "Script stopping on user request" )
    def run(self, script_name, **argv):
        if self.on_run_script is None:
            raise ScriptUserAbortException( "Cannot start script : no callback function is set." )
        else:
            return self.on_run_script(script_name, **argv)
class PrintRedirect:
    _redir = None
    _reerr = None
    _old_redir = None
    def __init__(self, globalloghandler, level=None):
        self.level = logging.INFO if level is None else level
        self.loghandler = globalloghandler
    def write(self,txt):
        txt = txt.strip()
        if txt=='\n' or len(txt)==0:
            return
        if self.level==logging.ERROR and txt=="^":
            return
        level = self.level
        if "[FAIL]" in txt:
            level = logging.ERROR
            txt = txt.replace("[FAIL]","").strip()
        elif "[ERROR]" in txt:
            level = logging.ERROR
            txt = txt.replace("[ERROR]","").strip()
        elif "[PASS]" in txt:
            level = logging.WARN+1
            txt = txt.replace("[PASS]","").strip()
        elif "[WARN]" in txt:
            level = logging.WARN
            txt = txt.replace("[WARN]","").strip()
        self.loghandler.add_line_from_print(txt, level)
    def flush(self):
        pass
    @classmethod
    def start_redirection(cls, handler):
        cls._redir = PrintRedirect(handler)
        cls._reerr = PrintRedirect(handler,logging.ERROR)
        cls._old_redir = ( sys.stdout, sys.stderr )
        sys.stdout=cls._redir
        sys.stderr=cls._reerr
    @classmethod
    def stop_redirection(cls):
        if cls._old_redir is not None:
            sys.stdout, sys.stderr = cls._old_redir
            cls._old_redir = None
class LogToText(object):
    def __init__(self):
        self.logfilename = "happyscript.log"
        self.tempfilename = self.logfilename
        self.handle = None
        self.last_flush_time = time.time()
    def set_filename(self, filename, /, use_temp=False):
        self.close()
        self.logfilename = filename
        if use_temp:
            self.tempfilename = os.path.splitext(filename)[0] + ".tmp"
        else:
            self.tempfilename = filename
    def open(self):
        if self.handle is not None:
            return
        self.handle = open(self.tempfilename, "a+")
        self.last_flush_time = time.time()
        self.handle.write("****** STARTING log FILE ********\n")
    def close(self):
        if self.handle is None:
            return
        self.handle.write("****** CLOSING log FILE ********\n")
        self.handle.close()
        if self.logfilename!=self.tempfilename:
            if os.path.isfile(self.logfilename):
                os.remove(self.logfilename)
            if os.path.isfile(self.tempfilename):
                os.rename(self.tempfilename, self.logfilename)
        self.handle = None
    def handle_log(self, logdata):
        self.open()
        msg = logdata.msg.strip()
        if logdata.levelno >= logging.WARN:
            self.handle.write(f"{logdata.levelname}: {msg}\n")
        else:
            self.handle.write(msg+"\n")
        if logdata.exc_info is not None:
            self.handle.write(logdata.exc_info)
        t = time.time()
        if t - self.last_flush_time > 5:
            self.handle.flush()
            self.last_flush_time = t
class LogData():
    msg = ""
    levelno = 0
    levelname = "[?]"
    exc_info = None
class PanelFormatter(logging.Formatter):
    def __init__(self):
        super().__init__()
    def format(self, record):
        if len(record.args) > 0:
            try:
                msg = record.msg % record.args
            except TypeError:
                msg = record.msg + " !!! BAD PARAMETERS !!! " + str(record.args)
        else:
            msg = record.msg
        return msg
class GlobalLogHandler(logging.StreamHandler):
    def __init__(self):
        super().__init__(None)
        formatter = PanelFormatter()
        self.setFormatter(formatter)
        self._callbacks = list()
        self._queue = queue.Queue()
    def add_callback(self, func):
        self._callbacks.append(func)
    def run_callbacks(self):
        while not self._queue.empty():
            data = self._queue.get()
            for func in self._callbacks:
                try:
                    func(data)
                except:
                    pass
    def emit(self, record):
        data = LogData()
        data.levelname = record.levelname
        data.levelno = record.levelno
        data.msg = self.format(record)
        if record.exc_info and str(record.exc_info[1])!="'Stopping parent script...'":
            exc_info = None
            tb = traceback.format_exception(record.exc_info[0], record.exc_info[1], record.exc_info[2])
            for line in tb[:-1 or None]:
                if line.startswith("Traceback "):
                    continue
                if "in execute_threadfunc" in line:
                    continue
                if exc_info is None:
                    exc_info = line
                else:
                    exc_info += "\r\n" + line
            data.exc_info = exc_info
        self._queue.put(data)
    def add_line_from_print(self, msg, level):
        data = LogData()
        data.levelno = level
        data.levelname = logging.getLevelName(level)
        data.msg = msg
        self._queue.put(data)
class ScriptThreadRunner:
    logger = logging.getLogger("happyscript.runner")
    MARKER_LEVEL = 25
    def __init__(self, ctrl):
        self._ctrl = ctrl
        self._recurse_count = 0
        self.top_script_name = ''
        self.last_result = False
        self.busy = False
    def execute_script(self, script_name, script_func, argvalues):
        self.last_result = False
        self.busy = True
        if threading.currentThread().getName()=="ScriptThread":
            self.execute_threadfunc(script_name, script_func, argvalues)
        elif self._recurse_count>0:
            self.logger.error( "Script '%s' already running.  Wait until it completed." % self.top_script_name )
        else:
            self.top_script_name = script_name
            thread = threading.Thread(name = "ScriptThread", target=self.execute_threadfunc, args=(script_name, script_func, argvalues) )
            thread.start()
    def execute_threadfunc(self, script_name, script_func, argvalues):
        if self._recurse_count<0:
            self._recurse_count = 0
        tstamp = datetime.datetime.now().strftime("%m/%d_%H:%M")
        self.logger.log(self.MARKER_LEVEL, "__________%s__________%s__" % (script_name, tstamp) )
        test_passed = False
        all_tests_done = False
        try:
            self._recurse_count += 1
            self._ctrl.set_busy(True)
            script_func( *argvalues )
            test_passed = True
        except ScriptUserAbortException as _:
            self.logger.error("Script stopped by user")
        except Exception as e:
            if self._ctrl.m_stop_script:
                self.logger.error("Script stopped by user")
            else:
                logging.error(str(e), exc_info = e)
        finally:
            self._recurse_count -= 1
            if self._recurse_count<=0:
                all_tests_done = True
            if test_passed:
                self.logger.log(self.MARKER_LEVEL, "\\_________%s__________ PASS ______/" % script_name )
            else:
                self.logger.log(self.MARKER_LEVEL, "\\_________%s__________ FAIL ______/" % script_name )
        if self._recurse_count>0 and test_passed==False:
            raise ScriptRecursiveAbortException("Stopping parent script...")
        if all_tests_done:
            self._recurse_count = 0
            self.top_script_name=''
            self.last_result = test_passed
            self._ctrl.set_busy(False)
            self.busy = False
class ScriptRunner:
    logger = logging.getLogger("happyscript.runner")
    def __init__(self, script_params, script_readers, script_control):
        self.script_params = script_params
        self._readers = script_readers
        self._recurse_count = 0
        self.start_ok = False
        self.thread_runner = ScriptThreadRunner(script_control)
    @property
    def test_passed(self):
        return self.start_ok and self.thread_runner.last_result
    @property
    def busy(self):
        return self.thread_runner.busy
    def run_script(self, script_name, **argv):
        parts = script_name.split(".")
        if len(parts) != 3:
            self.logger.error("Must provide script name as dirname.filename.scriptname")
            return
        self.start_script(parts[0], parts[1], parts[2], **argv)
    def start_script(self, group_name, filename, funcname, **extra_params):
        self.start_ok = False
        scriptname = "%s.%s.%s" % (group_name, filename, funcname)
        if not group_name in self._readers:
            self.logger.error("Cannot start %s : group %s not found" % (scriptname, group_name))
            return
        func = self._readers[group_name].get_func(filename, funcname)
        if func is None:
            self.logger.error("Cannot start %s : function not found" % scriptname)
            return
        if (extra_params is None) or (not isinstance(extra_params,dict)):
            extra_params = dict()
        (argvalues, missing) = self.script_params.get_parameters(func, extra_params)
        if len(missing)>0:
            self.logger.error( "Error : missing value for parameter(s) %s" % ("".join(missing) ) )
            self.logger.error( "        Make sure to use valid names as parameters for your function.")
            self.logger.log(self.MARKER_LEVEL, "\\_________%s_________ ERROR ______/" % scriptname )
            return
        self.thread_runner.execute_script(scriptname, func, argvalues)
        self.start_ok = True
class ScriptParams(object):
    def __init__(self, ask_gui = None):
        self._ask_gui = ask_gui
        self.argumentList = dict()
        self.on_add_object = None
    def add_object(self, objName, theObject):
        objName = objName.lower().strip()
        if objName=="_mngr_" or (objName is None) or len(objName)==0 or not objName.isidentifier():
            self.on_add_object("invalid object name '%s' " % objName, None)
            return
        elif theObject is None:
            self.on_add_object("Value for object %s is None" % objName, None)
            return
        self.argumentList[objName] = theObject
        if self.on_add_object is not None:
            self.on_add_object( objName, theObject )
    def add_objects(self, *args, **kwargs):
        for obj in args:
            if obj is None:
                continue
            try:
                if hasattr(obj, "name") and isinstance(obj.name, str):
                    self.add_object(obj.name, obj)
                elif hasattr(obj, "_name") and isinstance(obj._name, str):
                    self.add_object(obj._name, obj)
                elif hasattr(obj, "__name__") and isinstance(obj.__name__, str):
                    self.add_object(obj.__name__, obj)
            except AttributeError:
                self.on_add_object("No name found for object that was added", None)
                pass
        for key, value in kwargs.items():
            self.add_object(key, value)
    def get_param(self, param_name):
        if param_name in self.argumentList:
            return self.argumentList[param_name]
        else:
            return None
    def get_parameters(self, scriptObject, extraParams=None):
        if (extraParams is None) or (not isinstance(extraParams,dict)):
            extraParams = dict()
        missing = list()
        argnames = inspect.getfullargspec(scriptObject)[0]
        doctxt = inspect.getdoc( scriptObject )
        argvalues = list()
        for x in argnames:
            if x in self.argumentList:
                argvalues.append( self.argumentList[x] )
            elif x in extraParams:
                argvalues.append( extraParams[x] )
            elif self._ask_gui is not None:
                argvalues.append( self._find_missing_parameter(x, doctxt) )
            else:
                argvalues.append( None )
                missing.append(x)
        return (argvalues, missing)
    def _find_missing_parameter(self, paramName, docTxt ):
        result = None
        lines = docTxt.splitlines()
        for line in lines:
            if "@param " + paramName + " " in line:
                if ':' in line:
                    question = line[line.find(':')+1:].strip()
                else:
                    question = "Give parameter %s" % paramName
                try:
                    if '[num]' in line:
                        result = self._ask_gui.ask_number(question)
                    else:
                        result = self._ask_gui.ask(question)
                except ScriptUserAbortException as _:
                    pass
                break
        return result
class ScriptReader:
    def __init__(self, script_dir, group_name = None):
        if group_name is None:
            group_name = os.path.basename(script_dir)
        self.group_name = group_name
        self._script_dir = script_dir
        self.func_help = dict()
        self.func_obj = dict()
        self.mdl = dict()
        self.func_names = dict()
    def reload( self ):
        self.func_help.clear()
        self.func_obj.clear()
        self.mdl.clear()
        self.func_names.clear()
        print("Reading scripts from " + self._script_dir)
        files = os.listdir(self._script_dir)
        msg = ""
        for x in files:
            if not x.endswith(".py") or x=="__init__.py":
                continue
            print( "---> " + x )
            error = self.read_single_file(x)
            if error:
                msg = msg + "\n" + error
        if len(msg)>0:
            msg = "There were (more) errors :" + msg
            wx.MessageBox( msg, "Error importing files", wx.OK | wx.ICON_WARNING )
    def read_single_file(self, filename):
        fullfilename = os.path.join(self._script_dir, filename)
        try:
            child = None
            modname = os.path.splitext(filename)[0]
            spec = importlib.util.spec_from_file_location(modname, fullfilename)
            mdl = importlib.util.module_from_spec(spec)
            spec.loader.exec_module(mdl)
            self.mdl[modname] = mdl
            self.func_names[modname] = list()
            for x in inspect.getmembers(mdl, inspect.isfunction):
                funcname = x[0]
                doctxt = inspect.getdoc( x[1] )
                if not doctxt:
                    continue
                if not ("@public" in doctxt) and not ("\\public" in doctxt):
                    continue
                doctxt = doctxt.replace("@public","").replace("\\public","")
                if doctxt:
                    self.func_help["%s.%s" % (modname,funcname)] = doctxt
                else:
                    self.func_help["%s.%s" % (modname,funcname)] = "No help"
                self.func_obj["%s.%s" % (modname,funcname)] = x[1]
                self.func_names[modname].append(funcname)
        except:
            msg = traceback.format_exc()
            wx.MessageBox( msg, "Error importing file %s" % (fullfilename), wx.OK | wx.ICON_WARNING )
        for fname in list(self.func_names.keys()):
            if len(self.func_names[fname]) == 0:
                del self.func_names[fname]
        return None
    def get_file_list(self):
        if len(self.func_names)==0:
            return list()
        result = sorted(self.func_names.keys())
        return result
    def get_func_names(self, filename):
        if not filename in self.func_names:
            return list()
        return sorted(self.func_names[filename])
    def get_help(self, filename, funcname):
        itemname = "%s.%s" % (filename, funcname)
        if itemname in self.func_help:
            return self.func_help[itemname]
        else:
            return "No help for %s.%s" % (filename, funcname)
    def get_func(self, filename, funcname):
        itemname = "%s.%s" % (filename, funcname)
        if itemname in self.func_obj:
            return self.func_obj[itemname]
        else:
            return None
class FormStop( FormStop_base):
    def __init__( self, message, mngr ):
        super().__init__(mngr.dialog)
        self._mngr = mngr
        self.m_lblMessage.Label = message
    def OnBtnStop( self, event ):
        self._mngr.stop_scripts()
        self.Close()
    def update_message(self, msg):
        self.m_lblMessage.Label = msg
class FormAskImage( FormAskImage_Base):
    def __init__( self, message, filename, arrow_pos=None, yesno=False, cancel=False, numeric=False ):
        super().__init__(None)
        self.m_txtMessage.Label = message
        self.numeric = numeric
        self.yesno = yesno
        self.result = None
        if yesno:
            self.m_btnOK.Label = "Yes"
            self.m_txtValue.Hide()
        else:
            self.m_btnNo.Hide()
        if not cancel:
            self.m_btnCancel.Hide()
        img = wx.Image(filename, type=wx.BITMAP_TYPE_ANY)
        (img_x, img_y) = img.GetSize()
        disp = wx.Display(wx.Display.GetFromWindow(self))
        (x1, y1, sx, sy) = disp.GetGeometry()
        fx = (sx*9/10 - 200) / img_x
        fy = (sy*9/10 - 50) / img_y
        if fx<fy:
            factor = fx
        else:
            factor = fy
        img_x = int(img_x * factor)
        img_y = int(img_y * factor)
        img = img.Scale(img_x, img_y)
        bitmap = img.ConvertToBitmap()
        self.draw_arrow(bitmap, arrow_pos, factor)
        self.m_bitmap.SetBitmap(bitmap)
        self.SetSize( x1 + (sx - img_x - 220)//2, y1 + (sy-img_y-70)//2, img_x + 220, img_y + 70)
        self.m_txtMessage.Wrap(self.m_txtMessage.Size.Width)
    def draw_arrow(self, bitmap, arrow_pos, scale=1.0):
        if arrow_pos is None:
            return
        ax = int( arrow_pos[0] * scale )
        ay = int( arrow_pos[1] * scale )
        (max_x, max_y) = bitmap.GetSize()
        fx = 1 if ax+100 < max_x else -1
        fy = 1 if ay+100 < max_y else -1
        dc = wx.MemoryDC(bitmap)
        dc.SetPen(wx.Pen(colour='red', width=8, style=wx.SOLID))
        dc.DrawLine(ax, ay, ax+100*fx, ay+100*fy)
        dc.DrawLine(ax, ay, ax+30*fx, ay+10*fy)
        dc.DrawLine(ax, ay, ax+10*fx, ay+30*fy)
        del dc
    def OnButtonOK( self, event ):
        if self.numeric:
            try:
                self.result = float(self.m_txtValue.Value)
                self.EndModal(wx.ID_OK)
            except ValueError:
                wx.MessageBox("Ongeldig getal")
        elif self.yesno:
            self.result = True
            self.EndModal(wx.ID_OK)
        else:
            self.result = self.m_txtValue.Value
            self.EndModal(wx.ID_OK)
    def OnButtonNo( self, event ):
        self.result = False
        self.EndModal(wx.ID_NO)
    def OnButtonCancel( self, event ):
        self.EndModal(wx.ID_CANCEL)
class FormAskChoice( FormAskChoice_Base):
    def __init__( self, message, choices ):
        super().__init__(None)
        self.m_txtMessage.Label = message
        self.m_txtMessage.Wrap(self.m_txtMessage.Size.Width)
        self.SetSize( 320, 175 + len(choices*75))
        self.buttons = list()
        bSizer22 = wx.BoxSizer( wx.VERTICAL )
        for x in choices:
            btn = wx.Button( self.m_pnlChoices, wx.ID_ANY, x, wx.DefaultPosition, wx.DefaultSize, 0|wx.BORDER_NONE )
            btn.SetFont( wx.Font( 12, wx.FONTFAMILY_SWISS, wx.FONTSTYLE_NORMAL, wx.FONTWEIGHT_NORMAL, False, "Arial" ) )
            btn.SetBackgroundColour( wx.Colour( 255, 255, 255 ) )
            btn.Bind( wx.EVT_BUTTON, self.OnTestClick )
            bSizer22.Add( btn, 1, wx.ALL|wx.EXPAND, 5 )
            self.buttons.append(btn)
        self.m_pnlChoices.SetSizer( bSizer22 )
        self.m_pnlChoices.Layout()
        bSizer22.Fit( self.m_pnlChoices )
        self.result = -1
    def OnTestClick( self, event ):
        btn = event.GetEventObject()
        pos = self.buttons.index(btn)
        for i in range(len(self.buttons)):
            if self.buttons[i] == btn:
                self.buttons[i].SetBackgroundColour( wx.SystemSettings.GetColour( wx.SYS_COLOUR_HIGHLIGHT ) )
                self.buttons[i].SetForegroundColour( wx.SystemSettings.GetColour( wx.SYS_COLOUR_HIGHLIGHTTEXT ) )
                self.result = i
            else:
                self.buttons[i].SetBackgroundColour( wx.Colour( 255, 255, 255 ) )
                self.buttons[i].SetForegroundColour( wx.SystemSettings.GetColour( wx.SYS_COLOUR_BTNTEXT) )
        self.m_btnOK.Enable()
    def OnButtonOK( self, event ):
        self.EndModal(wx.ID_OK)
    def OnButtonCancel( self, event ):
        self.result = -1
        self.EndModal(wx.ID_CANCEL)
class ScriptGui:
    def __init__(self, mngr):
        self._mngr = mngr
        self.__func = None
        self.__params = None
        self.__reply = None
        self.__have_reply = threading.Semaphore(0)
        self.m_stop_dialog = None
    def on_gui_timer(self):
        if self.__func is not None:
            func = self.__func
            self.__func = None
            try:
                self.__reply = func(*self.__params)
            except Exception as e:
                self.__reply = e
            self.__have_reply.release()
    def __run_with_timer(self, func, *params):
        self.__params = params
        self.__func = func
        self.__have_reply.acquire()
        if isinstance(self.__reply, Exception):
            raise self.__reply
        return self.__reply
    def do_func(self, func, *params):
        if func is None or not callable(func):
            raise Exception("Given function to execute is not something callable.")
        if threading.currentThread().getName()=="ScriptThread":
            return self.__run_with_timer(func, *params )
        else:
            return func(*params)
    def ask(self, message, default_value="" ):
        if threading.currentThread().getName()=="ScriptThread":
            return self.__run_with_timer(self.ask, message, default_value )
        result = None
        dlg = wx.TextEntryDialog( None, message, 'HappyScript', default_value )
        if dlg.ShowModal() == wx.ID_OK:
            result = dlg.GetValue()
        dlg.Destroy()
        if result is None:
            raise ScriptUserAbortException( "User did not provide value in dialog" )
        return result
    def ask_number(self, message, default_value=None ):
        if threading.currentThread().getName()=="ScriptThread":
            return self.__run_with_timer(self.ask_number, message, default_value )
        result = None
        if default_value is None:
            default_value = ""
        else:
            default_value = "%d" % default_value
        dlg = wx.TextEntryDialog( None, message, 'HappyScript', default_value )
        while result is None:
            if dlg.ShowModal() == wx.ID_OK:
                txt_result = dlg.GetValue().encode("latin1")
            else:
                break
            try:
                result = int(txt_result)
            except:
                result = None
        dlg.Destroy()
        if result is None:
            raise ScriptUserAbortException( "User did not provide value in dialog" )
        return result
    def ask_yesno(self, message, cancel = False):
        if threading.currentThread().getName()=="ScriptThread":
            return self.__run_with_timer(self.ask_yesno, message, cancel )
        style = wx.YES_NO|wx.CANCEL if cancel else wx.YES_NO
        dlg = wx.MessageDialog(None, message, 'HappyScript', style=style)
        result = dlg.ShowModal()
        dlg.Destroy()
        if result == wx.ID_YES:
            return True
        elif result == wx.ID_NO:
            return False
        raise ScriptUserAbortException( "User did not answer yes/no dialog" )
    def ask_image(self, message, filename, arrow_pos=None, yesno=False, cancel=False, numeric=False):
        if threading.currentThread().getName()=="ScriptThread":
            return self.__run_with_timer(self.ask_image, message, filename, arrow_pos, yesno, cancel, numeric )
        form = FormAskImage(message, filename, arrow_pos, yesno, cancel, numeric )
        if form.ShowModal() == wx.ID_CANCEL:
            form.Destroy()
            raise ScriptUserAbortException( "User pressed cancel in dialog" )
        result = form.result
        form.Destroy()
        return result
    def ask_choice(self, message, choices, do_assert = True):
        if threading.currentThread().getName()=="ScriptThread":
            return self.__run_with_timer(self.ask_choice, message, choices )
        form = FormAskChoice(message, choices )
        if form.ShowModal() == wx.ID_CANCEL:
            if do_assert:
                form.Destroy()
                raise ScriptUserAbortException( "User pressed cancel in dialog" )
        result = form.result
        form.Destroy()
        return result
    def ask_open_file(self, message, wildcard):
        if threading.currentThread().getName() == "ScriptThread":
            return self.__run_with_timer(self.ask_open_file, message, wildcard)
        style = wx.FD_OPEN | wx.FD_FILE_MUST_EXIST
        dlg = wx.FileDialog(
            None, message, wildcard=wildcard, style=style)
        if dlg.ShowModal() == wx.ID_CANCEL:
            return None
        return dlg.GetPath()
    def show_stop_dialog(self, message=None ):
        if threading.currentThread().getName() == "ScriptThread":
            return self.__run_with_timer(self.show_stop_dialog, message)
        if message is None:
            message = "Press the 'Stop' button to stop the test."
        if self.m_stop_dialog is None:
            self.m_stop_dialog = FormStop(message, self._mngr)
        else:
            self.m_stop_dialog.update_message(message)
        self.m_stop_dialog.Show()
    def close_stop_dialog(self):
        if self.m_stop_dialog is None:
            return
        if threading.currentThread().getName() == "ScriptThread":
            return self.__run_with_timer(self.close_stop_dialog)
        self.m_stop_dialog.Destroy()
        self.m_stop_dialog = None
    def add_scatter_chart(self, name):
        if threading.currentThread().getName() == "ScriptThread":
            return self.__run_with_timer(self.add_scatter_chart, name)
        return self._mngr.charts.add_scatter_chart(name)
    def add_time_chart(self, name):
        if threading.currentThread().getName() == "ScriptThread":
            return self.__run_with_timer(self.add_time_chart, name)
        return self._mngr.charts.add_time_chart(name)
    def add_histogram(self, name, binsize):
        if threading.currentThread().getName() == "ScriptThread":
            return self.__run_with_timer(self.add_histogram, name, binsize)
        return self._mngr.charts.add_histogram(name, binsize)
    def get_chart(self, name):
        return self._mngr.charts.get_chart(name)
    def delete_chart(self, name):
        if threading.currentThread().getName() == "ScriptThread":
            return self.__run_with_timer(self.delete_chart, name)
        self._mngr.charts.delete_chart(name)
class ScriptInfo(object):
    logger = logging.getLogger('happyscript')
    def __init__(self, testlist):
        self.clear()
        self.__dict__["xx_testlist"] = testlist
    def clear(self):
        self.__dict__["xx_info"] = dict()
        self.__dict__["xx_serials"] = list()
        self.__dict__["xx_filename"] = None
        self.__dict__["xx_dirty"] = False
        self.__dict__["xx_lastupdate"] = time.time()
    def set_serials(self, serials):
        self.xx_serials.clear()
        if serials is not None:
            for sn in serials:
                self.add_serial(sn)
    def add_serial(self, *serials):
        for serial in serials:
            if isinstance(serial, str):
                self.xx_serials.append(serial.strip() )
            else:
                self.logger.error("Given serial is invalid : '%s'" % str(serial) )
                self.xx_serials.append("")
            self.xx_dirty = True
            self.update_file()
    def set_filename(self, fname):
        self.xx_filename = fname
        self.xx_dirty = True
    def write_file(self, fname = None):
        if fname is None:
            fname = self.xx_filename
        if fname is None:
            return
        fname = os.path.splitext(fname)[0] + ".yml"
        file = open(fname, "w")
        if len(self.serials)>0:
            serials_dict = { 'serials': self.serials }
            yaml.dump(serials_dict, file)
        if len(self.xx_info)>0:
            yaml.dump(self.xx_info, file)
        file.close()
    def update_file(self, force=False):
        if len(self.xx_info)==0 and len(self.serials)==0:
            return
        t = time.time()
        if force or (self.xx_dirty and (t - self.xx_lastupdate > 2)):
            self.xx_dirty = False
            self.xx_lastupdate = t
            self.write_file()
    @property
    def serials(self):
        return self.xx_serials.copy()
    def __getattr__(self, attr):
        if attr in self.xx_info:
            return self.xx_info[attr]
        else:
            return None
    def __setattr__(self, attr, value):
        if attr in self.__dict__:
            super().__setattr__(attr, value)
        else:
            self.add(attr, value)
    def get_passed_tests(self, include = None, exclude = None):
        if self.xx_testlist is None:
            return list()
        return self.xx_testlist.get_tests(True, include, exclude)
    def get_failed_tests(self, include = None, exclude = None):
        if self.xx_testlist is None:
            return list() if include is None else include
        return self.xx_testlist.get_tests(False, include, exclude)
    def add(self, objName, theObject):
        if not isinstance(objName, str) or not objName.isidentifier():
            self.logger.error("Given name for information is not a valid identifier : '%s'" % str(objName) )
            return
        self.xx_dirty = True
        objName = objName.lower().strip()
        self.xx_info[objName] = theObject
        self.update_file()
class TestLogHandler(logging.FileHandler):
    def __init__(self, filename):
        super().__init__(filename)
    def emit(self, record):
        if record.msg is None:
            return
        record.msg = record.msg.strip()
        if len(record.msg.rstrip())==0:
            return
        if record.exc_info and str(record.exc_info[1])!="'Stopping parent script...'":
            tb = traceback.format_exception(record.exc_info[0], record.exc_info[1], record.exc_info[2])
            for line in tb[:-1 or None]:
                if line.startswith("Traceback "):
                    continue
                if "in execute_threadfunc" in line:
                    continue
                record.msg = record.msg + "\r\n" + line
            record.exc_info = None
        super().emit(record)
class ScriptManager(object):
    dialog = None
    logger = logging.getLogger("happyscript")
    def __init__(self, title=None, colors = None):
        fixedcolors = [ (226, 239, 217), (222, 235, 246), (255, 242, 204), (237, 237, 237),
                        (251, 229, 213), (217, 226, 243) ]
        self.on_batch_start = None
        self.on_batch_end = None
        self.logfiles_defined = False
        logging.getLogger('').setLevel(logging.INFO)
        logging.addLevelName(logging.WARN+1, "PASS")
        self.loghandler = GlobalLogHandler()
        logging.getLogger('').addHandler(self.loghandler)
        paramiko_log = logging.getLogger("paramiko")
        paramiko_log.propagate = False
        self.textlogoutput = LogToText()
        self.loghandler.add_callback(self.textlogoutput.handle_log)
        self.app = wx.App()
        self.locale = wx.Locale(wx.LANGUAGE_ENGLISH)
        self.dialog = FormMain(self)
        self.charts = self.dialog.chartsPane
        self.loghandler.add_callback(self.dialog.logPane.HandleLog)
        self.loghandler.add_callback(self.dialog.msgArea.HandleLogData)
        self.dialog.on_log_timer = self.on_log_timer
        self.ctrl = ScriptControl()
        self.gui = ScriptGui(self)
        self.dialog.on_gui_timer = self.gui.on_gui_timer
        self.info = ScriptInfo( self.dialog.pnlTests )
        self._script_params = ScriptParams(self.gui)
        self._script_params.on_add_object = self._on_add_object
        self._script_readers = dict()
        self._script_runner = ScriptRunner(self._script_params, self._script_readers, self.ctrl)
        self.ctrl.on_run_script = self._script_runner.run_script
        self._script_params.add_objects( ctrl=self.ctrl, gui=self.gui, info=self.info )
        self.dialog.pnlTests.on_sequence_start_callback = self.handle_batch_start
        self.dialog.pnlTests.on_sequence_end_callback = self.handle_batch_end
        self.set_logfiles()
        if title is not None:
            self.dialog.Title = title
            self.dialog.pnlTests.Label = title
        if colors is not None and colors in range(len(fixedcolors)):
            rgb = fixedcolors[colors]
            color = wx.Colour(rgb[0], rgb[1], rgb[2])
            self.dialog.pnlTests.SetBackgroundColour(color)
            self.dialog.msgArea.SetBackgroundColour(color)
        self.dialog.Show()
    def on_log_timer(self):
        self.loghandler.run_callbacks()
    def set_logfiles(self, fname = None, fdir = None, use_temp = False):
        if fdir is None:
            fdir = "./log"
        if fname is None:
            fname = "happyscript"
        fname,_ = os.path.splitext(fname)
        if not os.path.exists(fdir):
            os.makedirs(fdir)
        self.info.set_filename( os.path.join(fdir, fname+".yml") )
        self.textlogoutput.set_filename( os.path.join(fdir, fname+".log"), use_temp = use_temp )
        self.logger.info("Writing log to %s" % os.path.join(fdir, fname+".log"))
        self.logfiles_defined = True
    def close_logfiles(self):
        self.set_logfiles()
        self.logfiles_defined = False
    def stop_scripts(self):
        self.ctrl.stop()
    def add_object(self, objName, theObject):
        self._script_params.add_object( objName, theObject)
    def add_objects(self, *args, **kwargs):
        self._script_params.add_objects(*args, **kwargs)
    def _on_add_object(self, obj_name, obj_value):
        if obj_value is None:
            self.logger.warning( f"Object with name {obj_name} is None." )
        else:
            self.logger.info("Added object %s" %obj_name)
            self.dialog.PushShellCommand("%s = _mngr_._script_params.get_param('%s')" % (obj_name, obj_name))
    def add_scripts(self, script_dir, group_name = None):
        full_path = os.path.normpath(os.path.abspath(script_dir))
        self.logger.info( "Adding scripts in %s" % full_path )
        if group_name is None:
            group_name = os.path.basename(full_path)
        reader = ScriptReader(script_dir, group_name)
        self._script_readers[group_name] = reader
        reader.reload()
        newPanel = PanelScripts2(self.dialog._nbk_scripts, reader, self.ctrl )
        self.dialog._nbk_scripts.AddPage( newPanel, group_name, False)
    def add_test(self, description, scriptname, **args):
        self.dialog.pnlTests.add_test( description, scriptname, **args )
    def add_tests(self, testlist):
        for x in testlist:
            if len(x)==3:
                self.add_test( x[0], x[1], **x[2] )
            elif len(x)==2:
                self.add_test( x[0], x[1] )
            else:
                self.logger.critical("Expected at least description and test name in test list.")
    @property
    def on_cmd_line(self):
        return self.dialog.logPane.callback
    @on_cmd_line.setter
    def on_cmd_line(self, value):
        self.dialog.logPane.callback = value
    def handle_batch_start(self):
        result = True
        self.info.clear()
        if self.logfiles_defined:
            self.close_logfiles()
        if not self.on_batch_start is None and callable(self.on_batch_start):
            result = self.on_batch_start()
        if not self.logfiles_defined:
            fname = "test_" + time.strftime("%y%m%d-%H%M%S")
            self.set_logfiles(fname, use_temp=True)
        return result
    def handle_batch_end(self):
        if not self.on_batch_end is None and callable(self.on_batch_end):
            self.on_batch_end()
        self.info.update_file(True)
        self.close_logfiles()
    def ask_serials(self, count, labels = None, filters=None, add_to_info=True):
        serials = FormSerials.show(count, labels, filters)
        if add_to_info:
            self.info.set_serials(serials)
        return serials
    def add_custom_panel(self, title, panelType, **args):
        self.dialog.AddCustomPanel(title, panelType, **args)
    def run(self):
        self.dialog.BeforeShow()
        PrintRedirect.start_redirection(self.loghandler)
        print("Happyscript started")
        self.app.MainLoop()
        PrintRedirect.stop_redirection()
        self.info.update_file(True)
        self.textlogoutput.close()
