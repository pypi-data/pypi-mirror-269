# This file was auto-generated by Fern from our API Definition.

import typing
import urllib.parse
from json.decoder import JSONDecodeError

from ...core.api_error import ApiError
from ...core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ...core.jsonable_encoder import jsonable_encoder
from ...core.remove_none_from_dict import remove_none_from_dict
from ...core.request_options import RequestOptions
from ...errors.bad_request_error import BadRequestError
from ...errors.forbidden_error import ForbiddenError
from ...errors.internal_server_error import InternalServerError
from ...errors.not_found_error import NotFoundError
from ...errors.unauthorized_error import UnauthorizedError
from ...types.annotations import Annotations
from ...types.bad_request_error_body import BadRequestErrorBody
from ...types.key_filter import KeyFilter
from ...types.key_generate import KeyGenerate
from ...types.key_import_private import KeyImportPrivate
from ...types.key_list import KeyList
from ...types.key_resource import KeyResource
from ...types.key_sort import KeySort
from ...types.labels import Labels
from ...types.problem_forbidden import ProblemForbidden
from ...types.problem_internal_server_error import ProblemInternalServerError
from ...types.problem_unauthorized import ProblemUnauthorized
from ...types.resource_id import ResourceId
from ...types.revision import Revision

try:
    import pydantic.v1 as pydantic  # type: ignore
except ImportError:
    import pydantic  # type: ignore

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class KeysClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def key_generate(
        self,
        *,
        data: KeyGenerate,
        annotations: typing.Optional[Annotations] = OMIT,
        labels: typing.Optional[Labels] = OMIT,
        idempotency_key: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> KeyResource:
        """
        Generate key's resource.

        You could use KeyGenerate, if you want to rely to generated by Truvity key-pairs for CredentialIssue and PresentationIssue.
        Remember, that you do not have any option to get private key by Truvity API, you could only use it

        | Truvity   | JWX - KeyType | JWX - Curve | FIPS  | SEC2      | OpenSSL    | AWS KMS         |
        | --------- | ------------- | ----------- | ----- | --------- | ---------- | --------------- |
        | ED25519   | OKP           | Ed25519     |       |           | ed25519    |                 |
        | P256      | EC            | P-256       | P-256 | secp256r1 | prime256v1 | ECC_NIST_P256   |
        | P384      | EC            | P-384       | P-384 | secp384r1 | secp384r1  | ECC_NIST_P384   |
        | SECP256K1 | EC            | secp256k1   |       | secp256k1 | secp256k1  | ECC_SECG_P256K1 |

        Useful third-party documentation:

        - [openssl-genrsa - generate an RSA private key](https://www.openssl.org/docs/manmaster/man1/openssl-genpkey.html).
        - [openssl-ec, ec - EC key processing](https://www.openssl.org/docs/man1.0.2/man1/ec.html)
        - [openssl-genrsa - generate an RSA private key](https://www.openssl.org/docs/man3.0/man1/openssl-genrsa.html)
        - [openssl-pkcs8 - PKCS#8 format private key conversion command](https://www.openssl.org/docs/manmaster/man1/openssl-pkcs8.html)
        - [JWX - github.com/lestrrat-go/jwx](https://github.com/lestrrat-go/jwx/blob/main/cmd/jwx/README.md)
        - [FIPS 186-4](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.186-4.pdf).
        - [SEC2](https://www.secg.org/sec2-v2.pdf).
        - [AWS KMS - Asymmetric key specs](https://docs.aws.amazon.com/kms/latest/developerguide/asymmetric-key-specs.html)
          .

        Parameters:
            - data: KeyGenerate.

            - annotations: typing.Optional[Annotations].

            - labels: typing.Optional[Labels].

            - idempotency_key: typing.Optional[str]. From [Zalando RESTful API Guidelines - models/headers-1.0.0.yaml](https://opensource.zalando.com/restful-api-guidelines/models/headers-1.0.0.yaml).
                                                     The **Idempotency-Key** is a free identifier created by the client to
                                                     identify a request. It is used by the service to identify repeated request
                                                     to ensure idempotent behavior by sending the same (or a similar) response
                                                     without executing the request a second time.

                                                     Clients should be careful as any subsequent requests with the same key may
                                                     return the same response without further check. Thus, it is recommended to
                                                     use a UUID version 4 (random) or any other random string with enough
                                                     entropy to avoid collisions.

                                                     Keys expire after 24 hours. Clients are responsible to stay within this
                                                     limit, if they require idempotent behavior.

                                                     See [API Guideline Rule #181][api-230] for further details.

                                                     [api-230]: <https://opensource.zalando.com/restful-api-guidelines/#230>.
            - request_options: typing.Optional[RequestOptions]. Request-specific configuration.
        ---
        from truvity_sdk import KeyGenerate
        from truvity_sdk.client import TruvityApi

        client = TruvityApi(
            api_key="YOUR_API_KEY",
        )
        client.keys.key_generate(
            data=KeyGenerate(),
        )
        """
        _request: typing.Dict[str, typing.Any] = {"data": data}
        if annotations is not OMIT:
            _request["annotations"] = annotations
        if labels is not OMIT:
            _request["labels"] = labels
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "keys/generate"),
            params=jsonable_encoder(
                request_options.get("additional_query_parameters") if request_options is not None else None
            ),
            json=jsonable_encoder(_request)
            if request_options is None or request_options.get("additional_body_parameters") is None
            else {
                **jsonable_encoder(_request),
                **(jsonable_encoder(remove_none_from_dict(request_options.get("additional_body_parameters", {})))),
            },
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        "Idempotency-Key": idempotency_key,
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else 60,
            retries=0,
            max_retries=request_options.get("max_retries") if request_options is not None else 0,  # type: ignore
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(KeyResource, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(BadRequestErrorBody, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(ProblemUnauthorized, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(ProblemForbidden, _response.json()))  # type: ignore
        if _response.status_code == 500:
            raise InternalServerError(
                pydantic.parse_obj_as(ProblemInternalServerError, _response.json())  # type: ignore
            )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def key_import(
        self,
        *,
        data: KeyImportPrivate,
        annotations: typing.Optional[Annotations] = OMIT,
        labels: typing.Optional[Labels] = OMIT,
        idempotency_key: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> KeyResource:
        """
        Import key's resource.

        You could use KeyGenerate, if you want to rely to generated by Truvity key-pairs for CredentialIssue and PresentationIssue.
        Remember, that you do not have any option to get private key by Truvity API, you could only use it

        If you prefer to keep private key, then you need to generate it manually.
        To use manually generated key CredentialIssue and PresentationIssue you need to import it.

        To generate key-pair you have two options

        1. OpenSSL - [OpenSSL commands](https://www.openssl.org/docs/man1.1.1/man1/index.html)
        2. JWX tool - [https://github.com/lestrrat-go/jwx/blob/main/cmd/jwx/README.md](https://github.com/lestrrat-go/jwx/blob/main/cmd/jwx/README.md)

        How to install JWX

        1. Download & Install Golang - [https://go.dev/doc/install](https://go.dev/doc/install)
        2. Clone & Build & Install [github.com/lestrrat-go/jwx](https://github.com/lestrrat-go/jwx)
           ```bash
           git clone https://github.com/lestrrat-go/jwx
           cd jwx/cmd/jwx
           go install -tags=jwx_es256k,jwx_secp256k1_pem .
           ```
        3. Verify that you correctly install everything

           ```bash
           âžœ jwx --help
           NAME:
                jwx - Tools for various JWE/JWK/JWS/JWT operations

            USAGE:
                jwx [global options] command [command options] [arguments...]

            COMMANDS:
                jwa      List available algorithms and types
                jwe      Work with JWE messages
                jwk      Work with JWK and JWK sets
                jws      Work with JWS messages
                help, h  Shows a list of commands or help for one command

            GLOBAL OPTIONS:
                --help, -h  show help
           ```

        How generate private key by `jwx` (output format JWK)

        ```bash
        # ED25519
        jwx jwx generate --type OKP --curve Ed25519
        # P256
        jwx jwx generate --type EC --curve P-256
        # P384
        jwx jwx generate --type EC --curve P-384
        # SECP256K1
        jwx jwx generate --type EC --curve secp256k1
        ```

        How to generate public key from private key by `jwx` (input format - JWK, output format - JWK)

        ```bash
        jwx jwk format -I json -O json - <(pathfile with private key in JWK format)
        ```

        How to generate private key by OpenSSL (output format PEM - PKCS#8)

        ```bash
        # ED25519
        openssl genpkey -algorithm ed25519 | openssl pkcs8 -nocrypt -topk8
        # P256
        openssl ecparam -name prime256v1 -noout -genkey | openssl pkcs8 -nocrypt -topk8
        # P384
        openssl ecparam -name secp384r1 -noout -genkey | openssl pkcs8 -nocrypt -topk8
        # SECP256K1
        openssl ecparam -name secp256k1 -noout -genkey | openssl pkcs8 -nocrypt -topk8
        ```

        How to transform existing private key to PKCS8 format by OpenSSL (input format PEM, output format - PEM PCKS#8)

        ```bash
        openssl pkcs8 -nocrypt -topk8 <(pathfile with private key in PEM format)
        ```

        How to transform private key to public key by OpenSSL (input format PEM, output format - PEM PKIX)

        ```bash
        openssl pkey -pubout <(pathfile with private key in PKCS8 format)
        ```

        Useful third-party documentation:

        - [openssl-genrsa - generate an RSA private key](https://www.openssl.org/docs/manmaster/man1/openssl-genpkey.html).
        - [openssl-ec, ec - EC key processing](https://www.openssl.org/docs/man1.0.2/man1/ec.html)
        - [openssl-genrsa - generate an RSA private key](https://www.openssl.org/docs/man3.0/man1/openssl-genrsa.html)
        - [openssl-pkcs8 - PKCS#8 format private key conversion command](https://www.openssl.org/docs/manmaster/man1/openssl-pkcs8.html)
        - [JWX - github.com/lestrrat-go/jwx](https://github.com/lestrrat-go/jwx/blob/main/cmd/jwx/README.md)
        - [FIPS 186-4](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.186-4.pdf).
        - [SEC2](https://www.secg.org/sec2-v2.pdf).
        - [AWS KMS - Asymmetric key specs](https://docs.aws.amazon.com/kms/latest/developerguide/asymmetric-key-specs.html)
          .

        Parameters:
            - data: KeyImportPrivate.

            - annotations: typing.Optional[Annotations].

            - labels: typing.Optional[Labels].

            - idempotency_key: typing.Optional[str]. From [Zalando RESTful API Guidelines - models/headers-1.0.0.yaml](https://opensource.zalando.com/restful-api-guidelines/models/headers-1.0.0.yaml).
                                                     The **Idempotency-Key** is a free identifier created by the client to
                                                     identify a request. It is used by the service to identify repeated request
                                                     to ensure idempotent behavior by sending the same (or a similar) response
                                                     without executing the request a second time.

                                                     Clients should be careful as any subsequent requests with the same key may
                                                     return the same response without further check. Thus, it is recommended to
                                                     use a UUID version 4 (random) or any other random string with enough
                                                     entropy to avoid collisions.

                                                     Keys expire after 24 hours. Clients are responsible to stay within this
                                                     limit, if they require idempotent behavior.

                                                     See [API Guideline Rule #181][api-230] for further details.

                                                     [api-230]: <https://opensource.zalando.com/restful-api-guidelines/#230>.
            - request_options: typing.Optional[RequestOptions]. Request-specific configuration.
        ---
        from truvity_sdk.client import TruvityApi

        client = TruvityApi(
            api_key="YOUR_API_KEY",
        )
        client.keys.key_import(
            data="data",
        )
        """
        _request: typing.Dict[str, typing.Any] = {"data": data}
        if annotations is not OMIT:
            _request["annotations"] = annotations
        if labels is not OMIT:
            _request["labels"] = labels
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "keys/import"),
            params=jsonable_encoder(
                request_options.get("additional_query_parameters") if request_options is not None else None
            ),
            json=jsonable_encoder(_request)
            if request_options is None or request_options.get("additional_body_parameters") is None
            else {
                **jsonable_encoder(_request),
                **(jsonable_encoder(remove_none_from_dict(request_options.get("additional_body_parameters", {})))),
            },
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        "Idempotency-Key": idempotency_key,
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else 60,
            retries=0,
            max_retries=request_options.get("max_retries") if request_options is not None else 0,  # type: ignore
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(KeyResource, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(BadRequestErrorBody, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(ProblemUnauthorized, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(ProblemForbidden, _response.json()))  # type: ignore
        if _response.status_code == 500:
            raise InternalServerError(
                pydantic.parse_obj_as(ProblemInternalServerError, _response.json())  # type: ignore
            )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def key_search(
        self,
        *,
        filter: typing.Optional[typing.Sequence[KeyFilter]] = OMIT,
        sort: typing.Optional[typing.Sequence[KeySort]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> KeyList:
        """
        Take a look at [GET with body payload](https://opensource.zalando.com/restful-api-guidelines/#get-with-body)

        - no resources created: Returns all keys matching the query passed as request input payload.

        Parameters:
            - filter: typing.Optional[typing.Sequence[KeyFilter]]. Filter for the keys' resources.

            - sort: typing.Optional[typing.Sequence[KeySort]]. Sort of the keys' resources.

            - request_options: typing.Optional[RequestOptions]. Request-specific configuration.
        ---
        from truvity_sdk.client import TruvityApi

        client = TruvityApi(
            api_key="YOUR_API_KEY",
        )
        client.keys.key_search()
        """
        _request: typing.Dict[str, typing.Any] = {}
        if filter is not OMIT:
            _request["filter"] = filter
        if sort is not OMIT:
            _request["sort"] = sort
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "keys/search"),
            params=jsonable_encoder(
                request_options.get("additional_query_parameters") if request_options is not None else None
            ),
            json=jsonable_encoder(_request)
            if request_options is None or request_options.get("additional_body_parameters") is None
            else {
                **jsonable_encoder(_request),
                **(jsonable_encoder(remove_none_from_dict(request_options.get("additional_body_parameters", {})))),
            },
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else 60,
            retries=0,
            max_retries=request_options.get("max_retries") if request_options is not None else 0,  # type: ignore
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(KeyList, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(BadRequestErrorBody, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(ProblemUnauthorized, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(ProblemForbidden, _response.json()))  # type: ignore
        if _response.status_code == 500:
            raise InternalServerError(
                pydantic.parse_obj_as(ProblemInternalServerError, _response.json())  # type: ignore
            )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def key_latest(
        self,
        id: ResourceId,
        *,
        if_none_match: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> KeyResource:
        """
        Read the latest revision of the key's resource.

        Parameters:
            - id: ResourceId. Take a look to documentation about #/components/schemas/ResourceID.

            - if_none_match: typing.Optional[str]. From [Zalando RESTful API Guidelines - models/headers-1.0.0.yaml](https://opensource.zalando.com/restful-api-guidelines/models/headers-1.0.0.yaml).
                                                   The **If-None-Match header** field is used to declare a list of identifiers
                                                   that are required to fail matching all the current resource version
                                                   identifiers as a pre-condition for executing the request on the server
                                                   side. This is especially used in conjunction with an **\*** (asterix) that
                                                   is matching all possible resource identifiers to ensure the initial
                                                   creation of a resource. Other use cases are possible but rare.

                                                   If the pre-condition fails the server will respond with status code **412**
                                                   (Precondition Failed). See [RFC 9110 Section 13.1.2][rfc-9110-13.1.2] as
                                                   well as [API Guideline Rule #182][api-182] for further details.

                                                   [rfc-9110-13.1.2]: https://tools.ietf.org/html/rfc9110#section-13.1.2

                                                   [api-182]: <https://opensource.zalando.com/restful-api-guidelines/#182>.
            - request_options: typing.Optional[RequestOptions]. Request-specific configuration.
        ---
        from truvity_sdk.client import TruvityApi

        client = TruvityApi(
            api_key="YOUR_API_KEY",
        )
        client.keys.key_latest(
            id="id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"keys/{jsonable_encoder(id)}"),
            params=jsonable_encoder(
                request_options.get("additional_query_parameters") if request_options is not None else None
            ),
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        "If-None-Match": if_none_match,
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else 60,
            retries=0,
            max_retries=request_options.get("max_retries") if request_options is not None else 0,  # type: ignore
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(KeyResource, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(BadRequestErrorBody, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(ProblemUnauthorized, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(ProblemForbidden, _response.json()))  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 500:
            raise InternalServerError(
                pydantic.parse_obj_as(ProblemInternalServerError, _response.json())  # type: ignore
            )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def key_update(
        self,
        id: ResourceId,
        *,
        annotations: typing.Optional[Annotations] = OMIT,
        labels: typing.Optional[Labels] = OMIT,
        idempotency_key: typing.Optional[str] = None,
        if_match: str,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> KeyResource:
        """
        Update key's resource.

        Parameters:
            - id: ResourceId. Take a look to documentation about #/components/schemas/ResourceID.

            - annotations: typing.Optional[Annotations].

            - labels: typing.Optional[Labels].

            - idempotency_key: typing.Optional[str]. From [Zalando RESTful API Guidelines - models/headers-1.0.0.yaml](https://opensource.zalando.com/restful-api-guidelines/models/headers-1.0.0.yaml).
                                                     The **Idempotency-Key** is a free identifier created by the client to
                                                     identify a request. It is used by the service to identify repeated request
                                                     to ensure idempotent behavior by sending the same (or a similar) response
                                                     without executing the request a second time.

                                                     Clients should be careful as any subsequent requests with the same key may
                                                     return the same response without further check. Thus, it is recommended to
                                                     use a UUID version 4 (random) or any other random string with enough
                                                     entropy to avoid collisions.

                                                     Keys expire after 24 hours. Clients are responsible to stay within this
                                                     limit, if they require idempotent behavior.

                                                     See [API Guideline Rule #181][api-230] for further details.

                                                     [api-230]: <https://opensource.zalando.com/restful-api-guidelines/#230>.
            - if_match: str. From [Zalando RESTful API Guidelines - models/headers-1.0.0.yaml](https://opensource.zalando.com/restful-api-guidelines/models/headers-1.0.0.yaml).
                             The **If-Match** header field is used to declare a list of identifiers that
                             are required to match the current resource version identifier in at least
                             one position as a pre-condition for executing the request on the server
                             side. This behavior is used to validate and reject optimistic updates, by
                             checking if the resource version a consumer has based his changes on is
                             outdated on arrival of the change request to prevent lost updates.

                             If the pre-condition fails the server will respond with status code **412**
                             (Precondition Failed). See [RFC 9110 Section 13.1.1][rfc-9110-13.1.1] as
                             well as [API Guideline Rule #182][api-182] for further details.

                             [rfc-9110-13.1.1]: https://tools.ietf.org/html/rfc9110#section-13.1.1

                             [api-182]: <https://opensource.zalando.com/restful-api-guidelines/#182>.
            - request_options: typing.Optional[RequestOptions]. Request-specific configuration.
        ---
        from truvity_sdk.client import TruvityApi

        client = TruvityApi(
            api_key="YOUR_API_KEY",
        )
        client.keys.key_update(
            id="id",
            if_match="If-Match",
        )
        """
        _request: typing.Dict[str, typing.Any] = {}
        if annotations is not OMIT:
            _request["annotations"] = annotations
        if labels is not OMIT:
            _request["labels"] = labels
        _response = self._client_wrapper.httpx_client.request(
            "PUT",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"keys/{jsonable_encoder(id)}"),
            params=jsonable_encoder(
                request_options.get("additional_query_parameters") if request_options is not None else None
            ),
            json=jsonable_encoder(_request)
            if request_options is None or request_options.get("additional_body_parameters") is None
            else {
                **jsonable_encoder(_request),
                **(jsonable_encoder(remove_none_from_dict(request_options.get("additional_body_parameters", {})))),
            },
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        "Idempotency-Key": idempotency_key,
                        "If-Match": if_match,
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else 60,
            retries=0,
            max_retries=request_options.get("max_retries") if request_options is not None else 0,  # type: ignore
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(KeyResource, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(BadRequestErrorBody, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(ProblemUnauthorized, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(ProblemForbidden, _response.json()))  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 500:
            raise InternalServerError(
                pydantic.parse_obj_as(ProblemInternalServerError, _response.json())  # type: ignore
            )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def key_delete(
        self,
        id: ResourceId,
        *,
        idempotency_key: typing.Optional[str] = None,
        if_match: str,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Delete key's resource.

        Parameters:
            - id: ResourceId. Take a look to documentation about #/components/schemas/ResourceID.

            - idempotency_key: typing.Optional[str]. From [Zalando RESTful API Guidelines - models/headers-1.0.0.yaml](https://opensource.zalando.com/restful-api-guidelines/models/headers-1.0.0.yaml).
                                                     The **Idempotency-Key** is a free identifier created by the client to
                                                     identify a request. It is used by the service to identify repeated request
                                                     to ensure idempotent behavior by sending the same (or a similar) response
                                                     without executing the request a second time.

                                                     Clients should be careful as any subsequent requests with the same key may
                                                     return the same response without further check. Thus, it is recommended to
                                                     use a UUID version 4 (random) or any other random string with enough
                                                     entropy to avoid collisions.

                                                     Keys expire after 24 hours. Clients are responsible to stay within this
                                                     limit, if they require idempotent behavior.

                                                     See [API Guideline Rule #181][api-230] for further details.

                                                     [api-230]: <https://opensource.zalando.com/restful-api-guidelines/#230>.
            - if_match: str. From [Zalando RESTful API Guidelines - models/headers-1.0.0.yaml](https://opensource.zalando.com/restful-api-guidelines/models/headers-1.0.0.yaml).
                             The **If-Match** header field is used to declare a list of identifiers that
                             are required to match the current resource version identifier in at least
                             one position as a pre-condition for executing the request on the server
                             side. This behavior is used to validate and reject optimistic updates, by
                             checking if the resource version a consumer has based his changes on is
                             outdated on arrival of the change request to prevent lost updates.

                             If the pre-condition fails the server will respond with status code **412**
                             (Precondition Failed). See [RFC 9110 Section 13.1.1][rfc-9110-13.1.1] as
                             well as [API Guideline Rule #182][api-182] for further details.

                             [rfc-9110-13.1.1]: https://tools.ietf.org/html/rfc9110#section-13.1.1

                             [api-182]: <https://opensource.zalando.com/restful-api-guidelines/#182>.
            - request_options: typing.Optional[RequestOptions]. Request-specific configuration.
        ---
        from truvity_sdk.client import TruvityApi

        client = TruvityApi(
            api_key="YOUR_API_KEY",
        )
        client.keys.key_delete(
            id="id",
            if_match="If-Match",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "DELETE",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"keys/{jsonable_encoder(id)}"),
            params=jsonable_encoder(
                request_options.get("additional_query_parameters") if request_options is not None else None
            ),
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        "Idempotency-Key": idempotency_key,
                        "If-Match": if_match,
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else 60,
            retries=0,
            max_retries=request_options.get("max_retries") if request_options is not None else 0,  # type: ignore
        )
        if 200 <= _response.status_code < 300:
            return
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(BadRequestErrorBody, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(ProblemUnauthorized, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(ProblemForbidden, _response.json()))  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 500:
            raise InternalServerError(
                pydantic.parse_obj_as(ProblemInternalServerError, _response.json())  # type: ignore
            )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def key_restore(
        self,
        id: ResourceId,
        *,
        idempotency_key: typing.Optional[str] = None,
        if_match: str,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> KeyResource:
        """
        Restore key's resource.

        Parameters:
            - id: ResourceId. Take a look to documentation about #/components/schemas/ResourceID.

            - idempotency_key: typing.Optional[str]. From [Zalando RESTful API Guidelines - models/headers-1.0.0.yaml](https://opensource.zalando.com/restful-api-guidelines/models/headers-1.0.0.yaml).
                                                     The **Idempotency-Key** is a free identifier created by the client to
                                                     identify a request. It is used by the service to identify repeated request
                                                     to ensure idempotent behavior by sending the same (or a similar) response
                                                     without executing the request a second time.

                                                     Clients should be careful as any subsequent requests with the same key may
                                                     return the same response without further check. Thus, it is recommended to
                                                     use a UUID version 4 (random) or any other random string with enough
                                                     entropy to avoid collisions.

                                                     Keys expire after 24 hours. Clients are responsible to stay within this
                                                     limit, if they require idempotent behavior.

                                                     See [API Guideline Rule #181][api-230] for further details.

                                                     [api-230]: <https://opensource.zalando.com/restful-api-guidelines/#230>.
            - if_match: str. From [Zalando RESTful API Guidelines - models/headers-1.0.0.yaml](https://opensource.zalando.com/restful-api-guidelines/models/headers-1.0.0.yaml).
                             The **If-Match** header field is used to declare a list of identifiers that
                             are required to match the current resource version identifier in at least
                             one position as a pre-condition for executing the request on the server
                             side. This behavior is used to validate and reject optimistic updates, by
                             checking if the resource version a consumer has based his changes on is
                             outdated on arrival of the change request to prevent lost updates.

                             If the pre-condition fails the server will respond with status code **412**
                             (Precondition Failed). See [RFC 9110 Section 13.1.1][rfc-9110-13.1.1] as
                             well as [API Guideline Rule #182][api-182] for further details.

                             [rfc-9110-13.1.1]: https://tools.ietf.org/html/rfc9110#section-13.1.1

                             [api-182]: <https://opensource.zalando.com/restful-api-guidelines/#182>.
            - request_options: typing.Optional[RequestOptions]. Request-specific configuration.
        ---
        from truvity_sdk.client import TruvityApi

        client = TruvityApi(
            api_key="YOUR_API_KEY",
        )
        client.keys.key_restore(
            id="id",
            if_match="If-Match",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"keys/{jsonable_encoder(id)}/restore"),
            params=jsonable_encoder(
                request_options.get("additional_query_parameters") if request_options is not None else None
            ),
            json=jsonable_encoder(remove_none_from_dict(request_options.get("additional_body_parameters", {})))
            if request_options is not None
            else None,
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        "Idempotency-Key": idempotency_key,
                        "If-Match": if_match,
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else 60,
            retries=0,
            max_retries=request_options.get("max_retries") if request_options is not None else 0,  # type: ignore
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(KeyResource, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(BadRequestErrorBody, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(ProblemUnauthorized, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(ProblemForbidden, _response.json()))  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 500:
            raise InternalServerError(
                pydantic.parse_obj_as(ProblemInternalServerError, _response.json())  # type: ignore
            )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def key_history(
        self,
        id: ResourceId,
        *,
        if_none_match: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> KeyList:
        """
        History of the keys' resources.

        Parameters:
            - id: ResourceId. Take a look to documentation about #/components/schemas/ResourceID.

            - if_none_match: typing.Optional[str]. From [Zalando RESTful API Guidelines - models/headers-1.0.0.yaml](https://opensource.zalando.com/restful-api-guidelines/models/headers-1.0.0.yaml).
                                                   The **If-None-Match header** field is used to declare a list of identifiers
                                                   that are required to fail matching all the current resource version
                                                   identifiers as a pre-condition for executing the request on the server
                                                   side. This is especially used in conjunction with an **\*** (asterix) that
                                                   is matching all possible resource identifiers to ensure the initial
                                                   creation of a resource. Other use cases are possible but rare.

                                                   If the pre-condition fails the server will respond with status code **412**
                                                   (Precondition Failed). See [RFC 9110 Section 13.1.2][rfc-9110-13.1.2] as
                                                   well as [API Guideline Rule #182][api-182] for further details.

                                                   [rfc-9110-13.1.2]: https://tools.ietf.org/html/rfc9110#section-13.1.2

                                                   [api-182]: <https://opensource.zalando.com/restful-api-guidelines/#182>.
            - request_options: typing.Optional[RequestOptions]. Request-specific configuration.
        ---
        from truvity_sdk.client import TruvityApi

        client = TruvityApi(
            api_key="YOUR_API_KEY",
        )
        client.keys.key_history(
            id="id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"keys/{jsonable_encoder(id)}/revisions"),
            params=jsonable_encoder(
                request_options.get("additional_query_parameters") if request_options is not None else None
            ),
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        "If-None-Match": if_none_match,
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else 60,
            retries=0,
            max_retries=request_options.get("max_retries") if request_options is not None else 0,  # type: ignore
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(KeyList, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(BadRequestErrorBody, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(ProblemUnauthorized, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(ProblemForbidden, _response.json()))  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 500:
            raise InternalServerError(
                pydantic.parse_obj_as(ProblemInternalServerError, _response.json())  # type: ignore
            )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def key_revision(
        self,
        id: ResourceId,
        revision: Revision,
        *,
        if_none_match: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> KeyResource:
        """
        Read the specific version of the key's resource.

        Parameters:
            - id: ResourceId. Take a look to documentation about #/components/schemas/ResourceID.

            - revision: Revision. We could refer to the specific version of the resource.
                                  Take a look to documentation about #/components/schemas/Revision.
            - if_none_match: typing.Optional[str]. From [Zalando RESTful API Guidelines - models/headers-1.0.0.yaml](https://opensource.zalando.com/restful-api-guidelines/models/headers-1.0.0.yaml).
                                                   The **If-None-Match header** field is used to declare a list of identifiers
                                                   that are required to fail matching all the current resource version
                                                   identifiers as a pre-condition for executing the request on the server
                                                   side. This is especially used in conjunction with an **\*** (asterix) that
                                                   is matching all possible resource identifiers to ensure the initial
                                                   creation of a resource. Other use cases are possible but rare.

                                                   If the pre-condition fails the server will respond with status code **412**
                                                   (Precondition Failed). See [RFC 9110 Section 13.1.2][rfc-9110-13.1.2] as
                                                   well as [API Guideline Rule #182][api-182] for further details.

                                                   [rfc-9110-13.1.2]: https://tools.ietf.org/html/rfc9110#section-13.1.2

                                                   [api-182]: <https://opensource.zalando.com/restful-api-guidelines/#182>.
            - request_options: typing.Optional[RequestOptions]. Request-specific configuration.
        ---
        from truvity_sdk.client import TruvityApi

        client = TruvityApi(
            api_key="YOUR_API_KEY",
        )
        client.keys.key_revision(
            id="id",
            revision=1,
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"keys/{jsonable_encoder(id)}/revisions/{jsonable_encoder(revision)}",
            ),
            params=jsonable_encoder(
                request_options.get("additional_query_parameters") if request_options is not None else None
            ),
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        "If-None-Match": if_none_match,
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else 60,
            retries=0,
            max_retries=request_options.get("max_retries") if request_options is not None else 0,  # type: ignore
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(KeyResource, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(BadRequestErrorBody, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(ProblemUnauthorized, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(ProblemForbidden, _response.json()))  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 500:
            raise InternalServerError(
                pydantic.parse_obj_as(ProblemInternalServerError, _response.json())  # type: ignore
            )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)


class AsyncKeysClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def key_generate(
        self,
        *,
        data: KeyGenerate,
        annotations: typing.Optional[Annotations] = OMIT,
        labels: typing.Optional[Labels] = OMIT,
        idempotency_key: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> KeyResource:
        """
        Generate key's resource.

        You could use KeyGenerate, if you want to rely to generated by Truvity key-pairs for CredentialIssue and PresentationIssue.
        Remember, that you do not have any option to get private key by Truvity API, you could only use it

        | Truvity   | JWX - KeyType | JWX - Curve | FIPS  | SEC2      | OpenSSL    | AWS KMS         |
        | --------- | ------------- | ----------- | ----- | --------- | ---------- | --------------- |
        | ED25519   | OKP           | Ed25519     |       |           | ed25519    |                 |
        | P256      | EC            | P-256       | P-256 | secp256r1 | prime256v1 | ECC_NIST_P256   |
        | P384      | EC            | P-384       | P-384 | secp384r1 | secp384r1  | ECC_NIST_P384   |
        | SECP256K1 | EC            | secp256k1   |       | secp256k1 | secp256k1  | ECC_SECG_P256K1 |

        Useful third-party documentation:

        - [openssl-genrsa - generate an RSA private key](https://www.openssl.org/docs/manmaster/man1/openssl-genpkey.html).
        - [openssl-ec, ec - EC key processing](https://www.openssl.org/docs/man1.0.2/man1/ec.html)
        - [openssl-genrsa - generate an RSA private key](https://www.openssl.org/docs/man3.0/man1/openssl-genrsa.html)
        - [openssl-pkcs8 - PKCS#8 format private key conversion command](https://www.openssl.org/docs/manmaster/man1/openssl-pkcs8.html)
        - [JWX - github.com/lestrrat-go/jwx](https://github.com/lestrrat-go/jwx/blob/main/cmd/jwx/README.md)
        - [FIPS 186-4](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.186-4.pdf).
        - [SEC2](https://www.secg.org/sec2-v2.pdf).
        - [AWS KMS - Asymmetric key specs](https://docs.aws.amazon.com/kms/latest/developerguide/asymmetric-key-specs.html)
          .

        Parameters:
            - data: KeyGenerate.

            - annotations: typing.Optional[Annotations].

            - labels: typing.Optional[Labels].

            - idempotency_key: typing.Optional[str]. From [Zalando RESTful API Guidelines - models/headers-1.0.0.yaml](https://opensource.zalando.com/restful-api-guidelines/models/headers-1.0.0.yaml).
                                                     The **Idempotency-Key** is a free identifier created by the client to
                                                     identify a request. It is used by the service to identify repeated request
                                                     to ensure idempotent behavior by sending the same (or a similar) response
                                                     without executing the request a second time.

                                                     Clients should be careful as any subsequent requests with the same key may
                                                     return the same response without further check. Thus, it is recommended to
                                                     use a UUID version 4 (random) or any other random string with enough
                                                     entropy to avoid collisions.

                                                     Keys expire after 24 hours. Clients are responsible to stay within this
                                                     limit, if they require idempotent behavior.

                                                     See [API Guideline Rule #181][api-230] for further details.

                                                     [api-230]: <https://opensource.zalando.com/restful-api-guidelines/#230>.
            - request_options: typing.Optional[RequestOptions]. Request-specific configuration.
        ---
        from truvity_sdk import KeyGenerate
        from truvity_sdk.client import AsyncTruvityApi

        client = AsyncTruvityApi(
            api_key="YOUR_API_KEY",
        )
        await client.keys.key_generate(
            data=KeyGenerate(),
        )
        """
        _request: typing.Dict[str, typing.Any] = {"data": data}
        if annotations is not OMIT:
            _request["annotations"] = annotations
        if labels is not OMIT:
            _request["labels"] = labels
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "keys/generate"),
            params=jsonable_encoder(
                request_options.get("additional_query_parameters") if request_options is not None else None
            ),
            json=jsonable_encoder(_request)
            if request_options is None or request_options.get("additional_body_parameters") is None
            else {
                **jsonable_encoder(_request),
                **(jsonable_encoder(remove_none_from_dict(request_options.get("additional_body_parameters", {})))),
            },
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        "Idempotency-Key": idempotency_key,
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else 60,
            retries=0,
            max_retries=request_options.get("max_retries") if request_options is not None else 0,  # type: ignore
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(KeyResource, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(BadRequestErrorBody, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(ProblemUnauthorized, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(ProblemForbidden, _response.json()))  # type: ignore
        if _response.status_code == 500:
            raise InternalServerError(
                pydantic.parse_obj_as(ProblemInternalServerError, _response.json())  # type: ignore
            )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def key_import(
        self,
        *,
        data: KeyImportPrivate,
        annotations: typing.Optional[Annotations] = OMIT,
        labels: typing.Optional[Labels] = OMIT,
        idempotency_key: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> KeyResource:
        """
        Import key's resource.

        You could use KeyGenerate, if you want to rely to generated by Truvity key-pairs for CredentialIssue and PresentationIssue.
        Remember, that you do not have any option to get private key by Truvity API, you could only use it

        If you prefer to keep private key, then you need to generate it manually.
        To use manually generated key CredentialIssue and PresentationIssue you need to import it.

        To generate key-pair you have two options

        1. OpenSSL - [OpenSSL commands](https://www.openssl.org/docs/man1.1.1/man1/index.html)
        2. JWX tool - [https://github.com/lestrrat-go/jwx/blob/main/cmd/jwx/README.md](https://github.com/lestrrat-go/jwx/blob/main/cmd/jwx/README.md)

        How to install JWX

        1. Download & Install Golang - [https://go.dev/doc/install](https://go.dev/doc/install)
        2. Clone & Build & Install [github.com/lestrrat-go/jwx](https://github.com/lestrrat-go/jwx)
           ```bash
           git clone https://github.com/lestrrat-go/jwx
           cd jwx/cmd/jwx
           go install -tags=jwx_es256k,jwx_secp256k1_pem .
           ```
        3. Verify that you correctly install everything

           ```bash
           âžœ jwx --help
           NAME:
                jwx - Tools for various JWE/JWK/JWS/JWT operations

            USAGE:
                jwx [global options] command [command options] [arguments...]

            COMMANDS:
                jwa      List available algorithms and types
                jwe      Work with JWE messages
                jwk      Work with JWK and JWK sets
                jws      Work with JWS messages
                help, h  Shows a list of commands or help for one command

            GLOBAL OPTIONS:
                --help, -h  show help
           ```

        How generate private key by `jwx` (output format JWK)

        ```bash
        # ED25519
        jwx jwx generate --type OKP --curve Ed25519
        # P256
        jwx jwx generate --type EC --curve P-256
        # P384
        jwx jwx generate --type EC --curve P-384
        # SECP256K1
        jwx jwx generate --type EC --curve secp256k1
        ```

        How to generate public key from private key by `jwx` (input format - JWK, output format - JWK)

        ```bash
        jwx jwk format -I json -O json - <(pathfile with private key in JWK format)
        ```

        How to generate private key by OpenSSL (output format PEM - PKCS#8)

        ```bash
        # ED25519
        openssl genpkey -algorithm ed25519 | openssl pkcs8 -nocrypt -topk8
        # P256
        openssl ecparam -name prime256v1 -noout -genkey | openssl pkcs8 -nocrypt -topk8
        # P384
        openssl ecparam -name secp384r1 -noout -genkey | openssl pkcs8 -nocrypt -topk8
        # SECP256K1
        openssl ecparam -name secp256k1 -noout -genkey | openssl pkcs8 -nocrypt -topk8
        ```

        How to transform existing private key to PKCS8 format by OpenSSL (input format PEM, output format - PEM PCKS#8)

        ```bash
        openssl pkcs8 -nocrypt -topk8 <(pathfile with private key in PEM format)
        ```

        How to transform private key to public key by OpenSSL (input format PEM, output format - PEM PKIX)

        ```bash
        openssl pkey -pubout <(pathfile with private key in PKCS8 format)
        ```

        Useful third-party documentation:

        - [openssl-genrsa - generate an RSA private key](https://www.openssl.org/docs/manmaster/man1/openssl-genpkey.html).
        - [openssl-ec, ec - EC key processing](https://www.openssl.org/docs/man1.0.2/man1/ec.html)
        - [openssl-genrsa - generate an RSA private key](https://www.openssl.org/docs/man3.0/man1/openssl-genrsa.html)
        - [openssl-pkcs8 - PKCS#8 format private key conversion command](https://www.openssl.org/docs/manmaster/man1/openssl-pkcs8.html)
        - [JWX - github.com/lestrrat-go/jwx](https://github.com/lestrrat-go/jwx/blob/main/cmd/jwx/README.md)
        - [FIPS 186-4](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.186-4.pdf).
        - [SEC2](https://www.secg.org/sec2-v2.pdf).
        - [AWS KMS - Asymmetric key specs](https://docs.aws.amazon.com/kms/latest/developerguide/asymmetric-key-specs.html)
          .

        Parameters:
            - data: KeyImportPrivate.

            - annotations: typing.Optional[Annotations].

            - labels: typing.Optional[Labels].

            - idempotency_key: typing.Optional[str]. From [Zalando RESTful API Guidelines - models/headers-1.0.0.yaml](https://opensource.zalando.com/restful-api-guidelines/models/headers-1.0.0.yaml).
                                                     The **Idempotency-Key** is a free identifier created by the client to
                                                     identify a request. It is used by the service to identify repeated request
                                                     to ensure idempotent behavior by sending the same (or a similar) response
                                                     without executing the request a second time.

                                                     Clients should be careful as any subsequent requests with the same key may
                                                     return the same response without further check. Thus, it is recommended to
                                                     use a UUID version 4 (random) or any other random string with enough
                                                     entropy to avoid collisions.

                                                     Keys expire after 24 hours. Clients are responsible to stay within this
                                                     limit, if they require idempotent behavior.

                                                     See [API Guideline Rule #181][api-230] for further details.

                                                     [api-230]: <https://opensource.zalando.com/restful-api-guidelines/#230>.
            - request_options: typing.Optional[RequestOptions]. Request-specific configuration.
        ---
        from truvity_sdk.client import AsyncTruvityApi

        client = AsyncTruvityApi(
            api_key="YOUR_API_KEY",
        )
        await client.keys.key_import(
            data="data",
        )
        """
        _request: typing.Dict[str, typing.Any] = {"data": data}
        if annotations is not OMIT:
            _request["annotations"] = annotations
        if labels is not OMIT:
            _request["labels"] = labels
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "keys/import"),
            params=jsonable_encoder(
                request_options.get("additional_query_parameters") if request_options is not None else None
            ),
            json=jsonable_encoder(_request)
            if request_options is None or request_options.get("additional_body_parameters") is None
            else {
                **jsonable_encoder(_request),
                **(jsonable_encoder(remove_none_from_dict(request_options.get("additional_body_parameters", {})))),
            },
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        "Idempotency-Key": idempotency_key,
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else 60,
            retries=0,
            max_retries=request_options.get("max_retries") if request_options is not None else 0,  # type: ignore
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(KeyResource, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(BadRequestErrorBody, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(ProblemUnauthorized, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(ProblemForbidden, _response.json()))  # type: ignore
        if _response.status_code == 500:
            raise InternalServerError(
                pydantic.parse_obj_as(ProblemInternalServerError, _response.json())  # type: ignore
            )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def key_search(
        self,
        *,
        filter: typing.Optional[typing.Sequence[KeyFilter]] = OMIT,
        sort: typing.Optional[typing.Sequence[KeySort]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> KeyList:
        """
        Take a look at [GET with body payload](https://opensource.zalando.com/restful-api-guidelines/#get-with-body)

        - no resources created: Returns all keys matching the query passed as request input payload.

        Parameters:
            - filter: typing.Optional[typing.Sequence[KeyFilter]]. Filter for the keys' resources.

            - sort: typing.Optional[typing.Sequence[KeySort]]. Sort of the keys' resources.

            - request_options: typing.Optional[RequestOptions]. Request-specific configuration.
        ---
        from truvity_sdk.client import AsyncTruvityApi

        client = AsyncTruvityApi(
            api_key="YOUR_API_KEY",
        )
        await client.keys.key_search()
        """
        _request: typing.Dict[str, typing.Any] = {}
        if filter is not OMIT:
            _request["filter"] = filter
        if sort is not OMIT:
            _request["sort"] = sort
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "keys/search"),
            params=jsonable_encoder(
                request_options.get("additional_query_parameters") if request_options is not None else None
            ),
            json=jsonable_encoder(_request)
            if request_options is None or request_options.get("additional_body_parameters") is None
            else {
                **jsonable_encoder(_request),
                **(jsonable_encoder(remove_none_from_dict(request_options.get("additional_body_parameters", {})))),
            },
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else 60,
            retries=0,
            max_retries=request_options.get("max_retries") if request_options is not None else 0,  # type: ignore
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(KeyList, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(BadRequestErrorBody, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(ProblemUnauthorized, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(ProblemForbidden, _response.json()))  # type: ignore
        if _response.status_code == 500:
            raise InternalServerError(
                pydantic.parse_obj_as(ProblemInternalServerError, _response.json())  # type: ignore
            )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def key_latest(
        self,
        id: ResourceId,
        *,
        if_none_match: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> KeyResource:
        """
        Read the latest revision of the key's resource.

        Parameters:
            - id: ResourceId. Take a look to documentation about #/components/schemas/ResourceID.

            - if_none_match: typing.Optional[str]. From [Zalando RESTful API Guidelines - models/headers-1.0.0.yaml](https://opensource.zalando.com/restful-api-guidelines/models/headers-1.0.0.yaml).
                                                   The **If-None-Match header** field is used to declare a list of identifiers
                                                   that are required to fail matching all the current resource version
                                                   identifiers as a pre-condition for executing the request on the server
                                                   side. This is especially used in conjunction with an **\*** (asterix) that
                                                   is matching all possible resource identifiers to ensure the initial
                                                   creation of a resource. Other use cases are possible but rare.

                                                   If the pre-condition fails the server will respond with status code **412**
                                                   (Precondition Failed). See [RFC 9110 Section 13.1.2][rfc-9110-13.1.2] as
                                                   well as [API Guideline Rule #182][api-182] for further details.

                                                   [rfc-9110-13.1.2]: https://tools.ietf.org/html/rfc9110#section-13.1.2

                                                   [api-182]: <https://opensource.zalando.com/restful-api-guidelines/#182>.
            - request_options: typing.Optional[RequestOptions]. Request-specific configuration.
        ---
        from truvity_sdk.client import AsyncTruvityApi

        client = AsyncTruvityApi(
            api_key="YOUR_API_KEY",
        )
        await client.keys.key_latest(
            id="id",
        )
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"keys/{jsonable_encoder(id)}"),
            params=jsonable_encoder(
                request_options.get("additional_query_parameters") if request_options is not None else None
            ),
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        "If-None-Match": if_none_match,
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else 60,
            retries=0,
            max_retries=request_options.get("max_retries") if request_options is not None else 0,  # type: ignore
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(KeyResource, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(BadRequestErrorBody, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(ProblemUnauthorized, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(ProblemForbidden, _response.json()))  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 500:
            raise InternalServerError(
                pydantic.parse_obj_as(ProblemInternalServerError, _response.json())  # type: ignore
            )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def key_update(
        self,
        id: ResourceId,
        *,
        annotations: typing.Optional[Annotations] = OMIT,
        labels: typing.Optional[Labels] = OMIT,
        idempotency_key: typing.Optional[str] = None,
        if_match: str,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> KeyResource:
        """
        Update key's resource.

        Parameters:
            - id: ResourceId. Take a look to documentation about #/components/schemas/ResourceID.

            - annotations: typing.Optional[Annotations].

            - labels: typing.Optional[Labels].

            - idempotency_key: typing.Optional[str]. From [Zalando RESTful API Guidelines - models/headers-1.0.0.yaml](https://opensource.zalando.com/restful-api-guidelines/models/headers-1.0.0.yaml).
                                                     The **Idempotency-Key** is a free identifier created by the client to
                                                     identify a request. It is used by the service to identify repeated request
                                                     to ensure idempotent behavior by sending the same (or a similar) response
                                                     without executing the request a second time.

                                                     Clients should be careful as any subsequent requests with the same key may
                                                     return the same response without further check. Thus, it is recommended to
                                                     use a UUID version 4 (random) or any other random string with enough
                                                     entropy to avoid collisions.

                                                     Keys expire after 24 hours. Clients are responsible to stay within this
                                                     limit, if they require idempotent behavior.

                                                     See [API Guideline Rule #181][api-230] for further details.

                                                     [api-230]: <https://opensource.zalando.com/restful-api-guidelines/#230>.
            - if_match: str. From [Zalando RESTful API Guidelines - models/headers-1.0.0.yaml](https://opensource.zalando.com/restful-api-guidelines/models/headers-1.0.0.yaml).
                             The **If-Match** header field is used to declare a list of identifiers that
                             are required to match the current resource version identifier in at least
                             one position as a pre-condition for executing the request on the server
                             side. This behavior is used to validate and reject optimistic updates, by
                             checking if the resource version a consumer has based his changes on is
                             outdated on arrival of the change request to prevent lost updates.

                             If the pre-condition fails the server will respond with status code **412**
                             (Precondition Failed). See [RFC 9110 Section 13.1.1][rfc-9110-13.1.1] as
                             well as [API Guideline Rule #182][api-182] for further details.

                             [rfc-9110-13.1.1]: https://tools.ietf.org/html/rfc9110#section-13.1.1

                             [api-182]: <https://opensource.zalando.com/restful-api-guidelines/#182>.
            - request_options: typing.Optional[RequestOptions]. Request-specific configuration.
        ---
        from truvity_sdk.client import AsyncTruvityApi

        client = AsyncTruvityApi(
            api_key="YOUR_API_KEY",
        )
        await client.keys.key_update(
            id="id",
            if_match="If-Match",
        )
        """
        _request: typing.Dict[str, typing.Any] = {}
        if annotations is not OMIT:
            _request["annotations"] = annotations
        if labels is not OMIT:
            _request["labels"] = labels
        _response = await self._client_wrapper.httpx_client.request(
            "PUT",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"keys/{jsonable_encoder(id)}"),
            params=jsonable_encoder(
                request_options.get("additional_query_parameters") if request_options is not None else None
            ),
            json=jsonable_encoder(_request)
            if request_options is None or request_options.get("additional_body_parameters") is None
            else {
                **jsonable_encoder(_request),
                **(jsonable_encoder(remove_none_from_dict(request_options.get("additional_body_parameters", {})))),
            },
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        "Idempotency-Key": idempotency_key,
                        "If-Match": if_match,
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else 60,
            retries=0,
            max_retries=request_options.get("max_retries") if request_options is not None else 0,  # type: ignore
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(KeyResource, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(BadRequestErrorBody, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(ProblemUnauthorized, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(ProblemForbidden, _response.json()))  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 500:
            raise InternalServerError(
                pydantic.parse_obj_as(ProblemInternalServerError, _response.json())  # type: ignore
            )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def key_delete(
        self,
        id: ResourceId,
        *,
        idempotency_key: typing.Optional[str] = None,
        if_match: str,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Delete key's resource.

        Parameters:
            - id: ResourceId. Take a look to documentation about #/components/schemas/ResourceID.

            - idempotency_key: typing.Optional[str]. From [Zalando RESTful API Guidelines - models/headers-1.0.0.yaml](https://opensource.zalando.com/restful-api-guidelines/models/headers-1.0.0.yaml).
                                                     The **Idempotency-Key** is a free identifier created by the client to
                                                     identify a request. It is used by the service to identify repeated request
                                                     to ensure idempotent behavior by sending the same (or a similar) response
                                                     without executing the request a second time.

                                                     Clients should be careful as any subsequent requests with the same key may
                                                     return the same response without further check. Thus, it is recommended to
                                                     use a UUID version 4 (random) or any other random string with enough
                                                     entropy to avoid collisions.

                                                     Keys expire after 24 hours. Clients are responsible to stay within this
                                                     limit, if they require idempotent behavior.

                                                     See [API Guideline Rule #181][api-230] for further details.

                                                     [api-230]: <https://opensource.zalando.com/restful-api-guidelines/#230>.
            - if_match: str. From [Zalando RESTful API Guidelines - models/headers-1.0.0.yaml](https://opensource.zalando.com/restful-api-guidelines/models/headers-1.0.0.yaml).
                             The **If-Match** header field is used to declare a list of identifiers that
                             are required to match the current resource version identifier in at least
                             one position as a pre-condition for executing the request on the server
                             side. This behavior is used to validate and reject optimistic updates, by
                             checking if the resource version a consumer has based his changes on is
                             outdated on arrival of the change request to prevent lost updates.

                             If the pre-condition fails the server will respond with status code **412**
                             (Precondition Failed). See [RFC 9110 Section 13.1.1][rfc-9110-13.1.1] as
                             well as [API Guideline Rule #182][api-182] for further details.

                             [rfc-9110-13.1.1]: https://tools.ietf.org/html/rfc9110#section-13.1.1

                             [api-182]: <https://opensource.zalando.com/restful-api-guidelines/#182>.
            - request_options: typing.Optional[RequestOptions]. Request-specific configuration.
        ---
        from truvity_sdk.client import AsyncTruvityApi

        client = AsyncTruvityApi(
            api_key="YOUR_API_KEY",
        )
        await client.keys.key_delete(
            id="id",
            if_match="If-Match",
        )
        """
        _response = await self._client_wrapper.httpx_client.request(
            "DELETE",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"keys/{jsonable_encoder(id)}"),
            params=jsonable_encoder(
                request_options.get("additional_query_parameters") if request_options is not None else None
            ),
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        "Idempotency-Key": idempotency_key,
                        "If-Match": if_match,
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else 60,
            retries=0,
            max_retries=request_options.get("max_retries") if request_options is not None else 0,  # type: ignore
        )
        if 200 <= _response.status_code < 300:
            return
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(BadRequestErrorBody, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(ProblemUnauthorized, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(ProblemForbidden, _response.json()))  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 500:
            raise InternalServerError(
                pydantic.parse_obj_as(ProblemInternalServerError, _response.json())  # type: ignore
            )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def key_restore(
        self,
        id: ResourceId,
        *,
        idempotency_key: typing.Optional[str] = None,
        if_match: str,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> KeyResource:
        """
        Restore key's resource.

        Parameters:
            - id: ResourceId. Take a look to documentation about #/components/schemas/ResourceID.

            - idempotency_key: typing.Optional[str]. From [Zalando RESTful API Guidelines - models/headers-1.0.0.yaml](https://opensource.zalando.com/restful-api-guidelines/models/headers-1.0.0.yaml).
                                                     The **Idempotency-Key** is a free identifier created by the client to
                                                     identify a request. It is used by the service to identify repeated request
                                                     to ensure idempotent behavior by sending the same (or a similar) response
                                                     without executing the request a second time.

                                                     Clients should be careful as any subsequent requests with the same key may
                                                     return the same response without further check. Thus, it is recommended to
                                                     use a UUID version 4 (random) or any other random string with enough
                                                     entropy to avoid collisions.

                                                     Keys expire after 24 hours. Clients are responsible to stay within this
                                                     limit, if they require idempotent behavior.

                                                     See [API Guideline Rule #181][api-230] for further details.

                                                     [api-230]: <https://opensource.zalando.com/restful-api-guidelines/#230>.
            - if_match: str. From [Zalando RESTful API Guidelines - models/headers-1.0.0.yaml](https://opensource.zalando.com/restful-api-guidelines/models/headers-1.0.0.yaml).
                             The **If-Match** header field is used to declare a list of identifiers that
                             are required to match the current resource version identifier in at least
                             one position as a pre-condition for executing the request on the server
                             side. This behavior is used to validate and reject optimistic updates, by
                             checking if the resource version a consumer has based his changes on is
                             outdated on arrival of the change request to prevent lost updates.

                             If the pre-condition fails the server will respond with status code **412**
                             (Precondition Failed). See [RFC 9110 Section 13.1.1][rfc-9110-13.1.1] as
                             well as [API Guideline Rule #182][api-182] for further details.

                             [rfc-9110-13.1.1]: https://tools.ietf.org/html/rfc9110#section-13.1.1

                             [api-182]: <https://opensource.zalando.com/restful-api-guidelines/#182>.
            - request_options: typing.Optional[RequestOptions]. Request-specific configuration.
        ---
        from truvity_sdk.client import AsyncTruvityApi

        client = AsyncTruvityApi(
            api_key="YOUR_API_KEY",
        )
        await client.keys.key_restore(
            id="id",
            if_match="If-Match",
        )
        """
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"keys/{jsonable_encoder(id)}/restore"),
            params=jsonable_encoder(
                request_options.get("additional_query_parameters") if request_options is not None else None
            ),
            json=jsonable_encoder(remove_none_from_dict(request_options.get("additional_body_parameters", {})))
            if request_options is not None
            else None,
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        "Idempotency-Key": idempotency_key,
                        "If-Match": if_match,
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else 60,
            retries=0,
            max_retries=request_options.get("max_retries") if request_options is not None else 0,  # type: ignore
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(KeyResource, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(BadRequestErrorBody, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(ProblemUnauthorized, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(ProblemForbidden, _response.json()))  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 500:
            raise InternalServerError(
                pydantic.parse_obj_as(ProblemInternalServerError, _response.json())  # type: ignore
            )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def key_history(
        self,
        id: ResourceId,
        *,
        if_none_match: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> KeyList:
        """
        History of the keys' resources.

        Parameters:
            - id: ResourceId. Take a look to documentation about #/components/schemas/ResourceID.

            - if_none_match: typing.Optional[str]. From [Zalando RESTful API Guidelines - models/headers-1.0.0.yaml](https://opensource.zalando.com/restful-api-guidelines/models/headers-1.0.0.yaml).
                                                   The **If-None-Match header** field is used to declare a list of identifiers
                                                   that are required to fail matching all the current resource version
                                                   identifiers as a pre-condition for executing the request on the server
                                                   side. This is especially used in conjunction with an **\*** (asterix) that
                                                   is matching all possible resource identifiers to ensure the initial
                                                   creation of a resource. Other use cases are possible but rare.

                                                   If the pre-condition fails the server will respond with status code **412**
                                                   (Precondition Failed). See [RFC 9110 Section 13.1.2][rfc-9110-13.1.2] as
                                                   well as [API Guideline Rule #182][api-182] for further details.

                                                   [rfc-9110-13.1.2]: https://tools.ietf.org/html/rfc9110#section-13.1.2

                                                   [api-182]: <https://opensource.zalando.com/restful-api-guidelines/#182>.
            - request_options: typing.Optional[RequestOptions]. Request-specific configuration.
        ---
        from truvity_sdk.client import AsyncTruvityApi

        client = AsyncTruvityApi(
            api_key="YOUR_API_KEY",
        )
        await client.keys.key_history(
            id="id",
        )
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"keys/{jsonable_encoder(id)}/revisions"),
            params=jsonable_encoder(
                request_options.get("additional_query_parameters") if request_options is not None else None
            ),
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        "If-None-Match": if_none_match,
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else 60,
            retries=0,
            max_retries=request_options.get("max_retries") if request_options is not None else 0,  # type: ignore
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(KeyList, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(BadRequestErrorBody, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(ProblemUnauthorized, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(ProblemForbidden, _response.json()))  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 500:
            raise InternalServerError(
                pydantic.parse_obj_as(ProblemInternalServerError, _response.json())  # type: ignore
            )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def key_revision(
        self,
        id: ResourceId,
        revision: Revision,
        *,
        if_none_match: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> KeyResource:
        """
        Read the specific version of the key's resource.

        Parameters:
            - id: ResourceId. Take a look to documentation about #/components/schemas/ResourceID.

            - revision: Revision. We could refer to the specific version of the resource.
                                  Take a look to documentation about #/components/schemas/Revision.
            - if_none_match: typing.Optional[str]. From [Zalando RESTful API Guidelines - models/headers-1.0.0.yaml](https://opensource.zalando.com/restful-api-guidelines/models/headers-1.0.0.yaml).
                                                   The **If-None-Match header** field is used to declare a list of identifiers
                                                   that are required to fail matching all the current resource version
                                                   identifiers as a pre-condition for executing the request on the server
                                                   side. This is especially used in conjunction with an **\*** (asterix) that
                                                   is matching all possible resource identifiers to ensure the initial
                                                   creation of a resource. Other use cases are possible but rare.

                                                   If the pre-condition fails the server will respond with status code **412**
                                                   (Precondition Failed). See [RFC 9110 Section 13.1.2][rfc-9110-13.1.2] as
                                                   well as [API Guideline Rule #182][api-182] for further details.

                                                   [rfc-9110-13.1.2]: https://tools.ietf.org/html/rfc9110#section-13.1.2

                                                   [api-182]: <https://opensource.zalando.com/restful-api-guidelines/#182>.
            - request_options: typing.Optional[RequestOptions]. Request-specific configuration.
        ---
        from truvity_sdk.client import AsyncTruvityApi

        client = AsyncTruvityApi(
            api_key="YOUR_API_KEY",
        )
        await client.keys.key_revision(
            id="id",
            revision=1,
        )
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"keys/{jsonable_encoder(id)}/revisions/{jsonable_encoder(revision)}",
            ),
            params=jsonable_encoder(
                request_options.get("additional_query_parameters") if request_options is not None else None
            ),
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        "If-None-Match": if_none_match,
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else 60,
            retries=0,
            max_retries=request_options.get("max_retries") if request_options is not None else 0,  # type: ignore
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(KeyResource, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(BadRequestErrorBody, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(ProblemUnauthorized, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(ProblemForbidden, _response.json()))  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 500:
            raise InternalServerError(
                pydantic.parse_obj_as(ProblemInternalServerError, _response.json())  # type: ignore
            )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)
