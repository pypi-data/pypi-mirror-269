# Generated from QuietParser.g4 by ANTLR 4.13.0
# encoding: utf-8
from antlr4 import *
from io import StringIO
import sys
if sys.version_info[1] > 5:
	from typing import TextIO
else:
	from typing.io import TextIO

def serializedATN():
    return [
        4,1,79,554,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,7,
        6,2,7,7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,13,
        2,14,7,14,2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,20,
        7,20,2,21,7,21,2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,2,26,7,26,
        2,27,7,27,2,28,7,28,2,29,7,29,2,30,7,30,2,31,7,31,2,32,7,32,2,33,
        7,33,2,34,7,34,2,35,7,35,2,36,7,36,2,37,7,37,2,38,7,38,2,39,7,39,
        2,40,7,40,2,41,7,41,2,42,7,42,2,43,7,43,2,44,7,44,2,45,7,45,2,46,
        7,46,2,47,7,47,2,48,7,48,2,49,7,49,2,50,7,50,2,51,7,51,2,52,7,52,
        2,53,7,53,2,54,7,54,2,55,7,55,2,56,7,56,2,57,7,57,2,58,7,58,2,59,
        7,59,2,60,7,60,2,61,7,61,2,62,7,62,2,63,7,63,2,64,7,64,1,0,3,0,132,
        8,0,1,0,3,0,135,8,0,1,0,3,0,138,8,0,1,0,3,0,141,8,0,1,1,5,1,144,
        8,1,10,1,12,1,147,9,1,1,1,1,1,1,1,1,1,5,1,153,8,1,10,1,12,1,156,
        9,1,1,1,1,1,1,2,5,2,161,8,2,10,2,12,2,164,9,2,1,2,1,2,3,2,168,8,
        2,1,3,1,3,1,3,1,3,1,4,4,4,175,8,4,11,4,12,4,176,1,5,1,5,1,5,1,5,
        1,6,1,6,1,6,5,6,186,8,6,10,6,12,6,189,9,6,1,7,5,7,192,8,7,10,7,12,
        7,195,9,7,1,7,1,7,1,7,1,8,1,8,1,8,1,8,1,9,5,9,205,8,9,10,9,12,9,
        208,9,9,1,10,1,10,1,10,1,10,1,10,1,11,1,11,1,11,1,11,1,12,1,12,1,
        12,3,12,222,8,12,1,12,5,12,225,8,12,10,12,12,12,228,9,12,1,13,5,
        13,231,8,13,10,13,12,13,234,9,13,1,13,1,13,1,13,1,14,1,14,1,14,1,
        14,1,15,5,15,244,8,15,10,15,12,15,247,9,15,1,16,1,16,1,16,1,16,1,
        16,1,16,1,16,3,16,256,8,16,1,17,1,17,1,17,3,17,261,8,17,1,17,1,17,
        1,17,1,17,1,17,1,17,3,17,269,8,17,1,18,1,18,1,18,5,18,274,8,18,10,
        18,12,18,277,9,18,1,19,1,19,1,19,5,19,282,8,19,10,19,12,19,285,9,
        19,1,20,1,20,1,20,1,21,5,21,291,8,21,10,21,12,21,294,9,21,1,22,1,
        22,1,22,3,22,299,8,22,3,22,301,8,22,1,22,1,22,1,23,1,23,1,24,1,24,
        1,24,1,24,1,24,1,24,1,24,1,24,1,24,1,24,1,24,1,24,1,24,1,24,1,24,
        1,24,1,24,1,24,1,24,3,24,326,8,24,1,25,1,25,1,25,1,25,5,25,332,8,
        25,10,25,12,25,335,9,25,3,25,337,8,25,1,26,1,26,1,26,1,26,5,26,343,
        8,26,10,26,12,26,346,9,26,1,26,1,26,1,27,1,27,1,27,1,28,3,28,354,
        8,28,1,28,1,28,1,28,1,28,1,28,3,28,361,8,28,1,28,1,28,1,28,5,28,
        366,8,28,10,28,12,28,369,9,28,1,29,1,29,3,29,373,8,29,1,30,1,30,
        1,31,1,31,1,31,5,31,380,8,31,10,31,12,31,383,9,31,1,32,1,32,3,32,
        387,8,32,1,33,1,33,1,34,1,34,1,34,1,34,1,34,1,34,1,35,1,35,1,36,
        1,36,1,37,1,37,1,37,3,37,404,8,37,1,38,1,38,1,38,3,38,409,8,38,1,
        39,1,39,1,40,1,40,1,40,1,40,1,41,1,41,1,41,1,41,4,41,421,8,41,11,
        41,12,41,422,1,42,1,42,1,42,1,42,5,42,429,8,42,10,42,12,42,432,9,
        42,1,43,1,43,1,43,1,43,3,43,438,8,43,1,44,3,44,441,8,44,1,44,1,44,
        1,44,3,44,446,8,44,1,44,1,44,1,44,1,44,1,44,5,44,453,8,44,10,44,
        12,44,456,9,44,3,44,458,8,44,1,45,1,45,1,45,1,45,3,45,464,8,45,1,
        46,1,46,1,46,1,46,1,46,3,46,471,8,46,1,47,1,47,1,48,1,48,1,48,1,
        48,1,48,1,48,3,48,481,8,48,1,49,1,49,1,50,1,50,3,50,487,8,50,1,51,
        1,51,1,51,1,51,1,51,1,51,1,51,1,52,1,52,1,53,1,53,1,53,1,53,1,53,
        1,53,1,53,1,54,1,54,1,55,1,55,1,55,1,55,1,55,1,55,3,55,513,8,55,
        1,55,1,55,1,56,1,56,1,57,1,57,3,57,521,8,57,1,58,1,58,1,58,1,58,
        1,58,3,58,528,8,58,1,59,1,59,1,60,1,60,3,60,534,8,60,1,61,1,61,1,
        61,1,61,1,61,1,61,1,61,1,62,1,62,1,63,1,63,1,63,1,63,1,63,1,63,1,
        63,1,64,1,64,1,64,0,0,65,0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,
        30,32,34,36,38,40,42,44,46,48,50,52,54,56,58,60,62,64,66,68,70,72,
        74,76,78,80,82,84,86,88,90,92,94,96,98,100,102,104,106,108,110,112,
        114,116,118,120,122,124,126,128,0,15,1,1,74,74,2,0,9,19,77,77,2,
        0,8,8,20,25,1,0,75,76,2,0,6,6,31,32,2,0,75,75,77,77,2,0,30,30,77,
        77,1,0,33,34,1,0,35,38,4,0,39,39,41,41,43,43,45,45,4,0,40,40,42,
        42,44,44,46,46,1,0,47,53,1,0,54,55,4,0,56,56,58,58,60,60,62,62,4,
        0,57,57,59,59,61,61,63,63,548,0,131,1,0,0,0,2,145,1,0,0,0,4,162,
        1,0,0,0,6,169,1,0,0,0,8,174,1,0,0,0,10,178,1,0,0,0,12,182,1,0,0,
        0,14,193,1,0,0,0,16,199,1,0,0,0,18,206,1,0,0,0,20,209,1,0,0,0,22,
        214,1,0,0,0,24,218,1,0,0,0,26,232,1,0,0,0,28,238,1,0,0,0,30,245,
        1,0,0,0,32,248,1,0,0,0,34,257,1,0,0,0,36,270,1,0,0,0,38,278,1,0,
        0,0,40,286,1,0,0,0,42,292,1,0,0,0,44,300,1,0,0,0,46,304,1,0,0,0,
        48,325,1,0,0,0,50,327,1,0,0,0,52,338,1,0,0,0,54,349,1,0,0,0,56,353,
        1,0,0,0,58,372,1,0,0,0,60,374,1,0,0,0,62,376,1,0,0,0,64,386,1,0,
        0,0,66,388,1,0,0,0,68,390,1,0,0,0,70,396,1,0,0,0,72,398,1,0,0,0,
        74,403,1,0,0,0,76,408,1,0,0,0,78,410,1,0,0,0,80,412,1,0,0,0,82,416,
        1,0,0,0,84,424,1,0,0,0,86,433,1,0,0,0,88,440,1,0,0,0,90,463,1,0,
        0,0,92,465,1,0,0,0,94,472,1,0,0,0,96,474,1,0,0,0,98,482,1,0,0,0,
        100,486,1,0,0,0,102,488,1,0,0,0,104,495,1,0,0,0,106,497,1,0,0,0,
        108,504,1,0,0,0,110,506,1,0,0,0,112,516,1,0,0,0,114,520,1,0,0,0,
        116,522,1,0,0,0,118,529,1,0,0,0,120,533,1,0,0,0,122,535,1,0,0,0,
        124,542,1,0,0,0,126,544,1,0,0,0,128,551,1,0,0,0,130,132,3,2,1,0,
        131,130,1,0,0,0,131,132,1,0,0,0,132,134,1,0,0,0,133,135,3,4,2,0,
        134,133,1,0,0,0,134,135,1,0,0,0,135,137,1,0,0,0,136,138,3,14,7,0,
        137,136,1,0,0,0,137,138,1,0,0,0,138,140,1,0,0,0,139,141,3,26,13,
        0,140,139,1,0,0,0,140,141,1,0,0,0,141,1,1,0,0,0,142,144,5,74,0,0,
        143,142,1,0,0,0,144,147,1,0,0,0,145,143,1,0,0,0,145,146,1,0,0,0,
        146,148,1,0,0,0,147,145,1,0,0,0,148,149,5,5,0,0,149,154,5,77,0,0,
        150,151,5,69,0,0,151,153,5,77,0,0,152,150,1,0,0,0,153,156,1,0,0,
        0,154,152,1,0,0,0,154,155,1,0,0,0,155,157,1,0,0,0,156,154,1,0,0,
        0,157,158,5,74,0,0,158,3,1,0,0,0,159,161,5,74,0,0,160,159,1,0,0,
        0,161,164,1,0,0,0,162,160,1,0,0,0,162,163,1,0,0,0,163,165,1,0,0,
        0,164,162,1,0,0,0,165,167,3,6,3,0,166,168,3,8,4,0,167,166,1,0,0,
        0,167,168,1,0,0,0,168,5,1,0,0,0,169,170,5,1,0,0,170,171,5,68,0,0,
        171,172,5,74,0,0,172,7,1,0,0,0,173,175,3,10,5,0,174,173,1,0,0,0,
        175,176,1,0,0,0,176,174,1,0,0,0,176,177,1,0,0,0,177,9,1,0,0,0,178,
        179,5,4,0,0,179,180,3,12,6,0,180,181,5,74,0,0,181,11,1,0,0,0,182,
        187,5,77,0,0,183,184,5,70,0,0,184,186,5,77,0,0,185,183,1,0,0,0,186,
        189,1,0,0,0,187,185,1,0,0,0,187,188,1,0,0,0,188,13,1,0,0,0,189,187,
        1,0,0,0,190,192,5,74,0,0,191,190,1,0,0,0,192,195,1,0,0,0,193,191,
        1,0,0,0,193,194,1,0,0,0,194,196,1,0,0,0,195,193,1,0,0,0,196,197,
        3,16,8,0,197,198,3,18,9,0,198,15,1,0,0,0,199,200,5,2,0,0,200,201,
        5,68,0,0,201,202,5,74,0,0,202,17,1,0,0,0,203,205,3,20,10,0,204,203,
        1,0,0,0,205,208,1,0,0,0,206,204,1,0,0,0,206,207,1,0,0,0,207,19,1,
        0,0,0,208,206,1,0,0,0,209,210,5,7,0,0,210,211,5,77,0,0,211,212,3,
        22,11,0,212,213,5,74,0,0,213,21,1,0,0,0,214,215,5,64,0,0,215,216,
        3,24,12,0,216,217,5,65,0,0,217,23,1,0,0,0,218,226,3,74,37,0,219,
        221,5,69,0,0,220,222,5,74,0,0,221,220,1,0,0,0,221,222,1,0,0,0,222,
        223,1,0,0,0,223,225,3,74,37,0,224,219,1,0,0,0,225,228,1,0,0,0,226,
        224,1,0,0,0,226,227,1,0,0,0,227,25,1,0,0,0,228,226,1,0,0,0,229,231,
        5,74,0,0,230,229,1,0,0,0,231,234,1,0,0,0,232,230,1,0,0,0,232,233,
        1,0,0,0,233,235,1,0,0,0,234,232,1,0,0,0,235,236,3,28,14,0,236,237,
        3,30,15,0,237,27,1,0,0,0,238,239,5,3,0,0,239,240,5,68,0,0,240,241,
        5,74,0,0,241,29,1,0,0,0,242,244,3,32,16,0,243,242,1,0,0,0,244,247,
        1,0,0,0,245,243,1,0,0,0,245,246,1,0,0,0,246,31,1,0,0,0,247,245,1,
        0,0,0,248,249,5,27,0,0,249,250,3,34,17,0,250,251,5,68,0,0,251,252,
        5,74,0,0,252,253,3,42,21,0,253,255,5,29,0,0,254,256,7,0,0,0,255,
        254,1,0,0,0,255,256,1,0,0,0,256,33,1,0,0,0,257,258,5,77,0,0,258,
        260,5,66,0,0,259,261,3,36,18,0,260,259,1,0,0,0,260,261,1,0,0,0,261,
        262,1,0,0,0,262,268,5,67,0,0,263,264,5,73,0,0,264,265,5,66,0,0,265,
        266,3,38,19,0,266,267,5,67,0,0,267,269,1,0,0,0,268,263,1,0,0,0,268,
        269,1,0,0,0,269,35,1,0,0,0,270,275,3,40,20,0,271,272,5,69,0,0,272,
        274,3,40,20,0,273,271,1,0,0,0,274,277,1,0,0,0,275,273,1,0,0,0,275,
        276,1,0,0,0,276,37,1,0,0,0,277,275,1,0,0,0,278,283,3,40,20,0,279,
        280,5,69,0,0,280,282,3,40,20,0,281,279,1,0,0,0,282,285,1,0,0,0,283,
        281,1,0,0,0,283,284,1,0,0,0,284,39,1,0,0,0,285,283,1,0,0,0,286,287,
        3,76,38,0,287,288,5,77,0,0,288,41,1,0,0,0,289,291,3,44,22,0,290,
        289,1,0,0,0,291,294,1,0,0,0,292,290,1,0,0,0,292,293,1,0,0,0,293,
        43,1,0,0,0,294,292,1,0,0,0,295,296,3,46,23,0,296,298,5,68,0,0,297,
        299,5,74,0,0,298,297,1,0,0,0,298,299,1,0,0,0,299,301,1,0,0,0,300,
        295,1,0,0,0,300,301,1,0,0,0,301,302,1,0,0,0,302,303,3,48,24,0,303,
        45,1,0,0,0,304,305,5,77,0,0,305,47,1,0,0,0,306,307,3,90,45,0,307,
        308,5,74,0,0,308,326,1,0,0,0,309,310,3,114,57,0,310,311,5,74,0,0,
        311,326,1,0,0,0,312,313,3,56,28,0,313,314,5,74,0,0,314,326,1,0,0,
        0,315,316,3,88,44,0,316,317,5,74,0,0,317,326,1,0,0,0,318,319,3,50,
        25,0,319,320,5,74,0,0,320,326,1,0,0,0,321,322,3,84,42,0,322,323,
        5,74,0,0,323,326,1,0,0,0,324,326,5,74,0,0,325,306,1,0,0,0,325,309,
        1,0,0,0,325,312,1,0,0,0,325,315,1,0,0,0,325,318,1,0,0,0,325,321,
        1,0,0,0,325,324,1,0,0,0,326,49,1,0,0,0,327,336,5,28,0,0,328,333,
        3,86,43,0,329,330,5,69,0,0,330,332,3,86,43,0,331,329,1,0,0,0,332,
        335,1,0,0,0,333,331,1,0,0,0,333,334,1,0,0,0,334,337,1,0,0,0,335,
        333,1,0,0,0,336,328,1,0,0,0,336,337,1,0,0,0,337,51,1,0,0,0,338,339,
        5,71,0,0,339,344,3,86,43,0,340,341,5,69,0,0,341,343,3,86,43,0,342,
        340,1,0,0,0,343,346,1,0,0,0,344,342,1,0,0,0,344,345,1,0,0,0,345,
        347,1,0,0,0,346,344,1,0,0,0,347,348,5,72,0,0,348,53,1,0,0,0,349,
        350,5,26,0,0,350,351,3,52,26,0,351,55,1,0,0,0,352,354,3,54,27,0,
        353,352,1,0,0,0,353,354,1,0,0,0,354,355,1,0,0,0,355,360,3,58,29,
        0,356,357,5,66,0,0,357,358,3,62,31,0,358,359,5,67,0,0,359,361,1,
        0,0,0,360,356,1,0,0,0,360,361,1,0,0,0,361,362,1,0,0,0,362,367,3,
        86,43,0,363,364,5,69,0,0,364,366,3,86,43,0,365,363,1,0,0,0,366,369,
        1,0,0,0,367,365,1,0,0,0,367,368,1,0,0,0,368,57,1,0,0,0,369,367,1,
        0,0,0,370,373,3,60,30,0,371,373,3,66,33,0,372,370,1,0,0,0,372,371,
        1,0,0,0,373,59,1,0,0,0,374,375,7,1,0,0,375,61,1,0,0,0,376,381,3,
        64,32,0,377,378,5,69,0,0,378,380,3,64,32,0,379,377,1,0,0,0,380,383,
        1,0,0,0,381,379,1,0,0,0,381,382,1,0,0,0,382,63,1,0,0,0,383,381,1,
        0,0,0,384,387,3,74,37,0,385,387,3,86,43,0,386,384,1,0,0,0,386,385,
        1,0,0,0,387,65,1,0,0,0,388,389,7,2,0,0,389,67,1,0,0,0,390,391,5,
        66,0,0,391,392,3,70,35,0,392,393,5,69,0,0,393,394,3,72,36,0,394,
        395,5,67,0,0,395,69,1,0,0,0,396,397,7,3,0,0,397,71,1,0,0,0,398,399,
        7,3,0,0,399,73,1,0,0,0,400,404,5,75,0,0,401,404,5,76,0,0,402,404,
        3,68,34,0,403,400,1,0,0,0,403,401,1,0,0,0,403,402,1,0,0,0,404,75,
        1,0,0,0,405,409,3,78,39,0,406,409,3,80,40,0,407,409,3,82,41,0,408,
        405,1,0,0,0,408,406,1,0,0,0,408,407,1,0,0,0,409,77,1,0,0,0,410,411,
        7,4,0,0,411,79,1,0,0,0,412,413,3,78,39,0,413,414,5,64,0,0,414,415,
        5,65,0,0,415,81,1,0,0,0,416,420,3,78,39,0,417,418,5,64,0,0,418,419,
        7,5,0,0,419,421,5,65,0,0,420,417,1,0,0,0,421,422,1,0,0,0,422,420,
        1,0,0,0,422,423,1,0,0,0,423,83,1,0,0,0,424,425,3,76,38,0,425,430,
        5,77,0,0,426,427,5,69,0,0,427,429,5,77,0,0,428,426,1,0,0,0,429,432,
        1,0,0,0,430,428,1,0,0,0,430,431,1,0,0,0,431,85,1,0,0,0,432,430,1,
        0,0,0,433,437,5,77,0,0,434,435,5,64,0,0,435,436,7,5,0,0,436,438,
        5,65,0,0,437,434,1,0,0,0,437,438,1,0,0,0,438,87,1,0,0,0,439,441,
        3,54,27,0,440,439,1,0,0,0,440,441,1,0,0,0,441,442,1,0,0,0,442,443,
        7,6,0,0,443,445,5,66,0,0,444,446,3,62,31,0,445,444,1,0,0,0,445,446,
        1,0,0,0,446,447,1,0,0,0,447,457,5,67,0,0,448,449,5,73,0,0,449,454,
        3,86,43,0,450,451,5,69,0,0,451,453,3,86,43,0,452,450,1,0,0,0,453,
        456,1,0,0,0,454,452,1,0,0,0,454,455,1,0,0,0,455,458,1,0,0,0,456,
        454,1,0,0,0,457,448,1,0,0,0,457,458,1,0,0,0,458,89,1,0,0,0,459,464,
        3,92,46,0,460,464,3,100,50,0,461,464,3,96,48,0,462,464,3,110,55,
        0,463,459,1,0,0,0,463,460,1,0,0,0,463,461,1,0,0,0,463,462,1,0,0,
        0,464,91,1,0,0,0,465,466,3,94,47,0,466,467,3,86,43,0,467,470,5,69,
        0,0,468,471,3,86,43,0,469,471,3,74,37,0,470,468,1,0,0,0,470,469,
        1,0,0,0,471,93,1,0,0,0,472,473,7,7,0,0,473,95,1,0,0,0,474,475,3,
        98,49,0,475,476,3,86,43,0,476,477,5,69,0,0,477,480,3,86,43,0,478,
        479,5,69,0,0,479,481,3,86,43,0,480,478,1,0,0,0,480,481,1,0,0,0,481,
        97,1,0,0,0,482,483,7,8,0,0,483,99,1,0,0,0,484,487,3,102,51,0,485,
        487,3,106,53,0,486,484,1,0,0,0,486,485,1,0,0,0,487,101,1,0,0,0,488,
        489,3,104,52,0,489,490,3,86,43,0,490,491,5,69,0,0,491,492,3,86,43,
        0,492,493,5,69,0,0,493,494,3,86,43,0,494,103,1,0,0,0,495,496,7,9,
        0,0,496,105,1,0,0,0,497,498,3,108,54,0,498,499,3,86,43,0,499,500,
        5,69,0,0,500,501,3,86,43,0,501,502,5,69,0,0,502,503,3,74,37,0,503,
        107,1,0,0,0,504,505,7,10,0,0,505,109,1,0,0,0,506,512,3,112,56,0,
        507,508,3,86,43,0,508,509,5,69,0,0,509,510,3,86,43,0,510,511,5,69,
        0,0,511,513,1,0,0,0,512,507,1,0,0,0,512,513,1,0,0,0,513,514,1,0,
        0,0,514,515,3,46,23,0,515,111,1,0,0,0,516,517,7,11,0,0,517,113,1,
        0,0,0,518,521,3,116,58,0,519,521,3,120,60,0,520,518,1,0,0,0,520,
        519,1,0,0,0,521,115,1,0,0,0,522,523,3,118,59,0,523,524,3,86,43,0,
        524,527,5,69,0,0,525,528,3,86,43,0,526,528,3,74,37,0,527,525,1,0,
        0,0,527,526,1,0,0,0,528,117,1,0,0,0,529,530,7,12,0,0,530,119,1,0,
        0,0,531,534,3,122,61,0,532,534,3,126,63,0,533,531,1,0,0,0,533,532,
        1,0,0,0,534,121,1,0,0,0,535,536,3,124,62,0,536,537,3,86,43,0,537,
        538,5,69,0,0,538,539,3,86,43,0,539,540,5,69,0,0,540,541,3,86,43,
        0,541,123,1,0,0,0,542,543,7,13,0,0,543,125,1,0,0,0,544,545,3,128,
        64,0,545,546,3,86,43,0,546,547,5,69,0,0,547,548,3,86,43,0,548,549,
        5,69,0,0,549,550,3,74,37,0,550,127,1,0,0,0,551,552,7,14,0,0,552,
        129,1,0,0,0,51,131,134,137,140,145,154,162,167,176,187,193,206,221,
        226,232,245,255,260,268,275,283,292,298,300,325,333,336,344,353,
        360,367,372,381,386,403,408,422,430,437,440,445,454,457,463,470,
        480,486,512,520,527,533
    ]

class QuietParser ( Parser ):

    grammarFileName = "QuietParser.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "'.file'", "'.gate'", "'.body'", "'include'", 
                     "'using'", "'qubit'", "'define'", "'U4'", "'H'", "'X'", 
                     "'Y'", "'Z'", "'S'", "'Sdag'", "'T'", "'Tdag'", "'CNOT'", 
                     "'CZ'", "'SWAP'", "'Rx'", "'Ry'", "'Rz'", "'Rxy'", 
                     "'CP'", "'CRz'", "'ctrl'", "'func'", "'return'", "'end'", 
                     "'measure'", "'int'", "'double'", "'ld'", "'mov'", 
                     "'land'", "'lnot'", "'lor'", "'lxor'", "'add'", "'addi'", 
                     "'sub'", "'subi'", "'mul'", "'muli'", "'div'", "'divi'", 
                     "'jump'", "'bne'", "'beq'", "'bgt'", "'bge'", "'blt'", 
                     "'ble'", "'ldd'", "'movd'", "'addd'", "'adddi'", "'subd'", 
                     "'subdi'", "'muld'", "'muldi'", "'divd'", "'divdi'", 
                     "'['", "']'", "'('", "')'", "':'", "','", "'.'", "'<'", 
                     "'>'", "'->'", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "' '" ]

    symbolicNames = [ "<INVALID>", "DotFile", "DotGate", "DotBody", "Include", 
                      "Using", "Qubit", "Define", "U4", "Hadamard", "PauliX", 
                      "PauliY", "PauliZ", "SGate", "Sdag", "TGate", "Tdg", 
                      "Cnot", "Cz", "Swap", "Rx", "Ry", "Rz", "Rxy", "CPhase", 
                      "CRz", "Control", "Func", "Return", "End", "Measure", 
                      "Int", "Double", "Ld", "Mov", "Land", "Lnot", "Lor", 
                      "Lxor", "Add", "Addi", "Sub", "Subi", "Mul", "Muli", 
                      "Div", "Divi", "Jump", "Bne", "Beq", "Bgt", "Bge", 
                      "Blt", "Ble", "Ldd", "Movd", "Addd", "Adddi", "Subd", 
                      "Subdi", "Muld", "Muldi", "Divd", "Divdi", "BracketLeft", 
                      "BracketRight", "ParenLeft", "ParenRight", "Colon", 
                      "Comma", "Dot", "Less", "Greater", "RightArrow", "EOL", 
                      "IntLiteral", "DoubleLiteral", "Id", "WS", "Comment" ]

    RULE_prog = 0
    RULE_usingModules = 1
    RULE_fileSection = 2
    RULE_fileSecDecl = 3
    RULE_fileSecContent = 4
    RULE_includeStatement = 5
    RULE_filename = 6
    RULE_gateSection = 7
    RULE_gateSecDecl = 8
    RULE_gateSecContent = 9
    RULE_gateDefinition = 10
    RULE_numberArray = 11
    RULE_numberList = 12
    RULE_bodySection = 13
    RULE_bodySecDecl = 14
    RULE_bodySecContent = 15
    RULE_function = 16
    RULE_funcHeader = 17
    RULE_inputArgs = 18
    RULE_outputArgs = 19
    RULE_formalParam = 20
    RULE_funcBody = 21
    RULE_action = 22
    RULE_label = 23
    RULE_instruction = 24
    RULE_returnStmt = 25
    RULE_controlQubit = 26
    RULE_controlModifier = 27
    RULE_quantumOpInsn = 28
    RULE_quantumGate = 29
    RULE_gateNoParam = 30
    RULE_actualParamList = 31
    RULE_actualParam = 32
    RULE_gateWithParams = 33
    RULE_complexLiteral = 34
    RULE_realPart = 35
    RULE_imaginaryPart = 36
    RULE_number = 37
    RULE_paramType = 38
    RULE_typeAtomic = 39
    RULE_typeArrayNoLength = 40
    RULE_typeArrayWithLength = 41
    RULE_variableDecl = 42
    RULE_variable = 43
    RULE_funcCall = 44
    RULE_integerModuleInsn = 45
    RULE_imDataTransferInsn = 46
    RULE_imDTOp = 47
    RULE_logicInsn = 48
    RULE_imLogicOp = 49
    RULE_imArithmeticInsn = 50
    RULE_imArithVarInsn = 51
    RULE_imArithVarOp = 52
    RULE_imArithImmInsn = 53
    RULE_imArithImmOp = 54
    RULE_jumpInsn = 55
    RULE_jumpOp = 56
    RULE_floatModuleInsn = 57
    RULE_fmDataTransferInsn = 58
    RULE_fmDTOp = 59
    RULE_fmArithmeticInsn = 60
    RULE_fmArithVarInsn = 61
    RULE_fmArithVarOp = 62
    RULE_fmArithImmInsn = 63
    RULE_fmArithImmOp = 64

    ruleNames =  [ "prog", "usingModules", "fileSection", "fileSecDecl", 
                   "fileSecContent", "includeStatement", "filename", "gateSection", 
                   "gateSecDecl", "gateSecContent", "gateDefinition", "numberArray", 
                   "numberList", "bodySection", "bodySecDecl", "bodySecContent", 
                   "function", "funcHeader", "inputArgs", "outputArgs", 
                   "formalParam", "funcBody", "action", "label", "instruction", 
                   "returnStmt", "controlQubit", "controlModifier", "quantumOpInsn", 
                   "quantumGate", "gateNoParam", "actualParamList", "actualParam", 
                   "gateWithParams", "complexLiteral", "realPart", "imaginaryPart", 
                   "number", "paramType", "typeAtomic", "typeArrayNoLength", 
                   "typeArrayWithLength", "variableDecl", "variable", "funcCall", 
                   "integerModuleInsn", "imDataTransferInsn", "imDTOp", 
                   "logicInsn", "imLogicOp", "imArithmeticInsn", "imArithVarInsn", 
                   "imArithVarOp", "imArithImmInsn", "imArithImmOp", "jumpInsn", 
                   "jumpOp", "floatModuleInsn", "fmDataTransferInsn", "fmDTOp", 
                   "fmArithmeticInsn", "fmArithVarInsn", "fmArithVarOp", 
                   "fmArithImmInsn", "fmArithImmOp" ]

    EOF = Token.EOF
    DotFile=1
    DotGate=2
    DotBody=3
    Include=4
    Using=5
    Qubit=6
    Define=7
    U4=8
    Hadamard=9
    PauliX=10
    PauliY=11
    PauliZ=12
    SGate=13
    Sdag=14
    TGate=15
    Tdg=16
    Cnot=17
    Cz=18
    Swap=19
    Rx=20
    Ry=21
    Rz=22
    Rxy=23
    CPhase=24
    CRz=25
    Control=26
    Func=27
    Return=28
    End=29
    Measure=30
    Int=31
    Double=32
    Ld=33
    Mov=34
    Land=35
    Lnot=36
    Lor=37
    Lxor=38
    Add=39
    Addi=40
    Sub=41
    Subi=42
    Mul=43
    Muli=44
    Div=45
    Divi=46
    Jump=47
    Bne=48
    Beq=49
    Bgt=50
    Bge=51
    Blt=52
    Ble=53
    Ldd=54
    Movd=55
    Addd=56
    Adddi=57
    Subd=58
    Subdi=59
    Muld=60
    Muldi=61
    Divd=62
    Divdi=63
    BracketLeft=64
    BracketRight=65
    ParenLeft=66
    ParenRight=67
    Colon=68
    Comma=69
    Dot=70
    Less=71
    Greater=72
    RightArrow=73
    EOL=74
    IntLiteral=75
    DoubleLiteral=76
    Id=77
    WS=78
    Comment=79

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.13.0")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None




    class ProgContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def usingModules(self):
            return self.getTypedRuleContext(QuietParser.UsingModulesContext,0)


        def fileSection(self):
            return self.getTypedRuleContext(QuietParser.FileSectionContext,0)


        def gateSection(self):
            return self.getTypedRuleContext(QuietParser.GateSectionContext,0)


        def bodySection(self):
            return self.getTypedRuleContext(QuietParser.BodySectionContext,0)


        def getRuleIndex(self):
            return QuietParser.RULE_prog

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterProg" ):
                listener.enterProg(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitProg" ):
                listener.exitProg(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitProg" ):
                return visitor.visitProg(self)
            else:
                return visitor.visitChildren(self)




    def prog(self):

        localctx = QuietParser.ProgContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_prog)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 131
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,0,self._ctx)
            if la_ == 1:
                self.state = 130
                self.usingModules()


            self.state = 134
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,1,self._ctx)
            if la_ == 1:
                self.state = 133
                self.fileSection()


            self.state = 137
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,2,self._ctx)
            if la_ == 1:
                self.state = 136
                self.gateSection()


            self.state = 140
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==3 or _la==74:
                self.state = 139
                self.bodySection()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class UsingModulesContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Using(self):
            return self.getToken(QuietParser.Using, 0)

        def Id(self, i:int=None):
            if i is None:
                return self.getTokens(QuietParser.Id)
            else:
                return self.getToken(QuietParser.Id, i)

        def EOL(self, i:int=None):
            if i is None:
                return self.getTokens(QuietParser.EOL)
            else:
                return self.getToken(QuietParser.EOL, i)

        def Comma(self, i:int=None):
            if i is None:
                return self.getTokens(QuietParser.Comma)
            else:
                return self.getToken(QuietParser.Comma, i)

        def getRuleIndex(self):
            return QuietParser.RULE_usingModules

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUsingModules" ):
                listener.enterUsingModules(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUsingModules" ):
                listener.exitUsingModules(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUsingModules" ):
                return visitor.visitUsingModules(self)
            else:
                return visitor.visitChildren(self)




    def usingModules(self):

        localctx = QuietParser.UsingModulesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_usingModules)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 145
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==74:
                self.state = 142
                self.match(QuietParser.EOL)
                self.state = 147
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 148
            self.match(QuietParser.Using)
            self.state = 149
            self.match(QuietParser.Id)
            self.state = 154
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==69:
                self.state = 150
                self.match(QuietParser.Comma)
                self.state = 151
                self.match(QuietParser.Id)
                self.state = 156
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 157
            self.match(QuietParser.EOL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FileSectionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def fileSecDecl(self):
            return self.getTypedRuleContext(QuietParser.FileSecDeclContext,0)


        def EOL(self, i:int=None):
            if i is None:
                return self.getTokens(QuietParser.EOL)
            else:
                return self.getToken(QuietParser.EOL, i)

        def fileSecContent(self):
            return self.getTypedRuleContext(QuietParser.FileSecContentContext,0)


        def getRuleIndex(self):
            return QuietParser.RULE_fileSection

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFileSection" ):
                listener.enterFileSection(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFileSection" ):
                listener.exitFileSection(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFileSection" ):
                return visitor.visitFileSection(self)
            else:
                return visitor.visitChildren(self)




    def fileSection(self):

        localctx = QuietParser.FileSectionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_fileSection)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 162
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==74:
                self.state = 159
                self.match(QuietParser.EOL)
                self.state = 164
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 165
            self.fileSecDecl()
            self.state = 167
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==4:
                self.state = 166
                self.fileSecContent()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FileSecDeclContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DotFile(self):
            return self.getToken(QuietParser.DotFile, 0)

        def Colon(self):
            return self.getToken(QuietParser.Colon, 0)

        def EOL(self):
            return self.getToken(QuietParser.EOL, 0)

        def getRuleIndex(self):
            return QuietParser.RULE_fileSecDecl

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFileSecDecl" ):
                listener.enterFileSecDecl(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFileSecDecl" ):
                listener.exitFileSecDecl(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFileSecDecl" ):
                return visitor.visitFileSecDecl(self)
            else:
                return visitor.visitChildren(self)




    def fileSecDecl(self):

        localctx = QuietParser.FileSecDeclContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_fileSecDecl)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 169
            self.match(QuietParser.DotFile)
            self.state = 170
            self.match(QuietParser.Colon)
            self.state = 171
            self.match(QuietParser.EOL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FileSecContentContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def includeStatement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(QuietParser.IncludeStatementContext)
            else:
                return self.getTypedRuleContext(QuietParser.IncludeStatementContext,i)


        def getRuleIndex(self):
            return QuietParser.RULE_fileSecContent

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFileSecContent" ):
                listener.enterFileSecContent(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFileSecContent" ):
                listener.exitFileSecContent(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFileSecContent" ):
                return visitor.visitFileSecContent(self)
            else:
                return visitor.visitChildren(self)




    def fileSecContent(self):

        localctx = QuietParser.FileSecContentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_fileSecContent)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 174 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 173
                self.includeStatement()
                self.state = 176 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==4):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IncludeStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Include(self):
            return self.getToken(QuietParser.Include, 0)

        def filename(self):
            return self.getTypedRuleContext(QuietParser.FilenameContext,0)


        def EOL(self):
            return self.getToken(QuietParser.EOL, 0)

        def getRuleIndex(self):
            return QuietParser.RULE_includeStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIncludeStatement" ):
                listener.enterIncludeStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIncludeStatement" ):
                listener.exitIncludeStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIncludeStatement" ):
                return visitor.visitIncludeStatement(self)
            else:
                return visitor.visitChildren(self)




    def includeStatement(self):

        localctx = QuietParser.IncludeStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_includeStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 178
            self.match(QuietParser.Include)
            self.state = 179
            self.filename()
            self.state = 180
            self.match(QuietParser.EOL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FilenameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Id(self, i:int=None):
            if i is None:
                return self.getTokens(QuietParser.Id)
            else:
                return self.getToken(QuietParser.Id, i)

        def Dot(self, i:int=None):
            if i is None:
                return self.getTokens(QuietParser.Dot)
            else:
                return self.getToken(QuietParser.Dot, i)

        def getRuleIndex(self):
            return QuietParser.RULE_filename

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFilename" ):
                listener.enterFilename(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFilename" ):
                listener.exitFilename(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFilename" ):
                return visitor.visitFilename(self)
            else:
                return visitor.visitChildren(self)




    def filename(self):

        localctx = QuietParser.FilenameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_filename)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 182
            self.match(QuietParser.Id)
            self.state = 187
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==70:
                self.state = 183
                self.match(QuietParser.Dot)
                self.state = 184
                self.match(QuietParser.Id)
                self.state = 189
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GateSectionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def gateSecDecl(self):
            return self.getTypedRuleContext(QuietParser.GateSecDeclContext,0)


        def gateSecContent(self):
            return self.getTypedRuleContext(QuietParser.GateSecContentContext,0)


        def EOL(self, i:int=None):
            if i is None:
                return self.getTokens(QuietParser.EOL)
            else:
                return self.getToken(QuietParser.EOL, i)

        def getRuleIndex(self):
            return QuietParser.RULE_gateSection

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGateSection" ):
                listener.enterGateSection(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGateSection" ):
                listener.exitGateSection(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGateSection" ):
                return visitor.visitGateSection(self)
            else:
                return visitor.visitChildren(self)




    def gateSection(self):

        localctx = QuietParser.GateSectionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_gateSection)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 193
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==74:
                self.state = 190
                self.match(QuietParser.EOL)
                self.state = 195
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 196
            self.gateSecDecl()
            self.state = 197
            self.gateSecContent()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GateSecDeclContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DotGate(self):
            return self.getToken(QuietParser.DotGate, 0)

        def Colon(self):
            return self.getToken(QuietParser.Colon, 0)

        def EOL(self):
            return self.getToken(QuietParser.EOL, 0)

        def getRuleIndex(self):
            return QuietParser.RULE_gateSecDecl

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGateSecDecl" ):
                listener.enterGateSecDecl(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGateSecDecl" ):
                listener.exitGateSecDecl(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGateSecDecl" ):
                return visitor.visitGateSecDecl(self)
            else:
                return visitor.visitChildren(self)




    def gateSecDecl(self):

        localctx = QuietParser.GateSecDeclContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_gateSecDecl)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 199
            self.match(QuietParser.DotGate)
            self.state = 200
            self.match(QuietParser.Colon)
            self.state = 201
            self.match(QuietParser.EOL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GateSecContentContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def gateDefinition(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(QuietParser.GateDefinitionContext)
            else:
                return self.getTypedRuleContext(QuietParser.GateDefinitionContext,i)


        def getRuleIndex(self):
            return QuietParser.RULE_gateSecContent

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGateSecContent" ):
                listener.enterGateSecContent(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGateSecContent" ):
                listener.exitGateSecContent(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGateSecContent" ):
                return visitor.visitGateSecContent(self)
            else:
                return visitor.visitChildren(self)




    def gateSecContent(self):

        localctx = QuietParser.GateSecContentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_gateSecContent)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 206
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==7:
                self.state = 203
                self.gateDefinition()
                self.state = 208
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GateDefinitionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Define(self):
            return self.getToken(QuietParser.Define, 0)

        def Id(self):
            return self.getToken(QuietParser.Id, 0)

        def numberArray(self):
            return self.getTypedRuleContext(QuietParser.NumberArrayContext,0)


        def EOL(self):
            return self.getToken(QuietParser.EOL, 0)

        def getRuleIndex(self):
            return QuietParser.RULE_gateDefinition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGateDefinition" ):
                listener.enterGateDefinition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGateDefinition" ):
                listener.exitGateDefinition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGateDefinition" ):
                return visitor.visitGateDefinition(self)
            else:
                return visitor.visitChildren(self)




    def gateDefinition(self):

        localctx = QuietParser.GateDefinitionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_gateDefinition)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 209
            self.match(QuietParser.Define)
            self.state = 210
            self.match(QuietParser.Id)
            self.state = 211
            self.numberArray()
            self.state = 212
            self.match(QuietParser.EOL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NumberArrayContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def BracketLeft(self):
            return self.getToken(QuietParser.BracketLeft, 0)

        def numberList(self):
            return self.getTypedRuleContext(QuietParser.NumberListContext,0)


        def BracketRight(self):
            return self.getToken(QuietParser.BracketRight, 0)

        def getRuleIndex(self):
            return QuietParser.RULE_numberArray

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNumberArray" ):
                listener.enterNumberArray(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNumberArray" ):
                listener.exitNumberArray(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNumberArray" ):
                return visitor.visitNumberArray(self)
            else:
                return visitor.visitChildren(self)




    def numberArray(self):

        localctx = QuietParser.NumberArrayContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_numberArray)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 214
            self.match(QuietParser.BracketLeft)
            self.state = 215
            self.numberList()
            self.state = 216
            self.match(QuietParser.BracketRight)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NumberListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def number(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(QuietParser.NumberContext)
            else:
                return self.getTypedRuleContext(QuietParser.NumberContext,i)


        def Comma(self, i:int=None):
            if i is None:
                return self.getTokens(QuietParser.Comma)
            else:
                return self.getToken(QuietParser.Comma, i)

        def EOL(self, i:int=None):
            if i is None:
                return self.getTokens(QuietParser.EOL)
            else:
                return self.getToken(QuietParser.EOL, i)

        def getRuleIndex(self):
            return QuietParser.RULE_numberList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNumberList" ):
                listener.enterNumberList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNumberList" ):
                listener.exitNumberList(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNumberList" ):
                return visitor.visitNumberList(self)
            else:
                return visitor.visitChildren(self)




    def numberList(self):

        localctx = QuietParser.NumberListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_numberList)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 218
            self.number()
            self.state = 226
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==69:
                self.state = 219
                self.match(QuietParser.Comma)
                self.state = 221
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==74:
                    self.state = 220
                    self.match(QuietParser.EOL)


                self.state = 223
                self.number()
                self.state = 228
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BodySectionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def bodySecDecl(self):
            return self.getTypedRuleContext(QuietParser.BodySecDeclContext,0)


        def bodySecContent(self):
            return self.getTypedRuleContext(QuietParser.BodySecContentContext,0)


        def EOL(self, i:int=None):
            if i is None:
                return self.getTokens(QuietParser.EOL)
            else:
                return self.getToken(QuietParser.EOL, i)

        def getRuleIndex(self):
            return QuietParser.RULE_bodySection

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBodySection" ):
                listener.enterBodySection(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBodySection" ):
                listener.exitBodySection(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBodySection" ):
                return visitor.visitBodySection(self)
            else:
                return visitor.visitChildren(self)




    def bodySection(self):

        localctx = QuietParser.BodySectionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_bodySection)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 232
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==74:
                self.state = 229
                self.match(QuietParser.EOL)
                self.state = 234
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 235
            self.bodySecDecl()
            self.state = 236
            self.bodySecContent()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BodySecDeclContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DotBody(self):
            return self.getToken(QuietParser.DotBody, 0)

        def Colon(self):
            return self.getToken(QuietParser.Colon, 0)

        def EOL(self):
            return self.getToken(QuietParser.EOL, 0)

        def getRuleIndex(self):
            return QuietParser.RULE_bodySecDecl

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBodySecDecl" ):
                listener.enterBodySecDecl(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBodySecDecl" ):
                listener.exitBodySecDecl(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBodySecDecl" ):
                return visitor.visitBodySecDecl(self)
            else:
                return visitor.visitChildren(self)




    def bodySecDecl(self):

        localctx = QuietParser.BodySecDeclContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_bodySecDecl)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 238
            self.match(QuietParser.DotBody)
            self.state = 239
            self.match(QuietParser.Colon)
            self.state = 240
            self.match(QuietParser.EOL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BodySecContentContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def function(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(QuietParser.FunctionContext)
            else:
                return self.getTypedRuleContext(QuietParser.FunctionContext,i)


        def getRuleIndex(self):
            return QuietParser.RULE_bodySecContent

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBodySecContent" ):
                listener.enterBodySecContent(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBodySecContent" ):
                listener.exitBodySecContent(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBodySecContent" ):
                return visitor.visitBodySecContent(self)
            else:
                return visitor.visitChildren(self)




    def bodySecContent(self):

        localctx = QuietParser.BodySecContentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_bodySecContent)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 245
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==27:
                self.state = 242
                self.function()
                self.state = 247
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FunctionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Func(self):
            return self.getToken(QuietParser.Func, 0)

        def funcHeader(self):
            return self.getTypedRuleContext(QuietParser.FuncHeaderContext,0)


        def Colon(self):
            return self.getToken(QuietParser.Colon, 0)

        def EOL(self, i:int=None):
            if i is None:
                return self.getTokens(QuietParser.EOL)
            else:
                return self.getToken(QuietParser.EOL, i)

        def funcBody(self):
            return self.getTypedRuleContext(QuietParser.FuncBodyContext,0)


        def End(self):
            return self.getToken(QuietParser.End, 0)

        def EOF(self):
            return self.getToken(QuietParser.EOF, 0)

        def getRuleIndex(self):
            return QuietParser.RULE_function

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFunction" ):
                listener.enterFunction(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFunction" ):
                listener.exitFunction(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFunction" ):
                return visitor.visitFunction(self)
            else:
                return visitor.visitChildren(self)




    def function(self):

        localctx = QuietParser.FunctionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_function)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 248
            self.match(QuietParser.Func)
            self.state = 249
            self.funcHeader()
            self.state = 250
            self.match(QuietParser.Colon)
            self.state = 251
            self.match(QuietParser.EOL)
            self.state = 252
            self.funcBody()
            self.state = 253
            self.match(QuietParser.End)
            self.state = 255
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,16,self._ctx)
            if la_ == 1:
                self.state = 254
                _la = self._input.LA(1)
                if not(_la==-1 or _la==74):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FuncHeaderContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Id(self):
            return self.getToken(QuietParser.Id, 0)

        def ParenLeft(self, i:int=None):
            if i is None:
                return self.getTokens(QuietParser.ParenLeft)
            else:
                return self.getToken(QuietParser.ParenLeft, i)

        def ParenRight(self, i:int=None):
            if i is None:
                return self.getTokens(QuietParser.ParenRight)
            else:
                return self.getToken(QuietParser.ParenRight, i)

        def inputArgs(self):
            return self.getTypedRuleContext(QuietParser.InputArgsContext,0)


        def RightArrow(self):
            return self.getToken(QuietParser.RightArrow, 0)

        def outputArgs(self):
            return self.getTypedRuleContext(QuietParser.OutputArgsContext,0)


        def getRuleIndex(self):
            return QuietParser.RULE_funcHeader

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFuncHeader" ):
                listener.enterFuncHeader(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFuncHeader" ):
                listener.exitFuncHeader(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFuncHeader" ):
                return visitor.visitFuncHeader(self)
            else:
                return visitor.visitChildren(self)




    def funcHeader(self):

        localctx = QuietParser.FuncHeaderContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_funcHeader)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 257
            self.match(QuietParser.Id)
            self.state = 258
            self.match(QuietParser.ParenLeft)
            self.state = 260
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & 6442451008) != 0):
                self.state = 259
                self.inputArgs()


            self.state = 262
            self.match(QuietParser.ParenRight)
            self.state = 268
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==73:
                self.state = 263
                self.match(QuietParser.RightArrow)
                self.state = 264
                self.match(QuietParser.ParenLeft)
                self.state = 265
                self.outputArgs()
                self.state = 266
                self.match(QuietParser.ParenRight)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class InputArgsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def formalParam(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(QuietParser.FormalParamContext)
            else:
                return self.getTypedRuleContext(QuietParser.FormalParamContext,i)


        def Comma(self, i:int=None):
            if i is None:
                return self.getTokens(QuietParser.Comma)
            else:
                return self.getToken(QuietParser.Comma, i)

        def getRuleIndex(self):
            return QuietParser.RULE_inputArgs

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInputArgs" ):
                listener.enterInputArgs(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInputArgs" ):
                listener.exitInputArgs(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitInputArgs" ):
                return visitor.visitInputArgs(self)
            else:
                return visitor.visitChildren(self)




    def inputArgs(self):

        localctx = QuietParser.InputArgsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 36, self.RULE_inputArgs)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 270
            self.formalParam()
            self.state = 275
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==69:
                self.state = 271
                self.match(QuietParser.Comma)
                self.state = 272
                self.formalParam()
                self.state = 277
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OutputArgsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def formalParam(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(QuietParser.FormalParamContext)
            else:
                return self.getTypedRuleContext(QuietParser.FormalParamContext,i)


        def Comma(self, i:int=None):
            if i is None:
                return self.getTokens(QuietParser.Comma)
            else:
                return self.getToken(QuietParser.Comma, i)

        def getRuleIndex(self):
            return QuietParser.RULE_outputArgs

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOutputArgs" ):
                listener.enterOutputArgs(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOutputArgs" ):
                listener.exitOutputArgs(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOutputArgs" ):
                return visitor.visitOutputArgs(self)
            else:
                return visitor.visitChildren(self)




    def outputArgs(self):

        localctx = QuietParser.OutputArgsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 38, self.RULE_outputArgs)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 278
            self.formalParam()
            self.state = 283
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==69:
                self.state = 279
                self.match(QuietParser.Comma)
                self.state = 280
                self.formalParam()
                self.state = 285
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FormalParamContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def paramType(self):
            return self.getTypedRuleContext(QuietParser.ParamTypeContext,0)


        def Id(self):
            return self.getToken(QuietParser.Id, 0)

        def getRuleIndex(self):
            return QuietParser.RULE_formalParam

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFormalParam" ):
                listener.enterFormalParam(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFormalParam" ):
                listener.exitFormalParam(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFormalParam" ):
                return visitor.visitFormalParam(self)
            else:
                return visitor.visitChildren(self)




    def formalParam(self):

        localctx = QuietParser.FormalParamContext(self, self._ctx, self.state)
        self.enterRule(localctx, 40, self.RULE_formalParam)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 286
            self.paramType()
            self.state = 287
            self.match(QuietParser.Id)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FuncBodyContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def action(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(QuietParser.ActionContext)
            else:
                return self.getTypedRuleContext(QuietParser.ActionContext,i)


        def getRuleIndex(self):
            return QuietParser.RULE_funcBody

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFuncBody" ):
                listener.enterFuncBody(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFuncBody" ):
                listener.exitFuncBody(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFuncBody" ):
                return visitor.visitFuncBody(self)
            else:
                return visitor.visitChildren(self)




    def funcBody(self):

        localctx = QuietParser.FuncBodyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 42, self.RULE_funcBody)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 292
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & -671088832) != 0) or _la==74 or _la==77:
                self.state = 289
                self.action()
                self.state = 294
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ActionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def instruction(self):
            return self.getTypedRuleContext(QuietParser.InstructionContext,0)


        def label(self):
            return self.getTypedRuleContext(QuietParser.LabelContext,0)


        def Colon(self):
            return self.getToken(QuietParser.Colon, 0)

        def EOL(self):
            return self.getToken(QuietParser.EOL, 0)

        def getRuleIndex(self):
            return QuietParser.RULE_action

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAction" ):
                listener.enterAction(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAction" ):
                listener.exitAction(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAction" ):
                return visitor.visitAction(self)
            else:
                return visitor.visitChildren(self)




    def action(self):

        localctx = QuietParser.ActionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 44, self.RULE_action)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 300
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,23,self._ctx)
            if la_ == 1:
                self.state = 295
                self.label()
                self.state = 296
                self.match(QuietParser.Colon)
                self.state = 298
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,22,self._ctx)
                if la_ == 1:
                    self.state = 297
                    self.match(QuietParser.EOL)




            self.state = 302
            self.instruction()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LabelContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Id(self):
            return self.getToken(QuietParser.Id, 0)

        def getRuleIndex(self):
            return QuietParser.RULE_label

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLabel" ):
                listener.enterLabel(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLabel" ):
                listener.exitLabel(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLabel" ):
                return visitor.visitLabel(self)
            else:
                return visitor.visitChildren(self)




    def label(self):

        localctx = QuietParser.LabelContext(self, self._ctx, self.state)
        self.enterRule(localctx, 46, self.RULE_label)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 304
            self.match(QuietParser.Id)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class InstructionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def integerModuleInsn(self):
            return self.getTypedRuleContext(QuietParser.IntegerModuleInsnContext,0)


        def EOL(self):
            return self.getToken(QuietParser.EOL, 0)

        def floatModuleInsn(self):
            return self.getTypedRuleContext(QuietParser.FloatModuleInsnContext,0)


        def quantumOpInsn(self):
            return self.getTypedRuleContext(QuietParser.QuantumOpInsnContext,0)


        def funcCall(self):
            return self.getTypedRuleContext(QuietParser.FuncCallContext,0)


        def returnStmt(self):
            return self.getTypedRuleContext(QuietParser.ReturnStmtContext,0)


        def variableDecl(self):
            return self.getTypedRuleContext(QuietParser.VariableDeclContext,0)


        def getRuleIndex(self):
            return QuietParser.RULE_instruction

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInstruction" ):
                listener.enterInstruction(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInstruction" ):
                listener.exitInstruction(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitInstruction" ):
                return visitor.visitInstruction(self)
            else:
                return visitor.visitChildren(self)




    def instruction(self):

        localctx = QuietParser.InstructionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 48, self.RULE_instruction)
        try:
            self.state = 325
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,24,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 306
                self.integerModuleInsn()
                self.state = 307
                self.match(QuietParser.EOL)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 309
                self.floatModuleInsn()
                self.state = 310
                self.match(QuietParser.EOL)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 312
                self.quantumOpInsn()
                self.state = 313
                self.match(QuietParser.EOL)
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 315
                self.funcCall()
                self.state = 316
                self.match(QuietParser.EOL)
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 318
                self.returnStmt()
                self.state = 319
                self.match(QuietParser.EOL)
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 321
                self.variableDecl()
                self.state = 322
                self.match(QuietParser.EOL)
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 324
                self.match(QuietParser.EOL)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ReturnStmtContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Return(self):
            return self.getToken(QuietParser.Return, 0)

        def variable(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(QuietParser.VariableContext)
            else:
                return self.getTypedRuleContext(QuietParser.VariableContext,i)


        def Comma(self, i:int=None):
            if i is None:
                return self.getTokens(QuietParser.Comma)
            else:
                return self.getToken(QuietParser.Comma, i)

        def getRuleIndex(self):
            return QuietParser.RULE_returnStmt

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterReturnStmt" ):
                listener.enterReturnStmt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitReturnStmt" ):
                listener.exitReturnStmt(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitReturnStmt" ):
                return visitor.visitReturnStmt(self)
            else:
                return visitor.visitChildren(self)




    def returnStmt(self):

        localctx = QuietParser.ReturnStmtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 50, self.RULE_returnStmt)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 327
            self.match(QuietParser.Return)
            self.state = 336
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==77:
                self.state = 328
                self.variable()
                self.state = 333
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==69:
                    self.state = 329
                    self.match(QuietParser.Comma)
                    self.state = 330
                    self.variable()
                    self.state = 335
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)



        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ControlQubitContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Less(self):
            return self.getToken(QuietParser.Less, 0)

        def variable(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(QuietParser.VariableContext)
            else:
                return self.getTypedRuleContext(QuietParser.VariableContext,i)


        def Greater(self):
            return self.getToken(QuietParser.Greater, 0)

        def Comma(self, i:int=None):
            if i is None:
                return self.getTokens(QuietParser.Comma)
            else:
                return self.getToken(QuietParser.Comma, i)

        def getRuleIndex(self):
            return QuietParser.RULE_controlQubit

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterControlQubit" ):
                listener.enterControlQubit(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitControlQubit" ):
                listener.exitControlQubit(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitControlQubit" ):
                return visitor.visitControlQubit(self)
            else:
                return visitor.visitChildren(self)




    def controlQubit(self):

        localctx = QuietParser.ControlQubitContext(self, self._ctx, self.state)
        self.enterRule(localctx, 52, self.RULE_controlQubit)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 338
            self.match(QuietParser.Less)
            self.state = 339
            self.variable()
            self.state = 344
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==69:
                self.state = 340
                self.match(QuietParser.Comma)
                self.state = 341
                self.variable()
                self.state = 346
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 347
            self.match(QuietParser.Greater)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ControlModifierContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Control(self):
            return self.getToken(QuietParser.Control, 0)

        def controlQubit(self):
            return self.getTypedRuleContext(QuietParser.ControlQubitContext,0)


        def getRuleIndex(self):
            return QuietParser.RULE_controlModifier

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterControlModifier" ):
                listener.enterControlModifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitControlModifier" ):
                listener.exitControlModifier(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitControlModifier" ):
                return visitor.visitControlModifier(self)
            else:
                return visitor.visitChildren(self)




    def controlModifier(self):

        localctx = QuietParser.ControlModifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 54, self.RULE_controlModifier)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 349
            self.match(QuietParser.Control)
            self.state = 350
            self.controlQubit()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class QuantumOpInsnContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def quantumGate(self):
            return self.getTypedRuleContext(QuietParser.QuantumGateContext,0)


        def variable(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(QuietParser.VariableContext)
            else:
                return self.getTypedRuleContext(QuietParser.VariableContext,i)


        def controlModifier(self):
            return self.getTypedRuleContext(QuietParser.ControlModifierContext,0)


        def ParenLeft(self):
            return self.getToken(QuietParser.ParenLeft, 0)

        def actualParamList(self):
            return self.getTypedRuleContext(QuietParser.ActualParamListContext,0)


        def ParenRight(self):
            return self.getToken(QuietParser.ParenRight, 0)

        def Comma(self, i:int=None):
            if i is None:
                return self.getTokens(QuietParser.Comma)
            else:
                return self.getToken(QuietParser.Comma, i)

        def getRuleIndex(self):
            return QuietParser.RULE_quantumOpInsn

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterQuantumOpInsn" ):
                listener.enterQuantumOpInsn(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitQuantumOpInsn" ):
                listener.exitQuantumOpInsn(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitQuantumOpInsn" ):
                return visitor.visitQuantumOpInsn(self)
            else:
                return visitor.visitChildren(self)




    def quantumOpInsn(self):

        localctx = QuietParser.QuantumOpInsnContext(self, self._ctx, self.state)
        self.enterRule(localctx, 56, self.RULE_quantumOpInsn)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 353
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==26:
                self.state = 352
                self.controlModifier()


            self.state = 355
            self.quantumGate()
            self.state = 360
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==66:
                self.state = 356
                self.match(QuietParser.ParenLeft)
                self.state = 357
                self.actualParamList()
                self.state = 358
                self.match(QuietParser.ParenRight)


            self.state = 362
            self.variable()
            self.state = 367
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==69:
                self.state = 363
                self.match(QuietParser.Comma)
                self.state = 364
                self.variable()
                self.state = 369
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class QuantumGateContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def gateNoParam(self):
            return self.getTypedRuleContext(QuietParser.GateNoParamContext,0)


        def gateWithParams(self):
            return self.getTypedRuleContext(QuietParser.GateWithParamsContext,0)


        def getRuleIndex(self):
            return QuietParser.RULE_quantumGate

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterQuantumGate" ):
                listener.enterQuantumGate(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitQuantumGate" ):
                listener.exitQuantumGate(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitQuantumGate" ):
                return visitor.visitQuantumGate(self)
            else:
                return visitor.visitChildren(self)




    def quantumGate(self):

        localctx = QuietParser.QuantumGateContext(self, self._ctx, self.state)
        self.enterRule(localctx, 58, self.RULE_quantumGate)
        try:
            self.state = 372
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 77]:
                self.enterOuterAlt(localctx, 1)
                self.state = 370
                self.gateNoParam()
                pass
            elif token in [8, 20, 21, 22, 23, 24, 25]:
                self.enterOuterAlt(localctx, 2)
                self.state = 371
                self.gateWithParams()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GateNoParamContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Hadamard(self):
            return self.getToken(QuietParser.Hadamard, 0)

        def PauliX(self):
            return self.getToken(QuietParser.PauliX, 0)

        def PauliY(self):
            return self.getToken(QuietParser.PauliY, 0)

        def PauliZ(self):
            return self.getToken(QuietParser.PauliZ, 0)

        def SGate(self):
            return self.getToken(QuietParser.SGate, 0)

        def Sdag(self):
            return self.getToken(QuietParser.Sdag, 0)

        def TGate(self):
            return self.getToken(QuietParser.TGate, 0)

        def Tdg(self):
            return self.getToken(QuietParser.Tdg, 0)

        def Cnot(self):
            return self.getToken(QuietParser.Cnot, 0)

        def Cz(self):
            return self.getToken(QuietParser.Cz, 0)

        def Swap(self):
            return self.getToken(QuietParser.Swap, 0)

        def Id(self):
            return self.getToken(QuietParser.Id, 0)

        def getRuleIndex(self):
            return QuietParser.RULE_gateNoParam

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGateNoParam" ):
                listener.enterGateNoParam(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGateNoParam" ):
                listener.exitGateNoParam(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGateNoParam" ):
                return visitor.visitGateNoParam(self)
            else:
                return visitor.visitChildren(self)




    def gateNoParam(self):

        localctx = QuietParser.GateNoParamContext(self, self._ctx, self.state)
        self.enterRule(localctx, 60, self.RULE_gateNoParam)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 374
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 1048064) != 0) or _la==77):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ActualParamListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def actualParam(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(QuietParser.ActualParamContext)
            else:
                return self.getTypedRuleContext(QuietParser.ActualParamContext,i)


        def Comma(self, i:int=None):
            if i is None:
                return self.getTokens(QuietParser.Comma)
            else:
                return self.getToken(QuietParser.Comma, i)

        def getRuleIndex(self):
            return QuietParser.RULE_actualParamList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterActualParamList" ):
                listener.enterActualParamList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitActualParamList" ):
                listener.exitActualParamList(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitActualParamList" ):
                return visitor.visitActualParamList(self)
            else:
                return visitor.visitChildren(self)




    def actualParamList(self):

        localctx = QuietParser.ActualParamListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 62, self.RULE_actualParamList)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 376
            self.actualParam()
            self.state = 381
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==69:
                self.state = 377
                self.match(QuietParser.Comma)
                self.state = 378
                self.actualParam()
                self.state = 383
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ActualParamContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def number(self):
            return self.getTypedRuleContext(QuietParser.NumberContext,0)


        def variable(self):
            return self.getTypedRuleContext(QuietParser.VariableContext,0)


        def getRuleIndex(self):
            return QuietParser.RULE_actualParam

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterActualParam" ):
                listener.enterActualParam(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitActualParam" ):
                listener.exitActualParam(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitActualParam" ):
                return visitor.visitActualParam(self)
            else:
                return visitor.visitChildren(self)




    def actualParam(self):

        localctx = QuietParser.ActualParamContext(self, self._ctx, self.state)
        self.enterRule(localctx, 64, self.RULE_actualParam)
        try:
            self.state = 386
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [66, 75, 76]:
                self.enterOuterAlt(localctx, 1)
                self.state = 384
                self.number()
                pass
            elif token in [77]:
                self.enterOuterAlt(localctx, 2)
                self.state = 385
                self.variable()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GateWithParamsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def U4(self):
            return self.getToken(QuietParser.U4, 0)

        def Rx(self):
            return self.getToken(QuietParser.Rx, 0)

        def Ry(self):
            return self.getToken(QuietParser.Ry, 0)

        def Rz(self):
            return self.getToken(QuietParser.Rz, 0)

        def Rxy(self):
            return self.getToken(QuietParser.Rxy, 0)

        def CPhase(self):
            return self.getToken(QuietParser.CPhase, 0)

        def CRz(self):
            return self.getToken(QuietParser.CRz, 0)

        def getRuleIndex(self):
            return QuietParser.RULE_gateWithParams

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGateWithParams" ):
                listener.enterGateWithParams(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGateWithParams" ):
                listener.exitGateWithParams(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGateWithParams" ):
                return visitor.visitGateWithParams(self)
            else:
                return visitor.visitChildren(self)




    def gateWithParams(self):

        localctx = QuietParser.GateWithParamsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 66, self.RULE_gateWithParams)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 388
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 66060544) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ComplexLiteralContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ParenLeft(self):
            return self.getToken(QuietParser.ParenLeft, 0)

        def realPart(self):
            return self.getTypedRuleContext(QuietParser.RealPartContext,0)


        def Comma(self):
            return self.getToken(QuietParser.Comma, 0)

        def imaginaryPart(self):
            return self.getTypedRuleContext(QuietParser.ImaginaryPartContext,0)


        def ParenRight(self):
            return self.getToken(QuietParser.ParenRight, 0)

        def getRuleIndex(self):
            return QuietParser.RULE_complexLiteral

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterComplexLiteral" ):
                listener.enterComplexLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitComplexLiteral" ):
                listener.exitComplexLiteral(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitComplexLiteral" ):
                return visitor.visitComplexLiteral(self)
            else:
                return visitor.visitChildren(self)




    def complexLiteral(self):

        localctx = QuietParser.ComplexLiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 68, self.RULE_complexLiteral)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 390
            self.match(QuietParser.ParenLeft)
            self.state = 391
            self.realPart()
            self.state = 392
            self.match(QuietParser.Comma)
            self.state = 393
            self.imaginaryPart()
            self.state = 394
            self.match(QuietParser.ParenRight)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RealPartContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DoubleLiteral(self):
            return self.getToken(QuietParser.DoubleLiteral, 0)

        def IntLiteral(self):
            return self.getToken(QuietParser.IntLiteral, 0)

        def getRuleIndex(self):
            return QuietParser.RULE_realPart

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRealPart" ):
                listener.enterRealPart(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRealPart" ):
                listener.exitRealPart(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRealPart" ):
                return visitor.visitRealPart(self)
            else:
                return visitor.visitChildren(self)




    def realPart(self):

        localctx = QuietParser.RealPartContext(self, self._ctx, self.state)
        self.enterRule(localctx, 70, self.RULE_realPart)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 396
            _la = self._input.LA(1)
            if not(_la==75 or _la==76):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ImaginaryPartContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DoubleLiteral(self):
            return self.getToken(QuietParser.DoubleLiteral, 0)

        def IntLiteral(self):
            return self.getToken(QuietParser.IntLiteral, 0)

        def getRuleIndex(self):
            return QuietParser.RULE_imaginaryPart

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterImaginaryPart" ):
                listener.enterImaginaryPart(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitImaginaryPart" ):
                listener.exitImaginaryPart(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitImaginaryPart" ):
                return visitor.visitImaginaryPart(self)
            else:
                return visitor.visitChildren(self)




    def imaginaryPart(self):

        localctx = QuietParser.ImaginaryPartContext(self, self._ctx, self.state)
        self.enterRule(localctx, 72, self.RULE_imaginaryPart)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 398
            _la = self._input.LA(1)
            if not(_la==75 or _la==76):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NumberContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IntLiteral(self):
            return self.getToken(QuietParser.IntLiteral, 0)

        def DoubleLiteral(self):
            return self.getToken(QuietParser.DoubleLiteral, 0)

        def complexLiteral(self):
            return self.getTypedRuleContext(QuietParser.ComplexLiteralContext,0)


        def getRuleIndex(self):
            return QuietParser.RULE_number

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNumber" ):
                listener.enterNumber(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNumber" ):
                listener.exitNumber(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNumber" ):
                return visitor.visitNumber(self)
            else:
                return visitor.visitChildren(self)




    def number(self):

        localctx = QuietParser.NumberContext(self, self._ctx, self.state)
        self.enterRule(localctx, 74, self.RULE_number)
        try:
            self.state = 403
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [75]:
                self.enterOuterAlt(localctx, 1)
                self.state = 400
                self.match(QuietParser.IntLiteral)
                pass
            elif token in [76]:
                self.enterOuterAlt(localctx, 2)
                self.state = 401
                self.match(QuietParser.DoubleLiteral)
                pass
            elif token in [66]:
                self.enterOuterAlt(localctx, 3)
                self.state = 402
                self.complexLiteral()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ParamTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def typeAtomic(self):
            return self.getTypedRuleContext(QuietParser.TypeAtomicContext,0)


        def typeArrayNoLength(self):
            return self.getTypedRuleContext(QuietParser.TypeArrayNoLengthContext,0)


        def typeArrayWithLength(self):
            return self.getTypedRuleContext(QuietParser.TypeArrayWithLengthContext,0)


        def getRuleIndex(self):
            return QuietParser.RULE_paramType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterParamType" ):
                listener.enterParamType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitParamType" ):
                listener.exitParamType(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitParamType" ):
                return visitor.visitParamType(self)
            else:
                return visitor.visitChildren(self)




    def paramType(self):

        localctx = QuietParser.ParamTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 76, self.RULE_paramType)
        try:
            self.state = 408
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,35,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 405
                self.typeAtomic()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 406
                self.typeArrayNoLength()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 407
                self.typeArrayWithLength()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TypeAtomicContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Qubit(self):
            return self.getToken(QuietParser.Qubit, 0)

        def Int(self):
            return self.getToken(QuietParser.Int, 0)

        def Double(self):
            return self.getToken(QuietParser.Double, 0)

        def getRuleIndex(self):
            return QuietParser.RULE_typeAtomic

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTypeAtomic" ):
                listener.enterTypeAtomic(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTypeAtomic" ):
                listener.exitTypeAtomic(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTypeAtomic" ):
                return visitor.visitTypeAtomic(self)
            else:
                return visitor.visitChildren(self)




    def typeAtomic(self):

        localctx = QuietParser.TypeAtomicContext(self, self._ctx, self.state)
        self.enterRule(localctx, 78, self.RULE_typeAtomic)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 410
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 6442451008) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TypeArrayNoLengthContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def typeAtomic(self):
            return self.getTypedRuleContext(QuietParser.TypeAtomicContext,0)


        def BracketLeft(self):
            return self.getToken(QuietParser.BracketLeft, 0)

        def BracketRight(self):
            return self.getToken(QuietParser.BracketRight, 0)

        def getRuleIndex(self):
            return QuietParser.RULE_typeArrayNoLength

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTypeArrayNoLength" ):
                listener.enterTypeArrayNoLength(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTypeArrayNoLength" ):
                listener.exitTypeArrayNoLength(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTypeArrayNoLength" ):
                return visitor.visitTypeArrayNoLength(self)
            else:
                return visitor.visitChildren(self)




    def typeArrayNoLength(self):

        localctx = QuietParser.TypeArrayNoLengthContext(self, self._ctx, self.state)
        self.enterRule(localctx, 80, self.RULE_typeArrayNoLength)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 412
            self.typeAtomic()
            self.state = 413
            self.match(QuietParser.BracketLeft)
            self.state = 414
            self.match(QuietParser.BracketRight)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TypeArrayWithLengthContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def typeAtomic(self):
            return self.getTypedRuleContext(QuietParser.TypeAtomicContext,0)


        def BracketLeft(self, i:int=None):
            if i is None:
                return self.getTokens(QuietParser.BracketLeft)
            else:
                return self.getToken(QuietParser.BracketLeft, i)

        def BracketRight(self, i:int=None):
            if i is None:
                return self.getTokens(QuietParser.BracketRight)
            else:
                return self.getToken(QuietParser.BracketRight, i)

        def IntLiteral(self, i:int=None):
            if i is None:
                return self.getTokens(QuietParser.IntLiteral)
            else:
                return self.getToken(QuietParser.IntLiteral, i)

        def Id(self, i:int=None):
            if i is None:
                return self.getTokens(QuietParser.Id)
            else:
                return self.getToken(QuietParser.Id, i)

        def getRuleIndex(self):
            return QuietParser.RULE_typeArrayWithLength

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTypeArrayWithLength" ):
                listener.enterTypeArrayWithLength(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTypeArrayWithLength" ):
                listener.exitTypeArrayWithLength(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTypeArrayWithLength" ):
                return visitor.visitTypeArrayWithLength(self)
            else:
                return visitor.visitChildren(self)




    def typeArrayWithLength(self):

        localctx = QuietParser.TypeArrayWithLengthContext(self, self._ctx, self.state)
        self.enterRule(localctx, 82, self.RULE_typeArrayWithLength)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 416
            self.typeAtomic()
            self.state = 420 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 417
                self.match(QuietParser.BracketLeft)
                self.state = 418
                _la = self._input.LA(1)
                if not(_la==75 or _la==77):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 419
                self.match(QuietParser.BracketRight)
                self.state = 422 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==64):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VariableDeclContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def paramType(self):
            return self.getTypedRuleContext(QuietParser.ParamTypeContext,0)


        def Id(self, i:int=None):
            if i is None:
                return self.getTokens(QuietParser.Id)
            else:
                return self.getToken(QuietParser.Id, i)

        def Comma(self, i:int=None):
            if i is None:
                return self.getTokens(QuietParser.Comma)
            else:
                return self.getToken(QuietParser.Comma, i)

        def getRuleIndex(self):
            return QuietParser.RULE_variableDecl

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVariableDecl" ):
                listener.enterVariableDecl(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVariableDecl" ):
                listener.exitVariableDecl(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVariableDecl" ):
                return visitor.visitVariableDecl(self)
            else:
                return visitor.visitChildren(self)




    def variableDecl(self):

        localctx = QuietParser.VariableDeclContext(self, self._ctx, self.state)
        self.enterRule(localctx, 84, self.RULE_variableDecl)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 424
            self.paramType()
            self.state = 425
            self.match(QuietParser.Id)
            self.state = 430
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==69:
                self.state = 426
                self.match(QuietParser.Comma)
                self.state = 427
                self.match(QuietParser.Id)
                self.state = 432
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VariableContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Id(self, i:int=None):
            if i is None:
                return self.getTokens(QuietParser.Id)
            else:
                return self.getToken(QuietParser.Id, i)

        def BracketLeft(self):
            return self.getToken(QuietParser.BracketLeft, 0)

        def BracketRight(self):
            return self.getToken(QuietParser.BracketRight, 0)

        def IntLiteral(self):
            return self.getToken(QuietParser.IntLiteral, 0)

        def getRuleIndex(self):
            return QuietParser.RULE_variable

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVariable" ):
                listener.enterVariable(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVariable" ):
                listener.exitVariable(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVariable" ):
                return visitor.visitVariable(self)
            else:
                return visitor.visitChildren(self)




    def variable(self):

        localctx = QuietParser.VariableContext(self, self._ctx, self.state)
        self.enterRule(localctx, 86, self.RULE_variable)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 433
            self.match(QuietParser.Id)
            self.state = 437
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==64:
                self.state = 434
                self.match(QuietParser.BracketLeft)
                self.state = 435
                _la = self._input.LA(1)
                if not(_la==75 or _la==77):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 436
                self.match(QuietParser.BracketRight)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FuncCallContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ParenLeft(self):
            return self.getToken(QuietParser.ParenLeft, 0)

        def ParenRight(self):
            return self.getToken(QuietParser.ParenRight, 0)

        def Id(self):
            return self.getToken(QuietParser.Id, 0)

        def Measure(self):
            return self.getToken(QuietParser.Measure, 0)

        def controlModifier(self):
            return self.getTypedRuleContext(QuietParser.ControlModifierContext,0)


        def actualParamList(self):
            return self.getTypedRuleContext(QuietParser.ActualParamListContext,0)


        def RightArrow(self):
            return self.getToken(QuietParser.RightArrow, 0)

        def variable(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(QuietParser.VariableContext)
            else:
                return self.getTypedRuleContext(QuietParser.VariableContext,i)


        def Comma(self, i:int=None):
            if i is None:
                return self.getTokens(QuietParser.Comma)
            else:
                return self.getToken(QuietParser.Comma, i)

        def getRuleIndex(self):
            return QuietParser.RULE_funcCall

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFuncCall" ):
                listener.enterFuncCall(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFuncCall" ):
                listener.exitFuncCall(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFuncCall" ):
                return visitor.visitFuncCall(self)
            else:
                return visitor.visitChildren(self)




    def funcCall(self):

        localctx = QuietParser.FuncCallContext(self, self._ctx, self.state)
        self.enterRule(localctx, 88, self.RULE_funcCall)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 440
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==26:
                self.state = 439
                self.controlModifier()


            self.state = 442
            _la = self._input.LA(1)
            if not(_la==30 or _la==77):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 443
            self.match(QuietParser.ParenLeft)
            self.state = 445
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if ((((_la - 66)) & ~0x3f) == 0 and ((1 << (_la - 66)) & 3585) != 0):
                self.state = 444
                self.actualParamList()


            self.state = 447
            self.match(QuietParser.ParenRight)
            self.state = 457
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==73:
                self.state = 448
                self.match(QuietParser.RightArrow)
                self.state = 449
                self.variable()
                self.state = 454
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==69:
                    self.state = 450
                    self.match(QuietParser.Comma)
                    self.state = 451
                    self.variable()
                    self.state = 456
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)



        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IntegerModuleInsnContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def imDataTransferInsn(self):
            return self.getTypedRuleContext(QuietParser.ImDataTransferInsnContext,0)


        def imArithmeticInsn(self):
            return self.getTypedRuleContext(QuietParser.ImArithmeticInsnContext,0)


        def logicInsn(self):
            return self.getTypedRuleContext(QuietParser.LogicInsnContext,0)


        def jumpInsn(self):
            return self.getTypedRuleContext(QuietParser.JumpInsnContext,0)


        def getRuleIndex(self):
            return QuietParser.RULE_integerModuleInsn

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIntegerModuleInsn" ):
                listener.enterIntegerModuleInsn(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIntegerModuleInsn" ):
                listener.exitIntegerModuleInsn(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIntegerModuleInsn" ):
                return visitor.visitIntegerModuleInsn(self)
            else:
                return visitor.visitChildren(self)




    def integerModuleInsn(self):

        localctx = QuietParser.IntegerModuleInsnContext(self, self._ctx, self.state)
        self.enterRule(localctx, 90, self.RULE_integerModuleInsn)
        try:
            self.state = 463
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [33, 34]:
                self.enterOuterAlt(localctx, 1)
                self.state = 459
                self.imDataTransferInsn()
                pass
            elif token in [39, 40, 41, 42, 43, 44, 45, 46]:
                self.enterOuterAlt(localctx, 2)
                self.state = 460
                self.imArithmeticInsn()
                pass
            elif token in [35, 36, 37, 38]:
                self.enterOuterAlt(localctx, 3)
                self.state = 461
                self.logicInsn()
                pass
            elif token in [47, 48, 49, 50, 51, 52, 53]:
                self.enterOuterAlt(localctx, 4)
                self.state = 462
                self.jumpInsn()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ImDataTransferInsnContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def imDTOp(self):
            return self.getTypedRuleContext(QuietParser.ImDTOpContext,0)


        def variable(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(QuietParser.VariableContext)
            else:
                return self.getTypedRuleContext(QuietParser.VariableContext,i)


        def Comma(self):
            return self.getToken(QuietParser.Comma, 0)

        def number(self):
            return self.getTypedRuleContext(QuietParser.NumberContext,0)


        def getRuleIndex(self):
            return QuietParser.RULE_imDataTransferInsn

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterImDataTransferInsn" ):
                listener.enterImDataTransferInsn(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitImDataTransferInsn" ):
                listener.exitImDataTransferInsn(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitImDataTransferInsn" ):
                return visitor.visitImDataTransferInsn(self)
            else:
                return visitor.visitChildren(self)




    def imDataTransferInsn(self):

        localctx = QuietParser.ImDataTransferInsnContext(self, self._ctx, self.state)
        self.enterRule(localctx, 92, self.RULE_imDataTransferInsn)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 465
            self.imDTOp()
            self.state = 466
            self.variable()
            self.state = 467
            self.match(QuietParser.Comma)
            self.state = 470
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [77]:
                self.state = 468
                self.variable()
                pass
            elif token in [66, 75, 76]:
                self.state = 469
                self.number()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ImDTOpContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Mov(self):
            return self.getToken(QuietParser.Mov, 0)

        def Ld(self):
            return self.getToken(QuietParser.Ld, 0)

        def getRuleIndex(self):
            return QuietParser.RULE_imDTOp

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterImDTOp" ):
                listener.enterImDTOp(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitImDTOp" ):
                listener.exitImDTOp(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitImDTOp" ):
                return visitor.visitImDTOp(self)
            else:
                return visitor.visitChildren(self)




    def imDTOp(self):

        localctx = QuietParser.ImDTOpContext(self, self._ctx, self.state)
        self.enterRule(localctx, 94, self.RULE_imDTOp)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 472
            _la = self._input.LA(1)
            if not(_la==33 or _la==34):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LogicInsnContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def imLogicOp(self):
            return self.getTypedRuleContext(QuietParser.ImLogicOpContext,0)


        def variable(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(QuietParser.VariableContext)
            else:
                return self.getTypedRuleContext(QuietParser.VariableContext,i)


        def Comma(self, i:int=None):
            if i is None:
                return self.getTokens(QuietParser.Comma)
            else:
                return self.getToken(QuietParser.Comma, i)

        def getRuleIndex(self):
            return QuietParser.RULE_logicInsn

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLogicInsn" ):
                listener.enterLogicInsn(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLogicInsn" ):
                listener.exitLogicInsn(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLogicInsn" ):
                return visitor.visitLogicInsn(self)
            else:
                return visitor.visitChildren(self)




    def logicInsn(self):

        localctx = QuietParser.LogicInsnContext(self, self._ctx, self.state)
        self.enterRule(localctx, 96, self.RULE_logicInsn)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 474
            self.imLogicOp()
            self.state = 475
            self.variable()
            self.state = 476
            self.match(QuietParser.Comma)
            self.state = 477
            self.variable()
            self.state = 480
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==69:
                self.state = 478
                self.match(QuietParser.Comma)
                self.state = 479
                self.variable()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ImLogicOpContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Land(self):
            return self.getToken(QuietParser.Land, 0)

        def Lor(self):
            return self.getToken(QuietParser.Lor, 0)

        def Lxor(self):
            return self.getToken(QuietParser.Lxor, 0)

        def Lnot(self):
            return self.getToken(QuietParser.Lnot, 0)

        def getRuleIndex(self):
            return QuietParser.RULE_imLogicOp

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterImLogicOp" ):
                listener.enterImLogicOp(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitImLogicOp" ):
                listener.exitImLogicOp(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitImLogicOp" ):
                return visitor.visitImLogicOp(self)
            else:
                return visitor.visitChildren(self)




    def imLogicOp(self):

        localctx = QuietParser.ImLogicOpContext(self, self._ctx, self.state)
        self.enterRule(localctx, 98, self.RULE_imLogicOp)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 482
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 515396075520) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ImArithmeticInsnContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def imArithVarInsn(self):
            return self.getTypedRuleContext(QuietParser.ImArithVarInsnContext,0)


        def imArithImmInsn(self):
            return self.getTypedRuleContext(QuietParser.ImArithImmInsnContext,0)


        def getRuleIndex(self):
            return QuietParser.RULE_imArithmeticInsn

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterImArithmeticInsn" ):
                listener.enterImArithmeticInsn(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitImArithmeticInsn" ):
                listener.exitImArithmeticInsn(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitImArithmeticInsn" ):
                return visitor.visitImArithmeticInsn(self)
            else:
                return visitor.visitChildren(self)




    def imArithmeticInsn(self):

        localctx = QuietParser.ImArithmeticInsnContext(self, self._ctx, self.state)
        self.enterRule(localctx, 100, self.RULE_imArithmeticInsn)
        try:
            self.state = 486
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [39, 41, 43, 45]:
                self.enterOuterAlt(localctx, 1)
                self.state = 484
                self.imArithVarInsn()
                pass
            elif token in [40, 42, 44, 46]:
                self.enterOuterAlt(localctx, 2)
                self.state = 485
                self.imArithImmInsn()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ImArithVarInsnContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def imArithVarOp(self):
            return self.getTypedRuleContext(QuietParser.ImArithVarOpContext,0)


        def variable(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(QuietParser.VariableContext)
            else:
                return self.getTypedRuleContext(QuietParser.VariableContext,i)


        def Comma(self, i:int=None):
            if i is None:
                return self.getTokens(QuietParser.Comma)
            else:
                return self.getToken(QuietParser.Comma, i)

        def getRuleIndex(self):
            return QuietParser.RULE_imArithVarInsn

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterImArithVarInsn" ):
                listener.enterImArithVarInsn(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitImArithVarInsn" ):
                listener.exitImArithVarInsn(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitImArithVarInsn" ):
                return visitor.visitImArithVarInsn(self)
            else:
                return visitor.visitChildren(self)




    def imArithVarInsn(self):

        localctx = QuietParser.ImArithVarInsnContext(self, self._ctx, self.state)
        self.enterRule(localctx, 102, self.RULE_imArithVarInsn)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 488
            self.imArithVarOp()
            self.state = 489
            self.variable()
            self.state = 490
            self.match(QuietParser.Comma)
            self.state = 491
            self.variable()
            self.state = 492
            self.match(QuietParser.Comma)
            self.state = 493
            self.variable()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ImArithVarOpContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Add(self):
            return self.getToken(QuietParser.Add, 0)

        def Sub(self):
            return self.getToken(QuietParser.Sub, 0)

        def Mul(self):
            return self.getToken(QuietParser.Mul, 0)

        def Div(self):
            return self.getToken(QuietParser.Div, 0)

        def getRuleIndex(self):
            return QuietParser.RULE_imArithVarOp

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterImArithVarOp" ):
                listener.enterImArithVarOp(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitImArithVarOp" ):
                listener.exitImArithVarOp(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitImArithVarOp" ):
                return visitor.visitImArithVarOp(self)
            else:
                return visitor.visitChildren(self)




    def imArithVarOp(self):

        localctx = QuietParser.ImArithVarOpContext(self, self._ctx, self.state)
        self.enterRule(localctx, 104, self.RULE_imArithVarOp)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 495
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 46729244180480) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ImArithImmInsnContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def imArithImmOp(self):
            return self.getTypedRuleContext(QuietParser.ImArithImmOpContext,0)


        def variable(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(QuietParser.VariableContext)
            else:
                return self.getTypedRuleContext(QuietParser.VariableContext,i)


        def Comma(self, i:int=None):
            if i is None:
                return self.getTokens(QuietParser.Comma)
            else:
                return self.getToken(QuietParser.Comma, i)

        def number(self):
            return self.getTypedRuleContext(QuietParser.NumberContext,0)


        def getRuleIndex(self):
            return QuietParser.RULE_imArithImmInsn

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterImArithImmInsn" ):
                listener.enterImArithImmInsn(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitImArithImmInsn" ):
                listener.exitImArithImmInsn(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitImArithImmInsn" ):
                return visitor.visitImArithImmInsn(self)
            else:
                return visitor.visitChildren(self)




    def imArithImmInsn(self):

        localctx = QuietParser.ImArithImmInsnContext(self, self._ctx, self.state)
        self.enterRule(localctx, 106, self.RULE_imArithImmInsn)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 497
            self.imArithImmOp()
            self.state = 498
            self.variable()
            self.state = 499
            self.match(QuietParser.Comma)
            self.state = 500
            self.variable()
            self.state = 501
            self.match(QuietParser.Comma)
            self.state = 502
            self.number()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ImArithImmOpContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Addi(self):
            return self.getToken(QuietParser.Addi, 0)

        def Subi(self):
            return self.getToken(QuietParser.Subi, 0)

        def Muli(self):
            return self.getToken(QuietParser.Muli, 0)

        def Divi(self):
            return self.getToken(QuietParser.Divi, 0)

        def getRuleIndex(self):
            return QuietParser.RULE_imArithImmOp

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterImArithImmOp" ):
                listener.enterImArithImmOp(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitImArithImmOp" ):
                listener.exitImArithImmOp(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitImArithImmOp" ):
                return visitor.visitImArithImmOp(self)
            else:
                return visitor.visitChildren(self)




    def imArithImmOp(self):

        localctx = QuietParser.ImArithImmOpContext(self, self._ctx, self.state)
        self.enterRule(localctx, 108, self.RULE_imArithImmOp)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 504
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 93458488360960) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class JumpInsnContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def jumpOp(self):
            return self.getTypedRuleContext(QuietParser.JumpOpContext,0)


        def label(self):
            return self.getTypedRuleContext(QuietParser.LabelContext,0)


        def variable(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(QuietParser.VariableContext)
            else:
                return self.getTypedRuleContext(QuietParser.VariableContext,i)


        def Comma(self, i:int=None):
            if i is None:
                return self.getTokens(QuietParser.Comma)
            else:
                return self.getToken(QuietParser.Comma, i)

        def getRuleIndex(self):
            return QuietParser.RULE_jumpInsn

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterJumpInsn" ):
                listener.enterJumpInsn(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitJumpInsn" ):
                listener.exitJumpInsn(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitJumpInsn" ):
                return visitor.visitJumpInsn(self)
            else:
                return visitor.visitChildren(self)




    def jumpInsn(self):

        localctx = QuietParser.JumpInsnContext(self, self._ctx, self.state)
        self.enterRule(localctx, 110, self.RULE_jumpInsn)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 506
            self.jumpOp()
            self.state = 512
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,47,self._ctx)
            if la_ == 1:
                self.state = 507
                self.variable()
                self.state = 508
                self.match(QuietParser.Comma)
                self.state = 509
                self.variable()
                self.state = 510
                self.match(QuietParser.Comma)


            self.state = 514
            self.label()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class JumpOpContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Jump(self):
            return self.getToken(QuietParser.Jump, 0)

        def Bne(self):
            return self.getToken(QuietParser.Bne, 0)

        def Beq(self):
            return self.getToken(QuietParser.Beq, 0)

        def Blt(self):
            return self.getToken(QuietParser.Blt, 0)

        def Ble(self):
            return self.getToken(QuietParser.Ble, 0)

        def Bgt(self):
            return self.getToken(QuietParser.Bgt, 0)

        def Bge(self):
            return self.getToken(QuietParser.Bge, 0)

        def getRuleIndex(self):
            return QuietParser.RULE_jumpOp

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterJumpOp" ):
                listener.enterJumpOp(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitJumpOp" ):
                listener.exitJumpOp(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitJumpOp" ):
                return visitor.visitJumpOp(self)
            else:
                return visitor.visitChildren(self)




    def jumpOp(self):

        localctx = QuietParser.JumpOpContext(self, self._ctx, self.state)
        self.enterRule(localctx, 112, self.RULE_jumpOp)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 516
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 17873661021126656) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FloatModuleInsnContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def fmDataTransferInsn(self):
            return self.getTypedRuleContext(QuietParser.FmDataTransferInsnContext,0)


        def fmArithmeticInsn(self):
            return self.getTypedRuleContext(QuietParser.FmArithmeticInsnContext,0)


        def getRuleIndex(self):
            return QuietParser.RULE_floatModuleInsn

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFloatModuleInsn" ):
                listener.enterFloatModuleInsn(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFloatModuleInsn" ):
                listener.exitFloatModuleInsn(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFloatModuleInsn" ):
                return visitor.visitFloatModuleInsn(self)
            else:
                return visitor.visitChildren(self)




    def floatModuleInsn(self):

        localctx = QuietParser.FloatModuleInsnContext(self, self._ctx, self.state)
        self.enterRule(localctx, 114, self.RULE_floatModuleInsn)
        try:
            self.state = 520
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [54, 55]:
                self.enterOuterAlt(localctx, 1)
                self.state = 518
                self.fmDataTransferInsn()
                pass
            elif token in [56, 57, 58, 59, 60, 61, 62, 63]:
                self.enterOuterAlt(localctx, 2)
                self.state = 519
                self.fmArithmeticInsn()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FmDataTransferInsnContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def fmDTOp(self):
            return self.getTypedRuleContext(QuietParser.FmDTOpContext,0)


        def variable(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(QuietParser.VariableContext)
            else:
                return self.getTypedRuleContext(QuietParser.VariableContext,i)


        def Comma(self):
            return self.getToken(QuietParser.Comma, 0)

        def number(self):
            return self.getTypedRuleContext(QuietParser.NumberContext,0)


        def getRuleIndex(self):
            return QuietParser.RULE_fmDataTransferInsn

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFmDataTransferInsn" ):
                listener.enterFmDataTransferInsn(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFmDataTransferInsn" ):
                listener.exitFmDataTransferInsn(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFmDataTransferInsn" ):
                return visitor.visitFmDataTransferInsn(self)
            else:
                return visitor.visitChildren(self)




    def fmDataTransferInsn(self):

        localctx = QuietParser.FmDataTransferInsnContext(self, self._ctx, self.state)
        self.enterRule(localctx, 116, self.RULE_fmDataTransferInsn)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 522
            self.fmDTOp()
            self.state = 523
            self.variable()
            self.state = 524
            self.match(QuietParser.Comma)
            self.state = 527
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [77]:
                self.state = 525
                self.variable()
                pass
            elif token in [66, 75, 76]:
                self.state = 526
                self.number()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FmDTOpContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Ldd(self):
            return self.getToken(QuietParser.Ldd, 0)

        def Movd(self):
            return self.getToken(QuietParser.Movd, 0)

        def getRuleIndex(self):
            return QuietParser.RULE_fmDTOp

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFmDTOp" ):
                listener.enterFmDTOp(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFmDTOp" ):
                listener.exitFmDTOp(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFmDTOp" ):
                return visitor.visitFmDTOp(self)
            else:
                return visitor.visitChildren(self)




    def fmDTOp(self):

        localctx = QuietParser.FmDTOpContext(self, self._ctx, self.state)
        self.enterRule(localctx, 118, self.RULE_fmDTOp)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 529
            _la = self._input.LA(1)
            if not(_la==54 or _la==55):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FmArithmeticInsnContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def fmArithVarInsn(self):
            return self.getTypedRuleContext(QuietParser.FmArithVarInsnContext,0)


        def fmArithImmInsn(self):
            return self.getTypedRuleContext(QuietParser.FmArithImmInsnContext,0)


        def getRuleIndex(self):
            return QuietParser.RULE_fmArithmeticInsn

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFmArithmeticInsn" ):
                listener.enterFmArithmeticInsn(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFmArithmeticInsn" ):
                listener.exitFmArithmeticInsn(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFmArithmeticInsn" ):
                return visitor.visitFmArithmeticInsn(self)
            else:
                return visitor.visitChildren(self)




    def fmArithmeticInsn(self):

        localctx = QuietParser.FmArithmeticInsnContext(self, self._ctx, self.state)
        self.enterRule(localctx, 120, self.RULE_fmArithmeticInsn)
        try:
            self.state = 533
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [56, 58, 60, 62]:
                self.enterOuterAlt(localctx, 1)
                self.state = 531
                self.fmArithVarInsn()
                pass
            elif token in [57, 59, 61, 63]:
                self.enterOuterAlt(localctx, 2)
                self.state = 532
                self.fmArithImmInsn()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FmArithVarInsnContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def fmArithVarOp(self):
            return self.getTypedRuleContext(QuietParser.FmArithVarOpContext,0)


        def variable(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(QuietParser.VariableContext)
            else:
                return self.getTypedRuleContext(QuietParser.VariableContext,i)


        def Comma(self, i:int=None):
            if i is None:
                return self.getTokens(QuietParser.Comma)
            else:
                return self.getToken(QuietParser.Comma, i)

        def getRuleIndex(self):
            return QuietParser.RULE_fmArithVarInsn

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFmArithVarInsn" ):
                listener.enterFmArithVarInsn(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFmArithVarInsn" ):
                listener.exitFmArithVarInsn(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFmArithVarInsn" ):
                return visitor.visitFmArithVarInsn(self)
            else:
                return visitor.visitChildren(self)




    def fmArithVarInsn(self):

        localctx = QuietParser.FmArithVarInsnContext(self, self._ctx, self.state)
        self.enterRule(localctx, 122, self.RULE_fmArithVarInsn)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 535
            self.fmArithVarOp()
            self.state = 536
            self.variable()
            self.state = 537
            self.match(QuietParser.Comma)
            self.state = 538
            self.variable()
            self.state = 539
            self.match(QuietParser.Comma)
            self.state = 540
            self.variable()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FmArithVarOpContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Addd(self):
            return self.getToken(QuietParser.Addd, 0)

        def Subd(self):
            return self.getToken(QuietParser.Subd, 0)

        def Muld(self):
            return self.getToken(QuietParser.Muld, 0)

        def Divd(self):
            return self.getToken(QuietParser.Divd, 0)

        def getRuleIndex(self):
            return QuietParser.RULE_fmArithVarOp

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFmArithVarOp" ):
                listener.enterFmArithVarOp(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFmArithVarOp" ):
                listener.exitFmArithVarOp(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFmArithVarOp" ):
                return visitor.visitFmArithVarOp(self)
            else:
                return visitor.visitChildren(self)




    def fmArithVarOp(self):

        localctx = QuietParser.FmArithVarOpContext(self, self._ctx, self.state)
        self.enterRule(localctx, 124, self.RULE_fmArithVarOp)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 542
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 6124895493223874560) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FmArithImmInsnContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def fmArithImmOp(self):
            return self.getTypedRuleContext(QuietParser.FmArithImmOpContext,0)


        def variable(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(QuietParser.VariableContext)
            else:
                return self.getTypedRuleContext(QuietParser.VariableContext,i)


        def Comma(self, i:int=None):
            if i is None:
                return self.getTokens(QuietParser.Comma)
            else:
                return self.getToken(QuietParser.Comma, i)

        def number(self):
            return self.getTypedRuleContext(QuietParser.NumberContext,0)


        def getRuleIndex(self):
            return QuietParser.RULE_fmArithImmInsn

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFmArithImmInsn" ):
                listener.enterFmArithImmInsn(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFmArithImmInsn" ):
                listener.exitFmArithImmInsn(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFmArithImmInsn" ):
                return visitor.visitFmArithImmInsn(self)
            else:
                return visitor.visitChildren(self)




    def fmArithImmInsn(self):

        localctx = QuietParser.FmArithImmInsnContext(self, self._ctx, self.state)
        self.enterRule(localctx, 126, self.RULE_fmArithImmInsn)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 544
            self.fmArithImmOp()
            self.state = 545
            self.variable()
            self.state = 546
            self.match(QuietParser.Comma)
            self.state = 547
            self.variable()
            self.state = 548
            self.match(QuietParser.Comma)
            self.state = 549
            self.number()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FmArithImmOpContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Adddi(self):
            return self.getToken(QuietParser.Adddi, 0)

        def Subdi(self):
            return self.getToken(QuietParser.Subdi, 0)

        def Muldi(self):
            return self.getToken(QuietParser.Muldi, 0)

        def Divdi(self):
            return self.getToken(QuietParser.Divdi, 0)

        def getRuleIndex(self):
            return QuietParser.RULE_fmArithImmOp

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFmArithImmOp" ):
                listener.enterFmArithImmOp(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFmArithImmOp" ):
                listener.exitFmArithImmOp(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFmArithImmOp" ):
                return visitor.visitFmArithImmOp(self)
            else:
                return visitor.visitChildren(self)




    def fmArithImmOp(self):

        localctx = QuietParser.FmArithImmOpContext(self, self._ctx, self.state)
        self.enterRule(localctx, 128, self.RULE_fmArithImmOp)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 551
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & -6196953087261802496) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx





