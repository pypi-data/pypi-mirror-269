//! Library for the docextractor executable.
//!
//! It consists of functions to extract content from the AST and
//! to write the content to an RST or MD file. The crate is tested on itself,
//! so all the documentation in the crate is in RST. The tests for Markdown
//! are done on the dependencies.

mod directives;
mod formats;

use std::fs::{create_dir_all, File};
use std::io::{Read, Write};
use std::os::unix::fs::MetadataExt;
use std::path::{Path, PathBuf};

pub use crate::directives::DirectiveVisibility;
use crate::directives::{extract_doc_from_attrs, CrateDirective, Directive, ModuleDirective};
pub use crate::formats::Format;

/// Read a Rust source code file and generate its AST.
///
/// Args:
///     :path: The path to the file to read.
///
/// Returns:
///     The AST for the file generated by ``syn``.
///
/// Panics:
///     If ``syn`` cannot parse the file.
fn read_rs_file(path: &Path) -> syn::File {
    let mut file = File::open(path).unwrap();
    let mut source_code = String::with_capacity(file.metadata().unwrap().size() as usize);
    file.read_to_string(&mut source_code).unwrap();
    syn::parse_file(&source_code).unwrap()
}

/// Checks that the crate's source directory exists and returns a canonical
/// form.
///
/// Note that this does not check that the crate name is the same as the crate's
/// directory name. This is intentional to allow renaming the crate for the
/// documentation.
///
/// Args:
///     :crate_name: The name of the crate.
///     :crate_src_dir: The crate's source directory as provided.
///
/// Returns:
///     A canonical form of the input, that ends with ``src`` (i.e. the
///     directory under which ``main.rs`` and ``lib.rs`` exist).
///
/// Panics:
///     If the input path contains non UTF-8 characters, cannot be accessed
///     or is not a directory.
fn check_crate_src_dir(crate_name: &str, crate_src_dir: &Path) -> PathBuf {
    if !crate_src_dir.is_dir() {
        panic!("{} is not a directory", crate_src_dir.to_str().unwrap());
    }

    // Check if it ends with src, and convert to owned value
    let crate_src_dir = if crate_src_dir.ends_with("src") {
        crate_src_dir.to_owned()
    }
    else {
        crate_src_dir.join("src")
    };

    // Canonicalize, which also checks that it exists.
    let crate_src_dir = match crate_src_dir.canonicalize() {
        Ok(d) => d,
        Err(e) => panic!("Could not find crate source directory: {}", e),
    };

    log::debug!(
        "Extracting docs for crate {crate_name} from {}",
        crate_src_dir.to_str().unwrap()
    );
    crate_src_dir
}

/// Checks that the output directory ends with the crates name, and creates
/// it if necessary.
///
/// Args:
///     :crate_name: The name of the crate.
///     :output_dir: The output path provided to check.
///
/// Returns:
///     A canonical form of the output directory for the crate's docs.
///
/// Panics:
///     If the output directory cannot be created.
fn check_and_create_output_dir(crate_name: &str, output_dir: &Path) -> PathBuf {
    // Check if the output directory ends with the crate name
    let output_dir = if !output_dir.ends_with(crate_name) {
        output_dir.join(crate_name)
    }
    else {
        output_dir.to_owned()
    };

    // Create output directory and canonicalize it.
    // Canonicalize fails if the output_dir doesn't exist, so it is also a good
    // check for permissions.
    create_dir_all(&output_dir).unwrap();
    let output_dir = match output_dir.canonicalize() {
        Ok(d) => d,
        Err(e) => panic!("Could not create the output directory: {}", e),
    };

    log::debug!(
        "Generated docs will be stored in {}",
        output_dir.to_str().unwrap()
    );
    output_dir
}

/// Get the document file from the relative path of the module.
///
/// Args:
///     :output_dir: The output directory for the crate's docs.
///     :rel_path: The relative path of the module file within the crate
///     :format: The format for the output file.
///
/// Returns:
///     A tuple of the file name and ``File`` for writing the document content
///     to. The file is opened for writing and truncated.
///
/// Panics:
///     If the file cannot be created or there are non unicode characters
///     in the file path.
fn get_doc_file_from_path(output_dir: &Path, rel_path: &Path, format: &Format) -> (String, File) {
    // For mod.rs files, the output file name is the parent directory name.
    // Otherwise, it is same as the file name.
    let doc_file_name = if rel_path.ends_with("mod.rs") {
        rel_path.parent().unwrap().to_owned()
    }
    else {
        rel_path
            .parent()
            .unwrap()
            .join(rel_path.file_stem().unwrap())
    };

    // Create the parent directory if required
    create_dir_all(output_dir.join(&doc_file_name).parent().unwrap()).unwrap();

    // Convert to absolute path and add the extension.
    // Cannot use canonicalize here since it will error.
    let doc_file_name =
        output_dir.join(doc_file_name).to_str().unwrap().to_string() + format.extension();

    // Create the file and return it along with the name.
    match File::create(&doc_file_name) {
        Ok(f) => (doc_file_name, f),
        Err(e) => panic!("Could not create file {doc_file_name}: {}", e),
    }
}

fn find_mod_file(parent: &Path, module_directive: &ModuleDirective) -> PathBuf {
    // Check modname.rs under the same directory as crate.
    let mut mod_file = parent.join(format!("{}.rs", &module_directive.ident));

    // Check modname/mod.rs under the crate's directory
    if !mod_file.is_file() {
        mod_file = parent.join(&module_directive.ident).join("mod.rs");
    }

    // Panic if still not found.
    if !mod_file.is_file() {
        panic!(
            "Could not locate file for module {}",
            &module_directive.ident
        );
    }
    mod_file
}

/// The different types of files that can be encountered.
enum FileType {
    /// A file that compiles to a binary
    Bin(String),
    /// The crate's library file.
    Lib(String),
    /// All other modules within the crate's library.
    Mod(String),
}

/// Macro to push the module files to the files vec for processing
///
/// Args:
///     :files: The files list to push the files to.
///     :parent: The parent path of the module or crate's file.
///     :directive: The directive for the module or crate.
macro_rules! push_module_files {
    ($files:expr, $parent:expr, $directive:expr) => {
        for directive in &$directive.items {
            if let Directive::Module(m) = directive {
                if m.items.is_empty() {
                    // Push the file to the vec
                    $files.push((
                        find_mod_file($parent, m),
                        FileType::Mod(m.name.clone()),
                        Some(m.visibility.clone()),
                    ));
                }
            }
        }
    };
}

/// Traverse the crate and extract the docstrings for the items.
///
/// Args:
///     :crate_name: The name of the crate.
///     :crate_src_dir: The directory with the crate source code.
///     :output_dir: The directory where to produce the generated documentation
///         files.
///     :format: The format of the docstrings.
pub fn traverse_crate(
    crate_name: &str,
    crate_src_dir: &Path,
    output_dir: &Path,
    format: Format,
    max_visibility: DirectiveVisibility,
) {
    let crate_src_dir = check_crate_src_dir(crate_name, crate_src_dir);
    let output_dir = check_and_create_output_dir(crate_name, output_dir);

    // Vec of files that we need to process
    let mut files = vec![];

    // Add the main file if it exists.
    // TODO: Make configurable
    let main = crate_src_dir.join("main.rs");
    if main.is_file() {
        files.push((main, FileType::Bin(crate_name.to_string()), None));
    }

    // Check src/bin for other executables
    let bin_dir = crate_src_dir.join("bin");
    if bin_dir.is_dir() {
        for path in bin_dir.read_dir().unwrap() {
            let path = path.unwrap().path();
            if path.is_dir() {
                let executable = path
                    .components()
                    .last()
                    .unwrap()
                    .as_os_str()
                    .to_str()
                    .unwrap()
                    .to_string();
                files.push((path.join("main.rs"), FileType::Bin(executable), None));
            }
            else if path.extension() == Some("rs".as_ref()) {
                let executable = path.file_stem().unwrap().to_str().unwrap().to_string();
                files.push((path, FileType::Bin(executable), None));
            }
        }
    }

    // Add the lib file if it exists.
    // TODO: Make configurable
    let lib = crate_src_dir.join("lib.rs");
    if lib.is_file() {
        files.push((lib, FileType::Lib(crate_name.to_string()), None));
    }

    while let Some((path, file, vis)) = files.pop() {
        log::debug!("Processing file {}", path.to_str().unwrap());

        let ast = read_rs_file(&path);
        let text = match file {
            FileType::Bin(exe_name) => {
                let mut text = format.make_title(&format!("{exe_name} documentation"), false);
                text.extend(format.format_content(extract_doc_from_attrs(&ast.attrs)));
                text
            }
            FileType::Lib(crate_name) => {
                let crate_directive = CrateDirective::new(&crate_name, &ast);

                push_module_files!(files, path.parent().unwrap(), crate_directive);

                let mut text =
                    format.make_title(&format!("Crate {crate_name} documentation"), false);
                text.extend(
                    format.format_directive(Directive::Crate(crate_directive), &max_visibility),
                );
                text
            }
            FileType::Mod(module) => {
                let module_directive = ModuleDirective::new(&module, &ast, vis.unwrap());

                push_module_files!(files, path.parent().unwrap(), module_directive);

                let mut text = format.make_title(&format!("mod {}", &module_directive.ident), true);
                text.extend(
                    format.format_directive(Directive::Module(module_directive), &max_visibility),
                );
                text
            }
        };

        let (doc_file_name, mut doc_file) = get_doc_file_from_path(
            &output_dir,
            path.strip_prefix(&crate_src_dir).unwrap_or(&path),
            &format,
        );
        log::debug!("Output file {doc_file_name}");

        for line in text {
            writeln!(doc_file, "{line}").unwrap();
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_extraction() {
        // Test just extracts the documents for the current crate. This avoids
        // creating unnecessary test files when the source code itself can be
        // used.
        traverse_crate(
            "sphinx-rustdocgen",
            Path::new("."),
            Path::new("../docs/crates"),
            Format::Rst,
            DirectiveVisibility::Pvt,
        );
    }
}
