"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
Frequenz Dispatch Automation API

Copyright:
Copyright 2022 Frequenz Energy-as-a-Service GmbH

License:
MIT
"""

import builtins
import collections.abc
import frequenz.api.common.v1.microgrid.components.components_pb2
import google.protobuf.descriptor
import google.protobuf.field_mask_pb2
import google.protobuf.internal.containers
import google.protobuf.internal.enum_type_wrapper
import google.protobuf.message
import google.protobuf.struct_pb2
import google.protobuf.timestamp_pb2
import sys
import typing

if sys.version_info >= (3, 10):
    import typing as typing_extensions
else:
    import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor

@typing.final
class Dispatch(google.protobuf.message.Message):
    """Message representing one dispatch.

    Timezone Note: Timestamps are in UTC. It is the responsibility of each microgrid to translate UTC
    to its local timezone.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    ID_FIELD_NUMBER: builtins.int
    MICROGRID_ID_FIELD_NUMBER: builtins.int
    TYPE_FIELD_NUMBER: builtins.int
    CREATE_TIME_FIELD_NUMBER: builtins.int
    UPDATE_TIME_FIELD_NUMBER: builtins.int
    START_TIME_FIELD_NUMBER: builtins.int
    DURATION_FIELD_NUMBER: builtins.int
    SELECTOR_FIELD_NUMBER: builtins.int
    IS_ACTIVE_FIELD_NUMBER: builtins.int
    IS_DRY_RUN_FIELD_NUMBER: builtins.int
    PAYLOAD_FIELD_NUMBER: builtins.int
    RECURRENCE_FIELD_NUMBER: builtins.int
    id: builtins.int
    """The dispatch identifier"""
    microgrid_id: builtins.int
    """The microgrid identifier"""
    type: builtins.str
    """The dispatch type.
    Contains user-defined information about what "type" of dispatch this is.
    Downstream applications that consume the dispatch API are responsible for
    understanding and processing this field.
    """
    duration: builtins.int
    """Duration in seconds"""
    is_active: builtins.bool
    """The "active" status
    An active dispatch is eligible for processing, either immediately or at a scheduled
    time in the future, including recurring dispatches. If a dispatch is set to
    inactive, it won't be processed even if it matches all other conditions, allowing
    for temporary disabling of dispatches without deletion.
    """
    is_dry_run: builtins.bool
    """The "dry run" status
    A dry run dispatch is executed for logging and monitoring purposes
    without affecting the microgrid components. This is useful, for example,
    in scenarios where a user may want to test dispatch behavior without
    actually affecting any component states.
    Notably, a dispatch can be both "dry run" and "active," allowing for
    the system to generate logs and observe behavior without making actual changes.
    """
    @property
    def create_time(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """The creation time in UTC
        This is set when a dispatch is created via the create request message
        """

    @property
    def update_time(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """The update time in UTC
        This is set when a dispatch is modified via the update request message
        """

    @property
    def start_time(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """The start time in UTC"""

    @property
    def selector(self) -> global___ComponentSelector:
        """The component selector"""

    @property
    def payload(self) -> google.protobuf.struct_pb2.Struct:
        """The dispatch payload"""

    @property
    def recurrence(self) -> global___RecurrenceRule:
        """The recurrence rule"""

    def __init__(
        self,
        *,
        id: builtins.int = ...,
        microgrid_id: builtins.int = ...,
        type: builtins.str = ...,
        create_time: google.protobuf.timestamp_pb2.Timestamp | None = ...,
        update_time: google.protobuf.timestamp_pb2.Timestamp | None = ...,
        start_time: google.protobuf.timestamp_pb2.Timestamp | None = ...,
        duration: builtins.int = ...,
        selector: global___ComponentSelector | None = ...,
        is_active: builtins.bool = ...,
        is_dry_run: builtins.bool = ...,
        payload: google.protobuf.struct_pb2.Struct | None = ...,
        recurrence: global___RecurrenceRule | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["create_time", b"create_time", "payload", b"payload", "recurrence", b"recurrence", "selector", b"selector", "start_time", b"start_time", "update_time", b"update_time"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["create_time", b"create_time", "duration", b"duration", "id", b"id", "is_active", b"is_active", "is_dry_run", b"is_dry_run", "microgrid_id", b"microgrid_id", "payload", b"payload", "recurrence", b"recurrence", "selector", b"selector", "start_time", b"start_time", "type", b"type", "update_time", b"update_time"]) -> None: ...

global___Dispatch = Dispatch

@typing.final
class TimeIntervalFilter(google.protobuf.message.Message):
    """Filter parameter for specifying multiple time intervals"""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    START_FROM_FIELD_NUMBER: builtins.int
    START_TO_FIELD_NUMBER: builtins.int
    END_FROM_FIELD_NUMBER: builtins.int
    END_TO_FIELD_NUMBER: builtins.int
    @property
    def start_from(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """Filter by start_time >= this timestamp"""

    @property
    def start_to(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """Filter by start_time < this timestamp"""

    @property
    def end_from(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """Filter by recurrence.end_criteria.until >= this timestamp"""

    @property
    def end_to(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """Filter by recurrence.end_criteria.until < this timestamp"""

    def __init__(
        self,
        *,
        start_from: google.protobuf.timestamp_pb2.Timestamp | None = ...,
        start_to: google.protobuf.timestamp_pb2.Timestamp | None = ...,
        end_from: google.protobuf.timestamp_pb2.Timestamp | None = ...,
        end_to: google.protobuf.timestamp_pb2.Timestamp | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["end_from", b"end_from", "end_to", b"end_to", "start_from", b"start_from", "start_to", b"start_to"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["end_from", b"end_from", "end_to", b"end_to", "start_from", b"start_from", "start_to", b"start_to"]) -> None: ...

global___TimeIntervalFilter = TimeIntervalFilter

@typing.final
class ComponentSelector(google.protobuf.message.Message):
    """Parameter for controlling which components a dispatch applies to
    Either a set of component IDs, or all components belonging to a category
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    COMPONENT_IDS_FIELD_NUMBER: builtins.int
    COMPONENT_CATEGORY_FIELD_NUMBER: builtins.int
    component_category: frequenz.api.common.v1.microgrid.components.components_pb2.ComponentCategory.ValueType
    """Component category"""
    @property
    def component_ids(self) -> global___ComponentIDs:
        """Set of component IDs"""

    def __init__(
        self,
        *,
        component_ids: global___ComponentIDs | None = ...,
        component_category: frequenz.api.common.v1.microgrid.components.components_pb2.ComponentCategory.ValueType = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["component_category", b"component_category", "component_ids", b"component_ids", "selector", b"selector"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["component_category", b"component_category", "component_ids", b"component_ids", "selector", b"selector"]) -> None: ...
    def WhichOneof(self, oneof_group: typing.Literal["selector", b"selector"]) -> typing.Literal["component_ids", "component_category"] | None: ...

global___ComponentSelector = ComponentSelector

@typing.final
class ComponentIDs(google.protobuf.message.Message):
    """Wrapper for controlling dispatches with a set of component IDs"""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    COMPONENT_IDS_FIELD_NUMBER: builtins.int
    @property
    def component_ids(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.int]:
        """Set of component IDs"""

    def __init__(
        self,
        *,
        component_ids: collections.abc.Iterable[builtins.int] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["component_ids", b"component_ids"]) -> None: ...

global___ComponentIDs = ComponentIDs

@typing.final
class RecurrenceRule(google.protobuf.message.Message):
    """Ruleset governing when and how a dispatch should re-occur.

    Timezone Note: Timestamps are in UTC. It is the responsibility of each microgrid to translate UTC
    to its local timezone.

    This definition tries to adhere closely to the iCalendar specification ([RFC5545]),
    particularly for recurrence rules. For advanced use-cases or further clarifications,
    refer to [RFC5545].

    [RFC5545]: https://tools.ietf.org/html/rfc5545

    #### Examples

    ##### Every 6 months

    ```proto
    message RecurrenceRule {
      Frequency freq = FREQUENCY_MONTHLY;
      uint32 interval = 6;
    }
    ```

    ##### Weekends only

    ```proto
    message RecurrenceRule {
      Frequency freq = FREQUENCY_WEEKLY;
      repeated Weekday byweekdays = [WEEKDAY_SATURDAY, WEEKDAY_SUNDAY];
    }
    ```

    ##### At midnight

    Every day at midnight.

    ```proto
    message RecurrenceRule {
      Frequency freq = FREQUENCY_DAILY;
      repeated uint32 byhours = [0];
    }
    ```

    ##### Nightly

    Assuming "night" means from 8 PM to 6 AM.

    ```proto
    message RecurrenceRule {
      Frequency freq = FREQUENCY_DAILY;
      repeated uint32 byhours = [20, 21, 22, 23, 0, 1, 2, 3, 4, 5];
    }
    ```
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    class _Weekday:
        ValueType = typing.NewType("ValueType", builtins.int)
        V: typing_extensions.TypeAlias = ValueType

    class _WeekdayEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[RecurrenceRule._Weekday.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        WEEKDAY_UNSPECIFIED: RecurrenceRule._Weekday.ValueType  # 0
        WEEKDAY_MONDAY: RecurrenceRule._Weekday.ValueType  # 1
        WEEKDAY_TUESDAY: RecurrenceRule._Weekday.ValueType  # 2
        WEEKDAY_WEDNESDAY: RecurrenceRule._Weekday.ValueType  # 3
        WEEKDAY_THURSDAY: RecurrenceRule._Weekday.ValueType  # 4
        WEEKDAY_FRIDAY: RecurrenceRule._Weekday.ValueType  # 5
        WEEKDAY_SATURDAY: RecurrenceRule._Weekday.ValueType  # 6
        WEEKDAY_SUNDAY: RecurrenceRule._Weekday.ValueType  # 7

    class Weekday(_Weekday, metaclass=_WeekdayEnumTypeWrapper):
        """Enum representing the day of the week"""

    WEEKDAY_UNSPECIFIED: RecurrenceRule.Weekday.ValueType  # 0
    WEEKDAY_MONDAY: RecurrenceRule.Weekday.ValueType  # 1
    WEEKDAY_TUESDAY: RecurrenceRule.Weekday.ValueType  # 2
    WEEKDAY_WEDNESDAY: RecurrenceRule.Weekday.ValueType  # 3
    WEEKDAY_THURSDAY: RecurrenceRule.Weekday.ValueType  # 4
    WEEKDAY_FRIDAY: RecurrenceRule.Weekday.ValueType  # 5
    WEEKDAY_SATURDAY: RecurrenceRule.Weekday.ValueType  # 6
    WEEKDAY_SUNDAY: RecurrenceRule.Weekday.ValueType  # 7

    class _Frequency:
        ValueType = typing.NewType("ValueType", builtins.int)
        V: typing_extensions.TypeAlias = ValueType

    class _FrequencyEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[RecurrenceRule._Frequency.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        FREQUENCY_UNSPECIFIED: RecurrenceRule._Frequency.ValueType  # 0
        FREQUENCY_MINUTELY: RecurrenceRule._Frequency.ValueType  # 1
        FREQUENCY_HOURLY: RecurrenceRule._Frequency.ValueType  # 2
        FREQUENCY_DAILY: RecurrenceRule._Frequency.ValueType  # 3
        FREQUENCY_WEEKLY: RecurrenceRule._Frequency.ValueType  # 4
        FREQUENCY_MONTHLY: RecurrenceRule._Frequency.ValueType  # 5

    class Frequency(_Frequency, metaclass=_FrequencyEnumTypeWrapper):
        """Enum representing the frequency of the recurrence"""

    FREQUENCY_UNSPECIFIED: RecurrenceRule.Frequency.ValueType  # 0
    FREQUENCY_MINUTELY: RecurrenceRule.Frequency.ValueType  # 1
    FREQUENCY_HOURLY: RecurrenceRule.Frequency.ValueType  # 2
    FREQUENCY_DAILY: RecurrenceRule.Frequency.ValueType  # 3
    FREQUENCY_WEEKLY: RecurrenceRule.Frequency.ValueType  # 4
    FREQUENCY_MONTHLY: RecurrenceRule.Frequency.ValueType  # 5

    @typing.final
    class EndCriteria(google.protobuf.message.Message):
        """Controls when a recurring dispatch should end"""

        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        COUNT_FIELD_NUMBER: builtins.int
        UNTIL_FIELD_NUMBER: builtins.int
        count: builtins.int
        """The number of times this dispatch should recur.
        If this field is set, the dispatch will recur the given number of times.
        """
        @property
        def until(self) -> google.protobuf.timestamp_pb2.Timestamp:
            """The end time of this dispatch in UTC.
            If this field is set, the dispatch will recur until the given timestamp.
            """

        def __init__(
            self,
            *,
            count: builtins.int = ...,
            until: google.protobuf.timestamp_pb2.Timestamp | None = ...,
        ) -> None: ...
        def HasField(self, field_name: typing.Literal["count", b"count", "count_or_until", b"count_or_until", "until", b"until"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing.Literal["count", b"count", "count_or_until", b"count_or_until", "until", b"until"]) -> None: ...
        def WhichOneof(self, oneof_group: typing.Literal["count_or_until", b"count_or_until"]) -> typing.Literal["count", "until"] | None: ...

    FREQ_FIELD_NUMBER: builtins.int
    INTERVAL_FIELD_NUMBER: builtins.int
    END_CRITERIA_FIELD_NUMBER: builtins.int
    BYMINUTES_FIELD_NUMBER: builtins.int
    BYHOURS_FIELD_NUMBER: builtins.int
    BYWEEKDAYS_FIELD_NUMBER: builtins.int
    BYMONTHDAYS_FIELD_NUMBER: builtins.int
    BYMONTHS_FIELD_NUMBER: builtins.int
    freq: global___RecurrenceRule.Frequency.ValueType
    """The frequency specifier of this recurring dispatch"""
    interval: builtins.int
    """How often this dispatch should recur, based on the frequency
    Example:
    - Every 2 hours:
      freq = FREQUENCY_HOURLY
      interval = 2
    """
    @property
    def end_criteria(self) -> global___RecurrenceRule.EndCriteria:
        """When this dispatch should end.
        A dispatch can either recur a fixed number of times, or until a given timestamp.
        If this field is not set, the dispatch will recur indefinitely.bool
        """

    @property
    def byminutes(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.int]:
        """On which minute(s) of the hour does the event occur"""

    @property
    def byhours(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.int]:
        """On which hour(s) of the day does the event occur"""

    @property
    def byweekdays(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[global___RecurrenceRule.Weekday.ValueType]:
        """On which day(s) of the week does the event occur"""

    @property
    def bymonthdays(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.int]:
        """On which day(s) of the month does the event occur"""

    @property
    def bymonths(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.int]:
        """On which month(s) of the year does the event occur"""

    def __init__(
        self,
        *,
        freq: global___RecurrenceRule.Frequency.ValueType = ...,
        interval: builtins.int = ...,
        end_criteria: global___RecurrenceRule.EndCriteria | None = ...,
        byminutes: collections.abc.Iterable[builtins.int] | None = ...,
        byhours: collections.abc.Iterable[builtins.int] | None = ...,
        byweekdays: collections.abc.Iterable[global___RecurrenceRule.Weekday.ValueType] | None = ...,
        bymonthdays: collections.abc.Iterable[builtins.int] | None = ...,
        bymonths: collections.abc.Iterable[builtins.int] | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["end_criteria", b"end_criteria"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["byhours", b"byhours", "byminutes", b"byminutes", "bymonthdays", b"bymonthdays", "bymonths", b"bymonths", "byweekdays", b"byweekdays", "end_criteria", b"end_criteria", "freq", b"freq", "interval", b"interval"]) -> None: ...

global___RecurrenceRule = RecurrenceRule

@typing.final
class DispatchListRequest(google.protobuf.message.Message):
    """Message for listing dispatches for a given microgrid, and an optional filter"""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    MICROGRID_ID_FIELD_NUMBER: builtins.int
    FILTER_FIELD_NUMBER: builtins.int
    microgrid_id: builtins.int
    """The microgrid ID"""
    @property
    def filter(self) -> global___DispatchFilter:
        """Additional filter parameters"""

    def __init__(
        self,
        *,
        microgrid_id: builtins.int = ...,
        filter: global___DispatchFilter | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["filter", b"filter"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["filter", b"filter", "microgrid_id", b"microgrid_id"]) -> None: ...

global___DispatchListRequest = DispatchListRequest

@typing.final
class DispatchFilter(google.protobuf.message.Message):
    """Parameters for filtering the dispatch list"""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    SELECTORS_FIELD_NUMBER: builtins.int
    TIME_INTERVAL_FIELD_NUMBER: builtins.int
    IS_ACTIVE_FIELD_NUMBER: builtins.int
    IS_DRY_RUN_FIELD_NUMBER: builtins.int
    is_active: builtins.bool
    """Filter by active status
    If this field is not set, dispatches of any active status will be included.
    """
    is_dry_run: builtins.bool
    """Filter by dry run status
    If this field is not set, dispatches of any dry run status will be included.
    """
    @property
    def selectors(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___ComponentSelector]:
        """Filter by component ID or category"""

    @property
    def time_interval(self) -> global___TimeIntervalFilter:
        """Filter by time interval
        If no interval is provided, all dispatches starting from the
        current timestamp will be included.
        """

    def __init__(
        self,
        *,
        selectors: collections.abc.Iterable[global___ComponentSelector] | None = ...,
        time_interval: global___TimeIntervalFilter | None = ...,
        is_active: builtins.bool | None = ...,
        is_dry_run: builtins.bool | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["_is_active", b"_is_active", "_is_dry_run", b"_is_dry_run", "is_active", b"is_active", "is_dry_run", b"is_dry_run", "time_interval", b"time_interval"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["_is_active", b"_is_active", "_is_dry_run", b"_is_dry_run", "is_active", b"is_active", "is_dry_run", b"is_dry_run", "selectors", b"selectors", "time_interval", b"time_interval"]) -> None: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing.Literal["_is_active", b"_is_active"]) -> typing.Literal["is_active"] | None: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing.Literal["_is_dry_run", b"_is_dry_run"]) -> typing.Literal["is_dry_run"] | None: ...

global___DispatchFilter = DispatchFilter

@typing.final
class DispatchList(google.protobuf.message.Message):
    """A list of dispatches"""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    DISPATCHES_FIELD_NUMBER: builtins.int
    @property
    def dispatches(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Dispatch]:
        """The dispatches"""

    def __init__(
        self,
        *,
        dispatches: collections.abc.Iterable[global___Dispatch] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["dispatches", b"dispatches"]) -> None: ...

global___DispatchList = DispatchList

@typing.final
class DispatchCreateRequest(google.protobuf.message.Message):
    """Message to create a new dispatch with the given attributes"""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    MICROGRID_ID_FIELD_NUMBER: builtins.int
    TYPE_FIELD_NUMBER: builtins.int
    START_TIME_FIELD_NUMBER: builtins.int
    DURATION_FIELD_NUMBER: builtins.int
    SELECTOR_FIELD_NUMBER: builtins.int
    IS_ACTIVE_FIELD_NUMBER: builtins.int
    IS_DRY_RUN_FIELD_NUMBER: builtins.int
    PAYLOAD_FIELD_NUMBER: builtins.int
    RECURRENCE_FIELD_NUMBER: builtins.int
    microgrid_id: builtins.int
    """The microgrid identifier"""
    type: builtins.str
    """The type of dispatch"""
    duration: builtins.int
    """Duration in seconds"""
    is_active: builtins.bool
    """The "active" status"""
    is_dry_run: builtins.bool
    """The "dry run" status"""
    @property
    def start_time(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """The start time
        When creating a dispatch, ensure that the starting timestamp is set to
        the current time or any future time.
        Timestamps earlier than the current time are not allowed.
        """

    @property
    def selector(self) -> global___ComponentSelector:
        """The component selector"""

    @property
    def payload(self) -> google.protobuf.struct_pb2.Struct:
        """The dispatch payload"""

    @property
    def recurrence(self) -> global___RecurrenceRule:
        """The recurrence rule"""

    def __init__(
        self,
        *,
        microgrid_id: builtins.int = ...,
        type: builtins.str = ...,
        start_time: google.protobuf.timestamp_pb2.Timestamp | None = ...,
        duration: builtins.int = ...,
        selector: global___ComponentSelector | None = ...,
        is_active: builtins.bool = ...,
        is_dry_run: builtins.bool = ...,
        payload: google.protobuf.struct_pb2.Struct | None = ...,
        recurrence: global___RecurrenceRule | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["payload", b"payload", "recurrence", b"recurrence", "selector", b"selector", "start_time", b"start_time"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["duration", b"duration", "is_active", b"is_active", "is_dry_run", b"is_dry_run", "microgrid_id", b"microgrid_id", "payload", b"payload", "recurrence", b"recurrence", "selector", b"selector", "start_time", b"start_time", "type", b"type"]) -> None: ...

global___DispatchCreateRequest = DispatchCreateRequest

@typing.final
class DispatchUpdateRequest(google.protobuf.message.Message):
    """Message to update the dispatch with the given ID, with the given attributes"""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    @typing.final
    class DispatchUpdate(google.protobuf.message.Message):
        """Message containing the updated dispatch attributes"""

        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        @typing.final
        class RecurrenceRuleUpdate(google.protobuf.message.Message):
            """Message containing the updated recurrence rule attributes"""

            DESCRIPTOR: google.protobuf.descriptor.Descriptor

            FREQ_FIELD_NUMBER: builtins.int
            INTERVAL_FIELD_NUMBER: builtins.int
            END_CRITERIA_FIELD_NUMBER: builtins.int
            BYMINUTES_FIELD_NUMBER: builtins.int
            BYHOURS_FIELD_NUMBER: builtins.int
            BYWEEKDAYS_FIELD_NUMBER: builtins.int
            BYMONTHDAYS_FIELD_NUMBER: builtins.int
            BYMONTHS_FIELD_NUMBER: builtins.int
            freq: global___RecurrenceRule.Frequency.ValueType
            """The frequency specifier of this recurring dispatch"""
            interval: builtins.int
            """How often this dispatch should recur, based on the frequency"""
            @property
            def end_criteria(self) -> global___RecurrenceRule.EndCriteria:
                """When this dispatch should end."""

            @property
            def byminutes(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.int]:
                """On which minute(s) of the hour does the event occur"""

            @property
            def byhours(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.int]:
                """On which hour(s) of the day does the event occur"""

            @property
            def byweekdays(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[global___RecurrenceRule.Weekday.ValueType]:
                """On which day(s) of the week does the event occur"""

            @property
            def bymonthdays(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.int]:
                """On which day(s) of the month does the event occur"""

            @property
            def bymonths(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.int]:
                """On which month(s) of the year does the event occur"""

            def __init__(
                self,
                *,
                freq: global___RecurrenceRule.Frequency.ValueType | None = ...,
                interval: builtins.int | None = ...,
                end_criteria: global___RecurrenceRule.EndCriteria | None = ...,
                byminutes: collections.abc.Iterable[builtins.int] | None = ...,
                byhours: collections.abc.Iterable[builtins.int] | None = ...,
                byweekdays: collections.abc.Iterable[global___RecurrenceRule.Weekday.ValueType] | None = ...,
                bymonthdays: collections.abc.Iterable[builtins.int] | None = ...,
                bymonths: collections.abc.Iterable[builtins.int] | None = ...,
            ) -> None: ...
            def HasField(self, field_name: typing.Literal["_freq", b"_freq", "_interval", b"_interval", "end_criteria", b"end_criteria", "freq", b"freq", "interval", b"interval"]) -> builtins.bool: ...
            def ClearField(self, field_name: typing.Literal["_freq", b"_freq", "_interval", b"_interval", "byhours", b"byhours", "byminutes", b"byminutes", "bymonthdays", b"bymonthdays", "bymonths", b"bymonths", "byweekdays", b"byweekdays", "end_criteria", b"end_criteria", "freq", b"freq", "interval", b"interval"]) -> None: ...
            @typing.overload
            def WhichOneof(self, oneof_group: typing.Literal["_freq", b"_freq"]) -> typing.Literal["freq"] | None: ...
            @typing.overload
            def WhichOneof(self, oneof_group: typing.Literal["_interval", b"_interval"]) -> typing.Literal["interval"] | None: ...

        TYPE_FIELD_NUMBER: builtins.int
        START_TIME_FIELD_NUMBER: builtins.int
        DURATION_FIELD_NUMBER: builtins.int
        SELECTOR_FIELD_NUMBER: builtins.int
        IS_ACTIVE_FIELD_NUMBER: builtins.int
        IS_DRY_RUN_FIELD_NUMBER: builtins.int
        PAYLOAD_FIELD_NUMBER: builtins.int
        RECURRENCE_FIELD_NUMBER: builtins.int
        type: builtins.str
        """The type of dispatch"""
        duration: builtins.int
        """Duration in seconds"""
        is_active: builtins.bool
        """The "active" status"""
        is_dry_run: builtins.bool
        """The "dry run" status"""
        @property
        def start_time(self) -> google.protobuf.timestamp_pb2.Timestamp:
            """The start time
            When updating a dispatch, ensure that the starting timestamp is set to
            the current time or any future time.
            Timestamps earlier than the current time are not allowed.
            """

        @property
        def selector(self) -> global___ComponentSelector:
            """The component selector"""

        @property
        def payload(self) -> google.protobuf.struct_pb2.Struct:
            """The dispatch payload"""

        @property
        def recurrence(self) -> global___DispatchUpdateRequest.DispatchUpdate.RecurrenceRuleUpdate:
            """The recurrence rule"""

        def __init__(
            self,
            *,
            type: builtins.str | None = ...,
            start_time: google.protobuf.timestamp_pb2.Timestamp | None = ...,
            duration: builtins.int | None = ...,
            selector: global___ComponentSelector | None = ...,
            is_active: builtins.bool | None = ...,
            is_dry_run: builtins.bool | None = ...,
            payload: google.protobuf.struct_pb2.Struct | None = ...,
            recurrence: global___DispatchUpdateRequest.DispatchUpdate.RecurrenceRuleUpdate | None = ...,
        ) -> None: ...
        def HasField(self, field_name: typing.Literal["_duration", b"_duration", "_is_active", b"_is_active", "_is_dry_run", b"_is_dry_run", "_type", b"_type", "duration", b"duration", "is_active", b"is_active", "is_dry_run", b"is_dry_run", "payload", b"payload", "recurrence", b"recurrence", "selector", b"selector", "start_time", b"start_time", "type", b"type"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing.Literal["_duration", b"_duration", "_is_active", b"_is_active", "_is_dry_run", b"_is_dry_run", "_type", b"_type", "duration", b"duration", "is_active", b"is_active", "is_dry_run", b"is_dry_run", "payload", b"payload", "recurrence", b"recurrence", "selector", b"selector", "start_time", b"start_time", "type", b"type"]) -> None: ...
        @typing.overload
        def WhichOneof(self, oneof_group: typing.Literal["_duration", b"_duration"]) -> typing.Literal["duration"] | None: ...
        @typing.overload
        def WhichOneof(self, oneof_group: typing.Literal["_is_active", b"_is_active"]) -> typing.Literal["is_active"] | None: ...
        @typing.overload
        def WhichOneof(self, oneof_group: typing.Literal["_is_dry_run", b"_is_dry_run"]) -> typing.Literal["is_dry_run"] | None: ...
        @typing.overload
        def WhichOneof(self, oneof_group: typing.Literal["_type", b"_type"]) -> typing.Literal["type"] | None: ...

    ID_FIELD_NUMBER: builtins.int
    UPDATE_MASK_FIELD_NUMBER: builtins.int
    UPDATE_FIELD_NUMBER: builtins.int
    id: builtins.int
    """The dispatch identifier"""
    @property
    def update_mask(self) -> google.protobuf.field_mask_pb2.FieldMask:
        """Field mask specifying which fields should be updated"""

    @property
    def update(self) -> global___DispatchUpdateRequest.DispatchUpdate:
        """The updated dispatch attributes"""

    def __init__(
        self,
        *,
        id: builtins.int = ...,
        update_mask: google.protobuf.field_mask_pb2.FieldMask | None = ...,
        update: global___DispatchUpdateRequest.DispatchUpdate | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["update", b"update", "update_mask", b"update_mask"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["id", b"id", "update", b"update", "update_mask", b"update_mask"]) -> None: ...

global___DispatchUpdateRequest = DispatchUpdateRequest

@typing.final
class DispatchGetRequest(google.protobuf.message.Message):
    """Message to get a single dispatch by its ID"""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    ID_FIELD_NUMBER: builtins.int
    id: builtins.int
    """The dispatch identifier"""
    def __init__(
        self,
        *,
        id: builtins.int = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["id", b"id"]) -> None: ...

global___DispatchGetRequest = DispatchGetRequest

@typing.final
class DispatchDeleteRequest(google.protobuf.message.Message):
    """Message to delete a single dispatch by its ID"""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    ID_FIELD_NUMBER: builtins.int
    id: builtins.int
    """The dispatch identifier"""
    def __init__(
        self,
        *,
        id: builtins.int = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["id", b"id"]) -> None: ...

global___DispatchDeleteRequest = DispatchDeleteRequest
